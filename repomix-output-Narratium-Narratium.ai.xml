This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build.yml
    BuildDockerImage.yml
    sync.yml
app/
  character/
    page.tsx
  character-cards/
    page.tsx
  contexts/
    SoundContext.tsx
  creator-area/
    page.tsx
  creator-input/
    page.tsx
  i18n/
    locales/
      en.json
      zh.json
    fonts.ts
    FontWrapper.tsx
    index.ts
    LanguageProvider.tsx
  styles/
    fantasy-ui.css
    fonts.css
    local-fonts.css
  globals.css
  layout.tsx
  metadata.ts
  not-found.tsx
  page.tsx
components/
  __tests__/
    ChatHtmlBubble.test.ts
  AdvancedSettingsEditor.tsx
  CharacterAvatarBackground.tsx
  CharacterCardCarousel.tsx
  CharacterCardGrid.tsx
  CharacterChatHeader.tsx
  CharacterChatPanel.tsx
  CharacterSidebar.tsx
  ChatHtmlBubble.tsx
  CreatePresetModal.tsx
  DialogueTreeModal.tsx
  DownloadCharacterModal.tsx
  EditCharacterModal.tsx
  EditPromptModal.tsx
  GoogleAnalytics.tsx
  HomeContent.tsx
  ImportCharacterModal.tsx
  ImportPresetModal.tsx
  ImportRegexScriptModal.tsx
  ImportWorldBookModal.tsx
  LoadingTransition.tsx
  LoginModal.tsx
  MainLayout.tsx
  MobileBottomNav.tsx
  ModelSidebar.tsx
  PresetEditor.tsx
  PromptEditor.tsx
  RegexScriptEditor.tsx
  RegexScriptEntryEditor.tsx
  SettingsDropdown.tsx
  Sidebar.tsx
  TagColorEditor.tsx
  UserTour.tsx
  WorldBookEditor.tsx
  WorldBookEntryEditor.tsx
contexts/
  SoundContext.tsx
  SymbolColorStore.ts
docs/
  GETTING_STARTED.md
  PROBLEM.md
  VERCEL_DEPLOYMENT.md
function/
  character/
    delete.ts
    import.ts
    list.ts
  data/
    export-import.ts
    google-control.ts
    google-request.ts
  dialogue/
    chat.ts
    delete.ts
    edit.ts
    incremental-info.ts
    info.ts
    init.ts
    save-prompts.ts
    truncate.ts
    update.ts
  preset/
    download.ts
    edit.ts
    global.ts
    import.ts
  regex/
    add.ts
    delete.ts
    get-setting.ts
    get.ts
    global.ts
    import.ts
    update-setting.ts
    update.ts
  worldbook/
    bulk-operations.ts
    delete.ts
    edit.ts
    global.ts
    import.ts
    info.ts
    settings.ts
hooks/
  useTour.ts
lib/
  adapter/
    tagReplacer.ts
  core/
    agent-engine.ts
    agent-service.ts
    agent-tools.ts
    character-dialogue.ts
    character-history.ts
    character.ts
    preset-assembler.ts
    prompt-assembler.ts
    regex-processor.ts
    world-book.ts
  data/
    agent-operation.ts
    character-dialogue-operation.ts
    character-record-operation.ts
    local-storage.ts
    preset-operation.ts
    regex-script-operation.ts
    world-book-operation.ts
  models/
    agent-model.ts
    character-dialogue-model.ts
    character-model.ts
    character-prompts-model.ts
    node-model.ts
    parsed-response.ts
    preset-model.ts
    rawdata-model.ts
    regex-script-model.ts
    world-book-model.ts
  nodeflow/
    ContextNode/
      ContextNode.ts
      ContextNodeTools.ts
    LLMNode/
      LLMNode.ts
      LLMNodeTools.ts
    OutputNode/
      OutputNode.ts
    PresetNode/
      PresetNode.ts
      PresetNodeTools.ts
    RegexNode/
      RegexNode.ts
      RegexNodeTools.ts
    UserInputNode/
      UserInputNode.ts
    WorldBookNode/
      WorldBookNode.ts
      WorldBookNodeTools.ts
    NodeBase.ts
    NodeContext.ts
    NodeTool.ts
    types.ts
    WorkflowEngine.ts
  prompts/
    character-prompts.ts
    preset-prompts.ts
  workflow/
    examples/
      DialogueWorkflow.ts
    BaseWorkflow.ts
utils/
  character-parser.ts
  google-analytics.ts
  response-parser.ts
  version-compare.ts
.env.example
.gitignore
docker-compose.yml
Dockerfile
eslint.config.mjs
LICENSE
next.config.ts
package.json
postcss.config.mjs
README_ZH.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/build.yml">
name: Build and Package
on:
  workflow_dispatch:
jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        include:
          - os: ubuntu-latest
            artifact_name: Narratium-linux
            asset_name: narratium-linux.tar.gz
            output_dir: pake/Narratium-linux
          - os: windows-latest
            artifact_name: Narratium-windows
            asset_name: narratium-windows.zip
            output_dir: pake/Narratium-win32
          - os: macos-latest
            artifact_name: Narratium-macos
            asset_name: narratium-macos.dmg
            output_dir: pake/Narratium.app
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
    - name: Install Linux dependencies
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt update
        sudo apt install -y libwebkit2gtk-4.1-dev \
          build-essential \
          curl \
          wget \
          file \
          libxdo-dev \
          libssl-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev
    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
        run_install: false
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    - name: Install dependencies
      run: pnpm install
    - name: Build Next.js app
      run: pnpm build
    - name: Install Pake CLI
      run: npm install -g pake-cli
    - name: Debug - Check icon files
      if: matrix.os != 'windows-latest'
      run: |
        echo "Checking icon files:"
        ls -la public/
        echo "Icon file exists:"
        if [ -f "public/icon.ico" ]; then echo "Yes"; else echo "No"; fi
        if [ -f "public/icon.png" ]; then echo "Yes"; else echo "No"; fi
        if [ -f "public/icon.icns" ]; then echo "Yes"; else echo "No"; fi
    - name: Debug - Check icon files (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        echo "Checking icon files:"
        Get-ChildItem -Path public/
        echo "Icon file exists:"
        if (Test-Path -Path "public/icon.ico") { echo "Yes" } else { echo "No" }
        if (Test-Path -Path "public/icon.png") { echo "Yes" } else { echo "No" }
        if (Test-Path -Path "public/icon.icns") { echo "Yes" } else { echo "No" }
    - name: Build with Pake (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: pake out/index.html --name Narratium --use-local-file --icon public/icon.png
    - name: Build with Pake (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        mkdir -p pake/icons
        Copy-Item "public\icon.ico" "pake\icons\icon.ico" -Force
        pake out/index.html --name Narratium
    - name: Build with Pake (macOS)
      if: matrix.os == 'macos-latest'
      run: pake out/index.html --name Narratium --use-local-file --icon public/icon.icns
    - name: Debug - List files (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        echo "Current directory:"
        pwd
        echo "Files in current directory:"
        ls -la
        echo "Files in pake directory (if exists):"
        ls -la pake || echo "pake directory not found"
        echo "Finding DMG files:"
        find . -name "*.dmg"
    - name: Package artifacts (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        mkdir -p dist
        echo "Current directory:"
        pwd
        echo "Files in current directory:"
        ls -la
        if [ -f "pake.deb" ]; then
          echo "Found pake.deb file, using it as the artifact"
          cp pake.deb dist/${{ matrix.asset_name }}
        else
          DEB_FILE=$(find . -name "*.deb" | head -n 1)
          if [ -n "$DEB_FILE" ]; then
            echo "Found .deb file: $DEB_FILE"
            cp "$DEB_FILE" dist/${{ matrix.asset_name }}
          else
            echo "No .deb file found, trying to find Narratium directory"
            NARRATIUM_DIR=$(find . -type d -name "Narratium*" | grep -v "node_modules" | head -n 1)
            if [ -z "$NARRATIUM_DIR" ]; then
              echo "Error: Could not find Narratium directory or .deb file"
              exit 1
            else
              echo "Found Narratium directory: $NARRATIUM_DIR"
              tar -czf dist/${{ matrix.asset_name }} "$NARRATIUM_DIR"
            fi
          fi
        fi
    - name: Package artifacts (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        mkdir -p dist
        New-Item -Path "temp_for_zip" -ItemType Directory -Force
        $msiFile = Get-ChildItem -Path "C:\npm\prefix\node_modules\pake-cli\src-tauri\target\release\bundle\msi\*.msi" -File | Select-Object -First 1
        if ($msiFile) {
          echo "Found MSI file: $($msiFile.FullName)"
          Copy-Item $msiFile.FullName -Destination "temp_for_zip\Narratium.msi"
          $exeFile = Get-ChildItem -Path "C:\npm\prefix\node_modules\pake-cli\src-tauri\target\release\*.exe" -File | Select-Object -First 1
          if ($exeFile) {
            echo "Found EXE file: $($exeFile.FullName)"
            Copy-Item $exeFile.FullName -Destination "temp_for_zip\Narratium.exe"
          }
          Set-Content -Path "temp_for_zip\README.txt" -Value "Narratium Windows Installation`n`nThis package contains:`n- Narratium.msi: Windows installer`n`nTo install, double-click the MSI file."
          Compress-Archive -Path "temp_for_zip\*" -DestinationPath "dist\${{ matrix.asset_name }}" -Force
        } else {
          $msiFile = Get-ChildItem -Path . -Recurse -Filter "*.msi" | Where-Object { $_.FullName -like "*Narratium*.msi" } | Select-Object -First 1
          if ($msiFile) {
            echo "Found MSI file via fallback search: $($msiFile.FullName)"
            Copy-Item $msiFile.FullName -Destination "temp_for_zip\Narratium.msi"
            Set-Content -Path "temp_for_zip\README.txt" -Value "Narratium Windows Installation`n`nThis package contains:`n- Narratium.msi: Windows installer`n`nTo install, double-click the MSI file."
            Compress-Archive -Path "temp_for_zip\*" -DestinationPath "dist\${{ matrix.asset_name }}" -Force
          } else {
            echo "Error: Could not find MSI file"
            exit 1
          }
        }
    - name: Package artifacts (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        mkdir -p dist
        DMG_FILE=$(find . -name "Narratium*.dmg" | head -n 1)
        if [ -z "$DMG_FILE" ]; then
          echo "Error: DMG file not found"
          exit 1
        else
          echo "Found DMG file: $DMG_FILE"
          cp "$DMG_FILE" dist/${{ matrix.asset_name }}
        fi
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: dist/${{ matrix.asset_name }}
        retention-days: 30
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/Narratium-linux/narratium-linux.tar.gz
            artifacts/Narratium-windows/narratium-windows.zip
            artifacts/Narratium-macos/narratium-macos.dmg
          draft: false
          prerelease: false
</file>

<file path=".github/workflows/BuildDockerImage.yml">
name: Build and Push Docker Image
on:
  workflow_dispatch:
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get latest tag as version
        id: get_latest_tag
        run: |
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "latest")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/narratium-ai:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/narratium-ai:${{ env.LATEST_TAG }}
</file>

<file path=".github/workflows/sync.yml">
name: Upstream Sync
permissions:
  contents: write
on:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:
jobs:
  sync_latest_from_upstream:
    name: Sync latest commits from upstream repo
    runs-on: ubuntu-latest
    if: ${{ github.event.repository.fork }}
    steps:
      - name: Checkout target repo
        uses: actions/checkout@v3
      - name: Sync upstream changes
        id: sync
        uses: aormsby/Fork-Sync-With-Upstream-action@v3.4
        with:
          upstream_sync_repo: Narratium/Narratium.ai
          upstream_sync_branch: main
          target_sync_branch: main
          target_repo_token: ${{ secrets.GITHUB_TOKEN }}
          test_mode: false
      - name: Sync check
        if: failure()
        run: |
          echo "[Error] 由于上游仓库的 workflow 文件变更，导致 GitHub 自动暂停了本次自动更新，你需要手动 Sync Fork 一次。"
          exit 1
</file>

<file path="app/character/page.tsx">
import { useState, useEffect, useRef } from "react";
import { useSearchParams } from "next/navigation";
import { useLanguage } from "@/app/i18n";
import CharacterSidebar from "@/components/CharacterSidebar";
import { PromptType } from "@/lib/models/character-prompts-model";
import { v4 as uuidv4 } from "uuid";
import { initCharacterDialogue } from "@/function/dialogue/init";
import { getCharacterDialogue } from "@/function/dialogue/info";
import { handleCharacterChatRequest } from "@/function/dialogue/chat";
import { switchDialogueBranch } from "@/function/dialogue/truncate";
import { deleteDialogueNode } from "@/function/dialogue/delete";
import CharacterChatPanel from "@/components/CharacterChatPanel";
import WorldBookEditor from "@/components/WorldBookEditor";
import RegexScriptEditor from "@/components/RegexScriptEditor";
import PresetEditor from "@/components/PresetEditor";
import CharacterChatHeader from "@/components/CharacterChatHeader";
import UserTour from "@/components/UserTour";
import { useTour } from "@/hooks/useTour";
interface Character {
  id: string;
  name: string;
  personality?: string;
  avatar_path?: string;
}
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp?: string;
}
⋮----
const switchToView = (targetView: "chat" | "worldbook" | "regex" | "preset") =>
const toggleView = () =>
const toggleRegexEditor = () =>
const truncateMessagesAfter = async (nodeId: string) =>
const handleRegenerate = async (nodeId: string) =>
const fetchLatestDialogue = async () =>
⋮----
const loadCharacterAndDialogue = async () =>
⋮----
const initializeNewDialogue = async (charId: string) =>
const handleSendMessage = async (message: string) =>
⋮----
const handleSwitchToPresetView = (event: any) =>
⋮----
const toggleSidebar = () =>
const handleSuggestedInput = (input: string) =>
⋮----
onViewSwitch=
</file>

<file path="app/character-cards/page.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { motion } from "framer-motion";
import ImportCharacterModal from "@/components/ImportCharacterModal";
import EditCharacterModal from "@/components/EditCharacterModal";
import DownloadCharacterModal from "@/components/DownloadCharacterModal";
import CharacterCardGrid from "@/components/CharacterCardGrid";
import CharacterCardCarousel from "@/components/CharacterCardCarousel";
import { getAllCharacters } from "@/function/character/list";
import { deleteCharacter } from "@/function/character/delete";
import { handleCharacterUpload } from "@/function/character/import";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
⋮----
const checkMobile = () =>
⋮----
const fetchCharacters = async () =>
const handleDeleteCharacter = async (characterId: string) =>
const handleEditClick = (character: Character, e: React.MouseEvent) =>
const handleEditSuccess = () =>
const downloadPresetCharacters = async () =>
</file>

<file path="app/contexts/SoundContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
interface SoundContextType {
  soundEnabled: boolean;
  toggleSound: () => void;
}
⋮----
export function useSoundContext()
interface SoundProviderProps {
  children: ReactNode;
}
export function SoundProvider(
⋮----
const toggleSound = () =>
</file>

<file path="app/creator-area/page.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
</file>

<file path="app/creator-input/page.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import { Send, Sparkles } from "lucide-react";
import { useRouter } from "next/navigation";
import { useLanguage } from "../i18n";
⋮----
const handleSubmit = async (e: React.FormEvent) =>
const handleKeyPress = (e: React.KeyboardEvent) =>
⋮----
onChange=
⋮----
placeholder=
</file>

<file path="app/i18n/locales/en.json">
{
  "common": {
    "save": "Save",
    "cancel": "Cancel",
    "close": "Close",
    "return": "Return",
    "settings": "Settings",
    "switchToEnglish": "Switch to English",
    "switchToChinese": "Switch to Chinese",
    "soundOn": "Sound On",
    "soundOff": "Sound Off",
    "saving": "Saving...",
    "defaultAutoFillFileName": "Default: Auto-fill from file name",
    "exportData": "Export Data",
    "exportDataToGoogle": "Export Data To Google",
    "importData": "Import Data",
    "importDataFromGoogle": "Import Data From Google",
    "exportFailed": "Export failed, please try again",
    "importFailed": "Import failed, please try again"
  },
  "sidebar": {
    "home": "Home",
    "gameArea": "Game Area",
    "creator": "Creator",
    "creationArea": "Creation Area",
    "historyRecords": "History Records",
    "newStory": "New Adventure",
    "storyCollection": "Story Collection",
    "characterCards": "Character Cards",
    "characterMarket": "Character Market",
    "login": "Login & Explore",
    "nologin": "Define User Name",
    "logout": "Logout",
    "collapseHome": "Collapse Home",
    "expandHome": "Expand Home",
    "collapseCreation": "Collapse Game Area",
    "expandCreation": "Expand Game Area",
    "collapseCreator": "Collapse Creation Area",
    "expandCreator": "Expand Creation Area",
    "goToUpdate": "Go to Update",
    "newVersionAvailable": "New Version Available",
    "currentVersion": "Current: v{version}"
  },
  "modelSettings": {
    "title": "Model Settings",
    "llmType": "LLM Type",
    "baseUrl": "Base URL",
    "model": "Model",
    "apiKey": "API Key",
    "language": "Output Language",
    "chinese": "Chinese",
    "english": "English",
    "saveSettings": "Click to enable",
    "settingsSaved": "Settings Saved",
    "commonModels": "Common Models:",
    "modelList": "Model List",
    "selectModel": "Select a model...",
    "modelListUnavailable": "Model list unavailable",
    "configurations": "API Configurations",
    "newConfig": "New Config",
    "configName": "Configuration Name",
    "configNamePlaceholder": "My API Configuration",
    "createConfig": "Create Configuration",
    "nameRequired": "Name is required",
    "cannotDeleteLastConfig": "Cannot delete the last configuration",
    "confirmDelete": "Are you sure you want to delete this configuration?",
    "createFirstConfig": "Create Your First Configuration",
    "noConfigs": "No API configurations yet",
    "getModelList": "Get Model List",
    "getModelListSuccess": "Get Model List Success",
    "getModelListError": "Get Model List Error",
    "configCreated": "Configuration created",
    "doubleClickToEditName": "Double click to edit name",
    "testModel": "Test Model",
    "testing": "Testing...",
    "testSuccess": "Model test successful",
    "testError": "Model test failed",
    "apiTestFailed": "API test failed",
    "modelTestFailed": "Model test failed"
  },
  "llmSettings": {
    "title": "Settings",
    "modelType": "Model Type",
    "presets": "Presets",
    "creative": "Creative",
    "balanced": "Balanced",
    "precise": "Precise",
    "commonParams": "Common",
    "advancedParams": "Advanced",
    "temperature": "Temperature",
    "temperatureDescription": "Controls randomness in text generation. Higher values produce more diverse outputs, lower values produce more deterministic outputs.",
    "maxTokens": "Max Tokens",
    "maxTokensDescription": "Maximum number of tokens to generate. Leave empty to use model default.",
    "timeout": "Timeout",
    "timeoutDescription": "Timeout for API requests in milliseconds. Leave empty to use default.",
    "maxRetries": "Max Retries",
    "maxRetriesDescription": "Maximum number of retries when API requests fail.",
    "topP": "Top P",
    "topPDescription": "Controls diversity via nucleus sampling. Lower values consider fewer high-probability options.",
    "frequencyPenalty": "Frequency Penalty",
    "frequencyPenaltyDescription": "Penalizes tokens based on their frequency in the text so far. Higher values reduce repetition.",
    "presencePenalty": "Presence Penalty",
    "presencePenaltyDescription": "Penalizes tokens that have appeared in the text so far. Higher values encourage new topics.",
    "topK": "Top K",
    "topKDescription": "Limits token selection to the K most likely tokens. Lower values make output more focused.",
    "repeatPenalty": "Repeat Penalty",
    "repeatPenaltyDescription": "Penalizes repeated tokens. Higher values reduce repetition in Ollama models.",
    "optional": "Optional, leave empty for default"
  },
  "sessionList": {
    "loading": "Summoning history scrolls...",
    "noHistory": "No history records yet",
    "continue": "Continue",
    "delete": "Delete"
  },
  "homePage": {
    "slogan": "Within each of us burns a flame",
    "newAdventure": "Begin a New Adventure",
    "continueJourney": "Continue Your Journey",
    "immediatelyStart": "Immediately Start"
  },
  "auth": {
    "username": "Username",
    "password": "Password",
    "login": "Login",
    "register": "Register",
    "welcomeBack": "Welcome Back",
    "continueJourney": "Sign in to continue your journey",
    "emailPlaceholder": "Press Enter to apply username",
    "passwordPlaceholder": "Enter your password...",
    "codePlaceholder": "Enter the verification code...",
    "wizardQuestion": "✨ Brave adventurer, please leave your name",
    "spellQuestion": "🔮 Cast your protective spell, it will guard your fantastic journey!",
    "codeQuestion": "⚡ Enter the mysterious runes sent by the cosmic sea to prove your identity!",
    "getCode": "Get Code",
    "openingMagicDoor": "Opening the magic door...",
    "magicSpell": "Password Login",
    "starCode": "Verification Code",
    "agreementText": "By continuing, you agree to our",
    "termsOfService": "Terms of Service",
    "privacyPolicy": "Privacy Policy"
  },
  "storiesPage": {
    "title": "My Story Collection",
    "createNewStory": "Create New Story",
    "loading": "Loading stories...",
    "noStories": "You haven't created any stories yet",
    "createFirstStory": "Create Your First Story",
    "recentlyCreated": "Recently Created",
    "fetchError": "Failed to fetch stories",
    "edit": "Edit",
    "delete": "Delete",
    "play": "Play",
    "deleteConfirm": "Are you sure you want to delete this story?",
    "deleteSuccess": "Story deleted",
    "deleteFailed": "Failed to delete story"
  },
  "newStory": {
    "title": "Create New Story",
    "editTitle": "Edit Story",
    "storyTitle": "Story Title",
    "storyFramework": "Story Setting",
    "characterInfo": "Character Information",
    "questionTitle": "✨ What name shall your legend be known by?",
    "questionFramework": "✨ In what mystical realm will your adventure unfold?",
    "questionCharacter": "✨ What form will you take in this immortal tale?",
    "titlePlaceholder": "Name your epic tale",
    "frameworkPlaceholder": "Describe your fantasy world",
    "characterPlaceholder": "Reveal your hero's identity",
    "create": "Begin Your Legend",
    "creating": "Weaving your legendary tale...",
    "update": "Update Story",
    "updating": "Updating...",
    "cancel": "Cancel",
    "fillAllFields": "Please fill in all required fields",
    "createFailed": "Failed to create story, please try again",
    "updateFailed": "Failed to update story, please try again",
    "updateSuccess": "Story updated successfully"
  },
  "notFound": {
    "title": "The Path Ahead Is Not Yet Open",
    "subtitle": "This Realm Is Still Under Construction",
    "message": "Noble Dreamer, the magical scroll you seek appears to be lost or not yet created.",
    "backToHome": "Return to Home",
    "exploreMore": "Explore Later"
  },
  "game": {
    "fetchStoryFailed": "Failed to fetch story details",
    "fetchStoryFailedRetry": "Failed to fetch story details, please try again",
    "loadSessionFailed": "Failed to load session history",
    "loadSessionFailedRetry": "Failed to load session history, please try again",
    "initializeFailed": "Game initialization failed",
    "setupFailed": "Game setup failed",
    "cannotReadResponseStream": "Cannot read response stream",
    "generatingStory": "Generating story...",
    "actionFailed": "Action failed",
    "confirmDelete": "Are you sure you want to delete this story? This action cannot be undone.",
    "deleteFailed": "Failed to delete story",
    "deleteFailedRetry": "Failed to delete story, please try again",
    "storyNotExist": "Story of Session Not Found", 
    "cannotFindStory": "Cannot find story with ID {id}",
    "backToStoryList": "Back to Story List",
    "expandSidebar": "Expand Sidebar",
    "collapseSidebar": "Collapse Sidebar",
    "storySummary": "Story Summary",
    "storyFramework": "Story Framework",
    "characterInfo": "Character Information",
    "starting": "Starting...",
    "startAdventure": "Begin Adventure",
    "inputCustomAction": "Enter custom action...",
    "execute": "Execute",
    "deleting": "Deleting...",
    "deleteStory": "Delete Story",
    "gameInfo": "Game Information",
    "memoryManagement": "Memory Management",
    "navigation": "Navigation",
    "collapse": "Collapse",
    "expand": "Expand",
    "memoryPlaceholder": "Game memories will be displayed here",
    "memoryDescription": "Memory management allows you to view and edit segments of the game",
    "memoryInstructions": "Click a node to view full content, edges show your actions",
    "editMemory": "Edit Memory",
    "memorySummary": "Memory Summary",
    "fullMemoryContent": "Full Memory Content",
    "editMemoryPlaceholder": "Edit your game memory...",
    "noSessionFound": "No Session Found",
    "startSessionFirst": "Please start a game session first to view memories",
    "loadingMemories": "Loading memories...",
    "jumpToNode": "Jump to this node",
    "expandMemory": "Expand memory content"
  },
  "characterCardsPage": {
    "title": "Character Cards",
    "importCharacter": "Import Character",
    "importFirstCharacter": "Import Your First Character",
    "noCharacters": "You don't have any characters yet",
    "loading": "Loading...",
    "downloadingPresets": "Downloading preset characters...",
    "fetchError": "Failed to fetch characters",
    "deleteFailed": "Failed to delete character",
    "delete": "Delete",
    "edit": "Edit",
    "chat": "Chat",
    "recentlyCreated": "Recently Created",
    "downloadCharacter": "Community Download Character"
  },
  "editCharacterModal": {
    "title": "Edit Character",
    "name": "Name",
    "description": "Description",
    "personality": "Personality",
    "scenario": "Scenario",
    "firstMessage": "Opening Message",
    "mesExample": "Message Examples",
    "creatorComment": "Creator Comments",
    "save": "Save",
    "cancel": "Cancel"
  },
  "importCharacterModal": {
    "title": "Import Character",
    "description": "Select or drag and drop a SillyTavern PNG character card file to import",
    "dragOrClick": "Drag file here or click to select",
    "pngFormat": "Only SillyTavern PNG character card files are supported",
    "pngOnly": "Please select a SillyTavern PNG file",
    "noFileSelected": "Please select a file first",
    "uploadFailed": "Upload failed, please try again",
    "import": "Import",
    "uploading": "Uploading..."
  },
  "characterMarketPage": {
    "description": "Explore a variety of fascinating characters to bring your stories to life",
    "searchPlaceholder": "Search character names or descriptions",
    "allTags": "All",
    "loading": "Loading characters...",
    "noResults": "No matching characters found",
    "clearFilters": "Clear Filters",
    "by": "By:",
    "download": "Download Character",
    "viewDetails": "View Details"
  },
  "characterChat": {
    "navigation": "Navigation",
    "characterInfo": "Character Info",
    "actions": "Actions",
    "expandSidebar": "Expand Sidebar",
    "collapseSidebar": "Collapse Sidebar",
    "backToCharacters": "Back to Characters",
    "Conversation": "Context Manager",
    "noPersonality": "No personality defined",
    "typeMessage": "Type a message...",
    "startConversation": "Start a conversation...",
    "send": "Send",
    "isTyping": "is typing...",
    "suggestedResponse1": "Tell me more",
    "suggestedResponse2": "What happened next?",
    "suggestedResponse3": "How do you feel about that?",
    "promptMode": "Prompt Mode",
    "companionMode": "Progression Mode",
    "nsfwMode": "Companion Mode",
    "explicitMode": "NSFW Mode",
    "customMode":"custom Mode",
    "innerThought": "Inner Thought",
    "screen": "Screen",
    "speech": "Speech",
    "nextPrompt": "Next Step",
    "storyProgress": "Story Progress",
    "storyProgressHint": "Please advance the story plot forward, make the story more interesting and engaging.",
    "perspective": "Perspective",
    "novelPerspective": "Novel Perspective",
    "protagonistPerspective": "Protagonist Perspective",
    "novelPerspectiveHint": "Please use a novel perspective to narrate, describing the scene and character actions in third person.",
    "protagonistPerspectiveHint": "Please use the protagonist's perspective to narrate, using first person to describe thoughts and feelings.",
    "sceneTransition": "Scene Setting",
    "sceneTransitionHint": "Please add scene descriptions and environmental details to enhance the atmosphere.",
    "screenPlaceholder": "Describe the scene or actions...",
    "speechPlaceholder": "What does the character say...",
    "innerThoughtPlaceholder": "What does the character think...",
    "playerInput": "Player Input",
    "responseInstructions": "Response Instructions",
    "characterStatus": "Character Status",
    "responseLength": "Model Response Length",
    "customPrompt": "Custom Prompt",
    "customPromptFor": "Custom Prompts",
    "presets": "Presets",
    "presetEditor": "Preset Editor",
    "githubPresets": "GitHub Presets",
    "noPresets": "No presets available",
    "prefixPrompt": "Prefix Prompt",
    "chainOfThoughtPrompt": "Chain of Thought",
    "suffixPrompt": "Suffix Prompt",
    "prefixPromptDescription": "The prefix prompt is placed at the beginning of the prompt, used to set the character's basic behavior and background.",
    "chainOfThoughtPromptDescription": "The chain of thought prompt is placed in the middle of the prompt, used to guide the character's thinking process.",
    "suffixPromptDescription": "The suffix prompt is placed at the end of the prompt, used to emphasize the character's response format and restrictions.",
    "prefixPromptPlaceholder": "Enter prefix prompt...",
    "chainOfThoughtPromptPlaceholder": "Enter chain of thought prompt...",
    "suffixPromptPlaceholder": "Enter suffix prompt...",
    "autoSaveEnabled": "Auto-save enabled",
    "initializing": "Initializing character...",
    "extractingTemplate": "Extracting character template...",
    "loadingTimeHint": "Loading usually takes 5-20 seconds. If it exceeds 30 seconds, please check your API configuration.",
    "error": "Error",
    "characterNotFound": "Character not found",
    "loading": "Loading...Parsing status, please wait...",
    "worldBook": "World Book",
    "regex": "Regex Script",
    "preset": "Preset",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "filtered": "Filtered",
    "advancedSettings": "Advanced Settings",
    "tagColorEditor": "Tag Color Editor",
    "enterTagName": "Enter tag name...",
    "add": "Add",
    "saveChanges": "Save Changes",
    "enterSymbol": "When entering a tag, it will match <tag>...</tag>",
    "enableStreaming": "Enable Streaming",
    "disableStreaming": "Disable Streaming",
    "jumpToMessage": "Jump to Message",
    "regenerateMessage": "Regenerate Message",
    "enableFastModel": "Enable Fast Mode",
    "disableFastModel": "Disable Fast Mode"
  },
  "preset": {
    "title": "Preset Manager",
    "createPreset": "Create Preset",
    "importPreset": "Import Preset",
    "sortBy": "Sort By",
    "sortOrder": "Sort Order",
    "filterBy": "Filter By",
    "ascending": "Ascending",
    "descending": "Descending",
    "asc": "Asc",
    "desc": "Desc",
    "all": "All",
    "active": "With Prompts",
    "empty": "Empty",
    "name": "Name",
    "promptCount": "Prompt Count",
    "lastUpdated": "Last Updated",
    "status": "Status",
    "prompts": "Prompts",
    "updated": "Updated",
    "actions": "Actions",
    "active_status": "Active",
    "empty_status": "Empty",
    "total": "Total",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "filtered": "Filtered",
    "loading": "Loading Presets...",
    "noPresetsFound": "No Presets Found",
    "createFirstPreset": "Create your first preset to get started",
    "enterPresetName": "Enter preset name:",
    "createSuccess": "Preset created successfully",
    "createFailed": "Failed to create preset",
    "deleteConfirm": "Are you sure you want to delete this preset?",
    "deleteSuccess": "Preset deleted successfully",
    "deleteFailed": "Failed to delete preset",
    "loadFailed": "Failed to load presets",
    "loadDetailsFailed": "Failed to load preset details",
    "expandDetails": "Expand details",
    "collapseDetails": "Collapse details",
    "promptsTitle": "Prompts",
    "addPrompt": "Add Prompt",
    "enterPromptName": "Enter prompt name:",
    "addPromptSuccess": "Prompt added successfully",
    "addPromptFailed": "Failed to add prompt",
    "deletePromptConfirm": "Are you sure you want to delete this prompt?",
    "deletePromptSuccess": "Prompt deleted successfully",
    "deletePromptFailed": "Failed to delete prompt",
    "noPromptsInPreset": "No prompts in this preset",
    "enabled_prompt": "Enabled",
    "disabled_prompt": "Disabled",
    "system": "System",
    "deletePrompt": "Delete prompt",
    "promptEnabledSuccess": "Prompt enabled successfully",
    "promptDisabledSuccess": "Prompt disabled successfully",
    "togglePromptFailed": "Failed to toggle prompt",
    "applyPresetSuccess": "Preset applied successfully",
    "applyPresetFailed": "Failed to apply preset",
    "applyPreset": "Apply Preset",
    "presetApplied": "Preset Active",
    "cannotApplyEmpty": "Cannot apply empty preset",
    "enablePreset": "Enable preset",
    "disablePreset": "Disable preset",
    "presetEnabledSuccess": "Preset enabled successfully",
    "presetEnabledExclusiveSuccess": "Preset enabled successfully (other presets disabled)",
    "presetDisabledSuccess": "Preset disabled successfully",
    "togglePresetFailed": "Failed to toggle preset",
    "presetDisabled": "Preset is disabled",
    "cannotApplyDisabled": "Cannot apply disabled preset",
    "toggle": "Toggle",
    "presetName": "Preset Name",
    "presetNamePlaceholder": "Enter preset name",
    "presetNameRequired": "Preset name is required",
    "creating": "Creating...",
    "create": "Create",
    "cancel": "Cancel",
    "editPrompt": "Edit Prompt",
    "promptContent": "Prompt Content",
    "saving": "Saving",
    "save": "Save"
  },
  "importPreset": {
    "title": "Import Preset",
    "dragDropFile": "Import Preset File",
    "dropFileHere": "Drop your file here",
    "browseFiles": "Browse Files",
    "dragAndDrop": "Drag and drop a JSON preset file, or click to browse",
    "importing": "Importing...",
    "importSuccess": "Import Successful",
    "importFailed": "Import Failed",
    "presetImported": "Preset has been imported successfully!",
    "importError": "An error occurred during import",
    "customizePreset": "Customize Preset",
    "presetName": "Preset Name",
    "presetNameDesc": "Leave empty to use the original name from the file",
    "confirmImport": "Confirm Import",
    "guidelines": "Import Guidelines",
    "jsonFormat": "Preset files must be in JSON format",
    "validStructure": "Files should contain valid preset structure with prompts",
    "noOverwrite": "Existing presets with same name will not be overwritten",
    "maxFileSize": "Maximum file size: 10MB",
    "selectJsonFile": "Please select a JSON file",
    "failedToImport": "Failed to import",
    "cancel": "Cancel"
  },
  "worldBook": {
    "title": "World Book",
    "addEntry": "Add Entry",
    "sortBy": "Sort by",
    "sortOrder": "Sort Order",
    "asc": "Ascending",
    "desc": "Descending",
    "importing": "Importing",
    "imported": "Global",
    "importedAt": "Imported at:",
    "saveAsGlobalWorldBook": "Save as Global World Book",
    "globalName": "Global Name",
    "description": "Description (Optional)",
    "enterGlobalWorldBookName": "Default to use filename",
    "enterDescriptionForThisGlobalWorldBook": "Default to empty description",
    "importWorldBook": "Import World Book",
    "dragDropJson": "Drag and drop JSON file here",
    "jsonFileOnly": "JSON files only",
    "importResults": "Import Results",
    "importedEntries": "Imported {count} entries",
    "skippedEntries": "Skipped {count} entries",
    "importErrors": "Import Errors",
    "loading": "Loading world book data...",
    "noEntries": "No world book entries yet",
    "noEntriesDescription": "Click \"Create Entry\" to start creating your first world book entry",
    "createEntry": "Create Entry",
    "editEntry": "Edit Entry",
    "newEntry": "New World Book Entry",
    "deleteEntry": "Delete Entry",
    "bulkOperations": "Bulk Operations",
    "enableAll": "Enable All",
    "disableAll": "Disable All",
    "enableDisabled": "Enable Disabled",
    "disableEnabled": "Disable Enabled",
    "enabledAll": "All entries enabled",
    "disabledAll": "All entries disabled",
    "noEntriesWithStatus": "No entries found with status \"{status}\"",
    "bulkEnable": "Bulk Enable",
    "bulkDisable": "Bulk Disable",
    "bulkDelete": "Bulk Delete",
    "selectAll": "Select All",
    "selectEntriesFirst": "Please select entries to operate on first",
    "confirmDelete": "Are you sure you want to delete this entry?",
    "saveSuccess": "Save successful",
    "saveFailed": "Save failed",
    "deleteSuccess": "Delete successful",
    "deleteFailed": "Delete failed",
    "bulkOperationFailed": "Bulk operation failed",
    "keywordRequired": "At least one keyword is required",
    "contentRequired": "Content cannot be empty",
    "totalCount": "Total:",
    "enabledCount": "Enabled:",
    "disabledCount": "Disabled:",
    "selectedItems": "Selected",
    "items": "items",
    "contextWindow": "Context Window:",
    "status": "Status",
    "comment": "Comment",
    "keywords": "Keywords",
    "position": "Position",
    "depth": "Depth",
    "characterCount": "Characters",
    "priority": "Priority",
    "actions": "Actions",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "regex": "Regex",
    "constant": "Constant",
    "noComment": "No comment",
    "edit": "Edit",
    "delete": "Delete",
    "contentPreview": "Content Preview",
    "noContent": "No content",
    "secondaryKeywords": "Secondary Keywords",
    "selectiveMatching": "Selective Matching:",
    "tokenCount": "Token Count:",
    "lastUpdated": "Last Updated:",
    "totalKeywords": "Total Keywords:",
    "notCalculated": "Not calculated",
    "yes": "Yes",
    "no": "No",
    "commentTitle": "Comment/Title",
    "commentPlaceholder": "Enter comment or title",
    "insertionOrder": "Insertion Order",
    "primaryKeywords": "Primary Keywords",
    "keywordPlaceholder": "Enter keyword",
    "addKeyword": "Add Keyword",
    "removeKeyword": "Remove Keyword",
    "depthLabel": "Depth",
    "enabledLabel": "Enabled",
    "regexLabel": "Regular Expression",
    "selectiveLabel": "Selective Matching",
    "constantLabel": "Constant Entry",
    "contentLabel": "Content",
    "contentPlaceholder": "Enter world book content...",
    "characters": "characters",
    "save": "Save",
    "cancel": "Cancel",
    "saving": "Saving...",
    "positionOptions": {
      "systemPromptStart": "System Prompt Start",
      "afterSystemPrompt": "After System Prompt",
      "userMessageStart": "User Message Start",
      "afterResponseMode": "After Response Mode",
      "basedOnDepth": "Based on Depth"
    },
    "toggleFailed": "Toggle failed",
    "enableEntry": "Enable entry",
    "disableEntry": "Disable entry",
    "toggle": "Toggle",
    "item": "item",
    "confirmBulkDisable": "This action will disable all entries",
    "importFromJson": "Import from JSON",
    "importValidationFailed": "Import validation failed",
    "selectJsonFile": "Select JSON file",
    "importFromGlobal": "Import from Global World Book",
    "noGlobalWorldBooks": "No global world books available",
    "createGlobalWorldBookFirst": "Create a global world book first",
    "selectGlobalWorldBook": "Select Global World Book",
    "entryCount": "Entry Count",
    "createdAt": "Created At",
    "sourceCharacter": "Source Character",
    "filterBy": "Filter By",
    "filterAll": "All",
    "filterEnabled": "Enabled",
    "filterDisabled": "Disabled",
    "filterImported": "Global",
    "filteredCount": "Filtered",
    "ascending": "Ascending",
    "descending": "Descending",
    "fullscreenContent": "Large Editor",
    "exitFullscreen": "Close Editor"
  },
  "regexScriptEditor": {
    "title": "Regex Script Editor",
    "close": "Close",
    "settings": "Settings",
    "enableProcessing": "Enable regex processing",
    "applyToPrompts": "Apply to prompts",
    "applyToResponses": "Apply to responses",
    "addNewScript": "Add New Script",
    "existingScripts": "Existing Scripts",
    "noScripts": "No scripts found",
    "noScriptsDescription": "Click Add New Script to create your first regex script",
    "priority": "Priority",
    "edit": "Edit",
    "enable": "Enable",
    "disable": "Disable",
    "delete": "Delete",
    "replace": "Replace",
    "findRegex": "Find Regex",
    "replaceString": "Replace String",
    "trimStrings": "Trim Strings",
    "confirmDelete": "Are you sure you want to delete this script?",
    "deleteError": "Failed to delete script",
    "newScript": "New Script",
    "editScript": "Edit Script",
    "scriptName": "Script Name",
    "scriptNamePlaceholder": "Enter script name",
    "findRegexPlaceholder": "/pattern/flags or pattern",
    "replaceStringPlaceholder": "Replacement text (use $1, $2 for groups)",
    "disabled": "Disabled",
    "enabled": "Enabled",
    "cancel": "Cancel",
    "save": "Save",
    "saving": "Saving...",
    "loading": "Loading...",
    "requiredFields": "Please fill in all required fields",
    "saveError": "Failed to save script",
    "totalCount": "Total",
    "enabledCount": "Enabled",
    "disabledCount": "Disabled",
    "filteredCount": "Filtered",
    "sortBy": "Sort By",
    "sortOrder": "Sort Order",
    "asc": "Ascending",
    "desc": "Descending",
    "filterBy": "Filter By",
    "filterAll": "All",
    "filterEnabled": "Enabled",
    "filterDisabled": "Disabled",
    "filterImported": "Global",
    "name": "Name",
    "status": "Status",
    "globalEnabled": "Global Enabled",
    "applyToPrompt": "Apply to Prompt",
    "applyToResponse": "Apply to Response",
    "yes": "Yes",
    "no": "No",
    "importScript": "Import Script",
    "importRegexScript": "Import Regex Script",
    "importFromJson": "Import from JSON",
    "importFromGlobal": "Import from Global",
    "dragDropJson": "Drag and drop JSON file here",
    "jsonFileOnly": "JSON files only",
    "saveAsGlobalRegexScript": "Save as Global Regex Script",
    "globalName": "Global Name",
    "description": "Description",
    "enterGlobalRegexScriptName": "Default to use filename",
    "enterDescriptionForThisGlobalRegexScript": "Default to empty description",
    "importing": "Importing...",
    "importResults": "Import Results",
    "importedScripts": "Imported {count} scripts",
    "skippedScripts": "Skipped {count} scripts",
    "importErrors": "Import Errors",
    "noGlobalRegexScripts": "No global regex scripts available",
    "createGlobalRegexScriptFirst": "Create a global regex script first",
    "selectGlobalRegexScript": "Select Global Regex Script",
    "willUseEachFileName": "Each file's name will be used as the script name"
  },
  "dialogue": {
    "treeVisualization": "Context Manager",
    "node": "Dialogue Node",
    "systemMessage": "System Message",
    "jumpToNode": "Jump to Node",
    "expandNode": "Expand Node",
    "editNode": "Edit Node",
    "userInput": "User Input",
    "assistantResponse": "Assistant Response",
    "noCharacterSelected": "No Character Selected",
    "selectCharacterFirst": "Please select a character first",
    "loadingDialogue": "Loading dialogue data...",
    "noDialogueNodes": "No Dialogue Nodes",
    "startConversation": "Start a conversation to create a dialogue tree",
    "memorySummary": "Memory Summary",
    "nodeId": "Node ID",
    "startingPoint": "Opening Scene",
    "rootNodeCannotJump": "Root node is the starting point of the dialogue and cannot be jumped to",
    "response": "Response Content",
    "responsePlaceholder": "Edit the response content...",
    "resetLayout": "Reset Layout",
    "manualPositions": "Manual Positions"
  },
  "downloadModal": {
      "title": "Download Character from Community Repository",
      "loading": "Loading...",
      "fetchError": "Unable to fetch character list",
      "downloadFailed": "Download failed",
      "importFailed": "Import failed",
      "importing": "Importing...",
      "downloadAndImport": "Download and Import",
      "by": "By:",
      "unknownAuthor": "Anonymous"
  },
  "creatorInput": {
    "title": "Creator Studio",
    "subtitle": "Start creating epic stories",
    "placeholder": "Enter your creative ideas...",
    "sendMessage": "Send message",
    "enterToSend": "Press Enter to send, Shift + Enter for new line",
    "characterCount": "{count}/1000",
    "exampleStories": "Survival, Harry Potter, Lord of the Rings - any story at your will"
  },
  "tour": {
    "welcome": "Welcome to Narratium",
    "welcomeDescription": "Narratium is an intelligent character dialogue platform where you can have in-depth conversations with various AI characters and create unique story experiences. Let's explore the basic features.",
    "loginTitle": "First, Login to Your Account",
    "loginDescription": "Click here to login. Note: The username you enter may be used by AI characters as the protagonist's name, so we recommend using a name you'd like to use in stories.",
    "settingsTitle": "Configure AI Model",
    "settingsDescription": "After logging in, click the settings button in the top right corner to configure your AI model. You can choose OpenAI or Ollama and set the corresponding API keys and model parameters.",
    "worldbookTitle": "World Book Feature",
    "worldbookDescription": "World Book is used to define the character's background world, settings, and important information. AI will maintain character consistency based on the content in the World Book, making conversations more immersive.",
    "regexTitle": "Regex Scripts",
    "regexDescription": "Regex scripts allow you to customize the format and processing logic of AI replies. You can set special text replacement rules to make character expressions more unique.",
    "presetTitle": "Preset Management",
    "presetDescription": "Preset features let you save and manage different conversation settings, including character tone, style, and special instructions, making it easy to switch between different scenarios.",
    "chatTitle": "Start Conversation",
    "chatDescription": "Now you can enter messages in the input box and start exciting conversations with AI characters! AI will respond based on your World Book, regex scripts, and presets.",
    "next": "Next",
    "previous": "Previous",
    "skip": "Skip",
    "finish": "Finish",
    "resetTour": "Reset Tour"
  }
}
</file>

<file path="app/i18n/locales/zh.json">
{
  "common": {
    "save": "保存",
    "cancel": "取消",
    "close": "关闭",
    "return": "返回",
    "settings": "设置",
    "switchToEnglish": "切换为英文",
    "switchToChinese": "切换为中文",
    "soundOn": "声音开启",
    "soundOff": "声音关闭",
    "saving": "保存中...",
    "defaultAutoFillFileName": "默认：自动填写文件名",
    "exportData": "导出数据",
    "exportDataToGoogle": "导出数据到谷歌",
    "importData": "导入数据",
    "importDataFromGoogle": "从谷歌导入数据",
    "exportFailed": "导出失败，请重试",
    "importFailed": "导入失败，请重试"
  },
  "sidebar": {
    "home": "首页",
    "gameArea": "游戏区",
    "creator": "创造者",
    "creationArea": "创作区",
    "historyRecords": "历史记录",
    "newStory": "新冒险",
    "storyCollection": "故事集",
    "characterCards": "角色卡",
    "characterMarket": "角色市场",
    "login": "登录并探索更多",
    "nologin": "定义 User 名称",
    "logout": "退出登录",
    "collapseHome": "收起首页",
    "expandHome": "展开首页",
    "collapseCreation": "收起游戏区",
    "expandCreation": "展开游戏区",
    "collapseCreator": "收起创作区",
    "expandCreator": "展开创作区",
    "goToUpdate": "前往更新",
    "newVersionAvailable": "发现新版本",
    "currentVersion": "当前版本: v{version}"
  },
  "modelSettings": {
    "title": "模型设置",
    "llmType": "LLM 类型",
    "baseUrl": "Base URL",
    "model": "模型",
    "apiKey": "API Key",
    "language": "输出语言",
    "chinese": "中文",
    "english": "英文",
    "saveSettings": "点击启用",
    "settingsSaved": "设置已保存",
    "commonModels": "常用模型推荐:",
    "modelList": "模型列表",
    "selectModel": "选择模型",
    "modelListUnavailable": "模型列表不可用",
    "configurations": "API 配置",
    "newConfig": "新建配置",
    "configName": "配置名称",
    "configNamePlaceholder": "我的 API 配置",
    "createConfig": "创建配置",
    "nameRequired": "名称不能为空",
    "cannotDeleteLastConfig": "无法删除最后一个配置",
    "confirmDelete": "确定要删除此配置吗？",
    "configCreated": "配置已创建",
    "noConfigs": "暂无API配置",
    "createFirstConfig": "创建你的第一个配置",
    "getModelList": "获取模型列表",
    "getModelListSuccess": "获取模型列表成功",
    "getModelListError": "获取模型列表失败",
    "doubleClickToEditName": "双击可修改名称",
    "testModel": "测试模型",
    "testing": "测试中...",
    "testSuccess": "模型测试成功",
    "testError": "模型测试失败",
    "apiTestFailed": "API 测试失败",
    "modelTestFailed": "模型测试失败"
  },
  "llmSettings": {
    "title": "设置",
    "modelType": "模型类型",
    "presets": "预设",
    "creative": "创意",
    "balanced": "平衡",
    "precise": "精确",
    "commonParams": "常用参数",
    "advancedParams": "高级参数",
    "temperature": "温度",
    "temperatureDescription": "控制生成文本的随机性。较高的值会产生更多样化的输出，较低的值会产生更确定的输出。",
    "maxTokens": "最大标记数",
    "maxTokensDescription": "生成文本的最大标记数。留空使用模型默认值。",
    "timeout": "超时时间",
    "timeoutDescription": "API 请求的超时时间（毫秒）。留空使用默认值。",
    "maxRetries": "最大重试次数",
    "maxRetriesDescription": "当 API 请求失败时的最大重试次数。",
    "topP": "Top P 采样",
    "topPDescription": "通过核采样控制多样性。较低的值会考虑更少的高概率选项。",
    "frequencyPenalty": "频率惩罚",
    "frequencyPenaltyDescription": "根据标记在文本中的频率进行惩罚。较高的值会减少重复。",
    "presencePenalty": "存在惩罚",
    "presencePenaltyDescription": "惩罚已经出现在文本中的标记。较高的值会鼓励新主题。",
    "topK": "Top K 采样",
    "topKDescription": "将标记选择限制为 K 个最可能的标记。较低的值使输出更加集中。",
    "repeatPenalty": "重复惩罚",
    "repeatPenaltyDescription": "惩罚重复的标记。较高的值会减少 Ollama 模型中的重复。",
    "optional": "可选项，留空使用默认值"
  },
  "sessionList": {
    "loading": "召唤历史卷轴中...",
    "noHistory": "暂无历史记录",
    "continue": "继续游戏",
    "delete": "删除记录"
  },
  "homePage": {
    "slogan": "我们每个人的心里，都是一团火焰",
    "newAdventure": "开启新的冒险",
    "continueJourney": "继续未完的旅程",
    "immediatelyStart": "立刻开始"
  },
  "auth": {
    "username": "用户名",
    "password": "密码",
    "login": "登录",
    "register": "注册",
    "welcomeBack": "欢迎回来",
    "continueJourney": "登录以继续您的旅程",
    "emailPlaceholder": "回车以应用用户名",
    "passwordPlaceholder": "输入密码",
    "codePlaceholder": "输入验证码",
    "wizardQuestion": "✨ 勇者，请留下您的姓名",
    "spellQuestion": "🔮 请施展您的守护咒语，它将保护您的奇幻旅程！",
    "codeQuestion": "⚡ 输入星辰大海送来的神秘符文，证明您的身份！",
    "getCode": "获取验证码",
    "openingMagicDoor": "正在开启魔法之门...",
    "magicSpell": "密码登录",
    "starCode": "验证码登录",
    "agreementText": "继续即表示您同意",
    "termsOfService": "服务条款",
    "privacyPolicy": "隐私政策"
  },
  "storiesPage": {
    "title": "我的故事",
    "createNewStory": "创建新故事",
    "loading": "正在加载故事...",
    "noStories": "你还没有创建任何故事",
    "createFirstStory": "创建第一个故事",
    "recentlyCreated": "最近创建",
    "fetchError": "获取故事列表失败",
    "edit": "编辑",
    "delete": "删除",
    "deleteConfirm": "确定要删除这个故事吗？",
    "deleteSuccess": "故事已删除",
    "deleteFailed": "删除故事失败",
    "play": "开始游戏"
  },
  "newStory": {
    "title": "创建新故事",
    "editTitle": "编辑故事",
    "storyTitle": "故事标题",
    "storyFramework": "故事背景",
    "characterInfo": "角色信息",
    "questionTitle": "✨ 传奇冒险的主题",
    "questionFramework": "✨ 你的冒险将在怎样神奇的位面展开？",
    "questionCharacter": "✨ 在这段不朽传奇中，你化身为何等存在？",
    "titlePlaceholder": "为你的史诗命名",
    "frameworkPlaceholder": "描绘你的奇幻世界",
    "characterPlaceholder": "揭示你的英雄身份",
    "create": "开启传奇之旅",
    "creating": "正在编织您的传奇故事...",
    "update": "更新故事",
    "updating": "更新中...",
    "cancel": "取消",
    "fillAllFields": "请填写所有必填字段",
    "createFailed": "创建故事失败，请重试",
    "updateFailed": "更新故事失败，请重试",
    "updateSuccess": "故事更新成功"
  },
  "notFound": {
    "title": "前方的道路尚未开放",
    "subtitle": "这片奇幻领域仍在建设中",
    "message": "尊敬的冥想家，您所寻找的魔法卷轴似乎已被遗失或尚未被创造。",
    "backToHome": "返回",
    "exploreMore": "稍后再来探索"
  },
  "game": {
    "fetchStoryFailed": "获取故事详情失败",
    "fetchStoryFailedRetry": "获取故事详情失败，请重试",
    "loadSessionFailed": "加载历史会话失败",
    "loadSessionFailedRetry": "加载历史会话失败，请重试",
    "initializeFailed": "游戏初始化失败",
    "setupFailed": "游戏设置失败",
    "cannotReadResponseStream": "无法读取响应流",
    "generatingStory": "正在生成故事...",
    "actionFailed": "游戏操作失败",
    "confirmDelete": "确定要删除这个故事吗？这个操作不可恢复。",
    "deleteFailed": "删除故事失败",
    "deleteFailedRetry": "删除故事失败，请重试",
    "storyNotExist": "历史记录所属的故事不存在",
    "cannotFindStory": "无法找到ID为 {id} 的故事",
    "backToStoryList": "返回故事列表",
    "expandSidebar": "展开侧边栏",
    "collapseSidebar": "收起侧边栏",
    "storySummary": "故事概要",
    "storyFramework": "故事框架",
    "characterInfo": "角色信息",
    "starting": "启动中...",
    "startAdventure": "开始冒险",
    "inputCustomAction": "输入自定义操作...",
    "execute": "执行",
    "deleting": "删除中...",
    "deleteStory": "删除故事",
    "gameInfo": "游戏信息",
    "memoryManagement": "记忆管理",
    "navigation": "导航",
    "collapse": "收起",
    "expand": "展开",
    "memoryPlaceholder": "这里将显示游戏记忆",
    "memoryDescription": "记忆管理允许您查看和编辑游戏中的记忆片段",
    "memoryInstructions": "点击节点查看完整内容，连线显示您的操作",
    "editMemory": "编辑记忆",
    "memorySummary": "记忆概要",
    "fullMemoryContent": "完整记忆内容",
    "editMemoryPlaceholder": "编辑您的游戏记忆...",
    "noSessionFound": "未找到会话",
    "startSessionFirst": "请先开始一个游戏会话才能查看记忆",
    "loadingMemories": "正在加载记忆...",
    "jumpToNode": "跳转到此节点",
    "expandMemory": "展开记忆内容"
  },
  "characterCardsPage": {
    "title": "角色卡",
    "importCharacter": "导入角色",
    "importFirstCharacter": "导入你的第一个角色",
    "noCharacters": "你还没有任何角色",
    "loading": "加载中...",
    "downloadingPresets": "正在下载预设角色...",
    "fetchError": "获取角色失败",
    "deleteFailed": "删除角色失败",
    "delete": "删除",
    "edit": "编辑",
    "chat": "聊天",
    "recentlyCreated": "最近创建",
    "downloadCharacter": "社区下载角色"
  },
  "editCharacterModal": {
    "title": "编辑角色",
    "name": "名称",
    "description": "描述",
    "personality": "性格",
    "scenario": "场景",
    "firstMessage": "开场白",
    "mesExample": "消息示例",
    "creatorComment": "创建者备注",
    "save": "保存",
    "cancel": "取消"
  },
  "importCharacterModal": {
    "title": "导入角色",
    "description": "选择或拖放 SillyTavern 格式的 PNG 角色卡文件进行导入",
    "dragOrClick": "拖放文件到此处或点击选择",
    "pngFormat": "仅支持 SillyTavern 格式的 PNG 角色卡文件",
    "pngOnly": "请选择 SillyTavern 格式的 PNG 文件",
    "noFileSelected": "请先选择文件",
    "uploadFailed": "上传失败，请重试",
    "import": "导入",
    "uploading": "正在上传..."
  },
  "characterMarketPage": {
    "description": "探索各种精彩角色，为您的故事增添生机",
    "searchPlaceholder": "搜索角色名称或描述",
    "allTags": "全部",
    "loading": "正在加载角色...",
    "noResults": "没有找到匹配的角色",
    "clearFilters": "清除筛选条件",
    "by": "作者：",
    "download": "下载角色",
    "viewDetails": "查看详情"
  },
  "characterChat": {
    "navigation": "导航",
    "characterInfo": "角色信息",
    "actions": "操作",
    "expandSidebar": "展开侧边栏",
    "collapseSidebar": "收起侧边栏",
    "backToCharacters": "返回角色列表",
    "Conversation": "剧情分支管理",
    "noPersonality": "未定义性格",
    "typeMessage": "输入消息...",
    "startConversation": "开始对话...",
    "send": "发送",
    "isTyping": "正在输入...",
    "suggestedResponse1": "告诉我更多",
    "suggestedResponse2": "接下来发生了什么？",
    "suggestedResponse3": "你对此有什么感想？",
    "promptMode": "提示词模式",
    "companionMode": "剧情推进模式",
    "nsfwMode": "亲密陪伴模式",
    "explicitMode": "NSFW模式",
    "customMode": "自定义模式",
    "innerThought": "内心想法",
    "speech": "对话",
    "screen": "场景",
    "nextPrompt": "下一步",
    "storyProgress": "剧情推进",
    "storyProgressHint": "（下一步根据全部有效信息推进故事发展）",
    "perspective": "视角设计",
    "novelPerspective": "小说视角",
    "protagonistPerspective": "主角视角",
    "novelPerspectiveHint": "（下次以小说上帝视角回复，必须包含剧透姓名）",
    "protagonistPerspectiveHint": "（下次以主角视角回复，必须使用我或者主角的实际名称）",
    "sceneTransition": "场景过渡",
    "sceneTransitionHint": "（下一次进行自然的场景过渡，实现场景切换）",
    "screenPlaceholder": "描述场景或动作...",
    "speechPlaceholder": "角色说的话...",
    "innerThoughtPlaceholder": "角色心里想了什么...",
    "playerInput": "玩家输入指令",
    "characterStatus": "角色状态",
    "responseInstructions": "回复提示",
    "responseLength": "模型回复长度",
    "customPrompt": "自定义提示词",
    "customPromptFor": "自定义提示词",
    "presets": "预设",
    "presetEditor": "预设编辑器",
    "githubPresets": "提示词选择",
    "noPresets": "没有可用的预设",
    "prefixPrompt": "前缀提示词",
    "chainOfThoughtPrompt": "思维链提示词",
    "suffixPrompt": "后缀提示词",
    "prefixPromptDescription": "前缀提示词将放置在提示词的开头，用于设置角色的基本行为和背景。",
    "chainOfThoughtPromptDescription": "思维链提示词将放置在提示词的中间，用于指导角色的思考过程。",
    "suffixPromptDescription": "后缀提示词将放置在提示词的结尾，用于补充额外的指导和限制。",
    "prefixPromptPlaceholder": "输入前缀提示词...",
    "chainOfThoughtPromptPlaceholder": "输入思维链提示词...",
    "suffixPromptPlaceholder": "输入后缀提示词...",
    "autoSaveEnabled": "自动保存已启用",
    "initializing": "正在初始化角色...",
    "extractingTemplate": "提取状态模板中，请稍候...",
    "loadingTimeHint": "首次加载时间在 5-40 秒之间，角色卡内容越大加载时间越长，如果长时间未加载，请检查 API 配置是否正确",
    "error": "错误",
    "characterNotFound": "未找到角色",
    "loading":"加载中……正在解析状态，请稍等……",
    "worldBook": "世界书",
    "regex": "正则脚本",
    "preset": "预设",
    "enabled": "启用",
    "disabled": "禁用",
    "filtered": "筛选",
    "advancedSettings": "高级设置",
    "tagColorEditor": "标签颜色编辑器",
    "enterTagName": "输入标签名称...",
    "add": "添加",
    "saveChanges": "保存更改",
    "enterSymbol": "当输入 tag 时，将对<tag>...</tag>进行匹配",
    "enableStreaming": "启用流式输出",
    "disableStreaming": "禁用流式输出",
    "jumpToMessage": "跳转到此消息",
    "regenerateMessage": "重新生成消息",
    "enableFastModel": "开启快速模式",
    "disableFastModel": "关闭快速模式"
  },
  "preset": {
    "title": "预设编辑器",
    "createPreset": "创建预设",
    "importPreset": "导入预设",
    "sortBy": "排序方式",
    "sortOrder": "排序顺序",
    "filterBy": "筛选方式",
    "ascending": "升序",
    "descending": "降序",
    "asc": "升序",
    "desc": "降序",
    "all": "全部",
    "active": "有提示词",
    "empty": "空白",
    "name": "名称",
    "promptCount": "提示词数量",
    "lastUpdated": "最后更新",
    "status": "状态",
    "prompts": "提示词",
    "updated": "更新时间",
    "actions": "操作",
    "active_status": "活跃",
    "empty_status": "空白",
    "total": "总计",
    "enabled": "启用",
    "disabled": "禁用",
    "filtered": "筛选结果",
    "loading": "加载预设中...",
    "noPresetsFound": "未找到预设",
    "createFirstPreset": "创建您的第一个预设开始使用",
    "enterPresetName": "输入预设名称：",
    "createSuccess": "预设创建成功",
    "createFailed": "创建预设失败",
    "deleteConfirm": "确定要删除这个预设吗？",
    "deleteSuccess": "预设删除成功",
    "deleteFailed": "删除预设失败",
    "loadFailed": "加载预设失败",
    "loadDetailsFailed": "加载预设详情失败",
    "expandDetails": "展开详情",
    "collapseDetails": "收起详情",
    "promptsTitle": "提示词",
    "addPrompt": "添加提示词",
    "enterPromptName": "输入提示词名称：",
    "addPromptSuccess": "提示词添加成功",
    "addPromptFailed": "添加提示词失败",
    "deletePromptConfirm": "确定要删除这个提示词吗？",
    "deletePromptSuccess": "提示词删除成功",
    "deletePromptFailed": "删除提示词失败",
    "noPromptsInPreset": "此预设中没有提示词",
    "enabled_prompt": "已启用",
    "disabled_prompt": "已禁用",
    "system": "系统",
    "deletePrompt": "删除提示词",
    "promptEnabledSuccess": "提示词已成功启用",
    "promptDisabledSuccess": "提示词已成功禁用",
    "togglePromptFailed": "切换提示词状态失败",
    "applyPresetSuccess": "预设应用成功",
    "applyPresetFailed": "应用预设失败",
    "applyPreset": "应用预设",
    "presetApplied": "预设已激活",
    "cannotApplyEmpty": "无法应用空预设",
    "enablePreset": "启用预设",
    "disablePreset": "禁用预设",
    "presetEnabledSuccess": "预设已成功启用",
    "presetEnabledExclusiveSuccess": "预设已成功启用（其他预设已自动禁用）",
    "presetDisabledSuccess": "预设已成功禁用",
    "togglePresetFailed": "切换预设状态失败",
    "presetDisabled": "预设已禁用",
    "cannotApplyDisabled": "无法应用已禁用的预设",
    "toggle": "开关",
    "presetName": "预设名称",
    "presetNamePlaceholder": "输入预设名称",
    "presetNameRequired": "预设名称不能为空",
    "creating": "创建中...",
    "create": "创建",
    "cancel": "取消",
    "editPrompt": "编辑提示词",
    "promptContent": "提示词内容",
    "saving": "保存中"
  },
  "importPreset": {
    "title": "导入预设",
    "dragDropFile": "导入预设文件",
    "dropFileHere": "将文件拖拽到这里",
    "browseFiles": "浏览文件",
    "dragAndDrop": "拖拽JSON预设文件到此处，或点击浏览",
    "importing": "导入中...",
    "importSuccess": "导入成功",
    "importFailed": "导入失败",
    "presetImported": "预设已成功导入！",
    "importError": "导入过程中发生错误",
    "customizePreset": "自定义预设",
    "presetName": "预设名称",
    "presetNameDesc": "留空以使用文件原始名称",
    "confirmImport": "确认导入",
    "guidelines": "导入指南",
    "jsonFormat": "预设文件必须为JSON格式",
    "validStructure": "文件应包含有效的预设结构和提示词",
    "noOverwrite": "不会覆盖同名的现有预设",
    "maxFileSize": "最大文件大小：10MB",
    "selectJsonFile": "请选择JSON文件",
    "failedToImport": "导入失败",
    "cancel": "取消",
    "save": "保存"
  },
  "dialogue": {
    "treeVisualization": "剧情分支管理",
    "node": "对话节点",
    "systemMessage": "系统消息",
    "jumpToNode": "跳转到节点",
    "expandNode": "展开节点",
    "editNode": "编辑节点",
    "userInput": "用户输入",
    "assistantResponse": "助手回复",
    "noCharacterSelected": "未选择角色",
    "selectCharacterFirst": "请先选择一个角色",
    "loadingDialogue": "正在加载对话数据...",
    "noDialogueNodes": "没有对话节点",
    "startConversation": "开始对话以创建对话树",
    "memorySummary": "记忆摘要",
    "nodeId": "节点ID",
    "startingPoint": "开局",
    "rootNodeCannotJump": "根节点是对话的起点，不能跳转",
    "response": "回复内容",
    "responsePlaceholder": "编辑回复内容...",
    "resetLayout": "重置布局",
    "manualPositions": "手动位置"
  },  
  "downloadModal": {
      "title": "从社区仓库下载角色",
      "loading": "加载中…",
      "fetchError": "无法获取角色列表",
      "downloadFailed": "下载失败",
      "importFailed": "导入失败",
      "importing": "导入中…",
      "downloadAndImport": "下载并导入",
      "by": "作者：",
      "unknownAuthor": "佚名"
  },
  "creatorInput": {
    "title": "Creator Studio",
    "subtitle": "开始创作史诗级的故事",
    "placeholder": "输入您的创作想法...",
    "sendMessage": "发送消息",
    "enterToSend": "按 Enter 发送，Shift + Enter 换行",
    "characterCount": "{count}/1000",
    "exampleStories": "《荒野求生》、《哈利波特》、《魔戒》，任何故事随心而动"
  },
  "worldBook": {
    "title": "世界书",
    "addEntry": "添加条目",
    "sortBy": "排序方式",
    "sortOrder": "排序顺序",
    "asc": "升序",
    "desc": "降序",
    "importing": "导入中",
    "imported": "全局",
    "importedAt": "导入时间:",
    "saveAsGlobalWorldBook": "保存为全局世界书",
    "globalName": "全局名称",
    "description": "描述（可选）",
    "enterGlobalWorldBookName": "默认自动填写文件名称",
    "enterDescriptionForThisGlobalWorldBook": "默认自动填写空描述",
    "importWorldBook": "导入世界书",
    "dragDropJson": "拖拽JSON文件到此处",
    "jsonFileOnly": "仅支持JSON文件",
    "importResults": "导入结果",
    "importedEntries": "已导入 {count} 个条目",
    "skippedEntries": "跳过 {count} 个条目",
    "importErrors": "导入错误",
    "loading": "加载世界书数据...",
    "noEntries": "暂无世界书条目",
    "noEntriesDescription": "点击新建条目开始创建您的第一个世界书条目",
    "createEntry": "新建条目",
    "editEntry": "编辑世界书条目",
    "newEntry": "新建世界书条目",
    "deleteEntry": "删除条目",
    "bulkOperations": "批量操作",
    "enableAll": "全部启用",
    "disableAll": "全部禁用",
    "enableDisabled": "启用禁用的",
    "disableEnabled": "禁用启用的",
    "enabledAll": "已启用全部",
    "disabledAll": "已禁用全部",
    "noEntriesWithStatus": "没有找到状态为{status}的条目",
    "bulkEnable": "批量启用",
    "bulkDisable": "批量禁用",
    "bulkDelete": "批量删除",
    "selectAll": "全选",
    "selectEntriesFirst": "请先选择要操作的条目",
    "confirmDelete": "确定要删除这个条目吗？",
    "saveSuccess": "保存成功",
    "saveFailed": "保存失败",
    "deleteSuccess": "删除成功",
    "deleteFailed": "删除失败",
    "bulkOperationFailed": "批量操作失败",
    "toggleFailed": "切换状态失败",
    "enableEntry": "启用条目",
    "disableEntry": "禁用条目",
    "toggle": "开关",
    "item": "条",
    "confirmBulkDisable": "此操作将禁用所有条目",
    "keywordRequired": "至少需要一个关键词",
    "contentRequired": "内容不能为空",
    "totalCount": "总计:",
    "enabledCount": "启用:",
    "disabledCount": "禁用:",
    "selectedItems": "已选择",
    "items": "项",
    "contextWindow": "上下文窗口:",
    "status": "状态",
    "comment": "注释",
    "keywords": "关键词",
    "position": "位置",
    "depth": "深度",
    "characterCount": "字符数",
    "priority": "优先级",
    "actions": "操作",
    "enabled": "启用",
    "disabled": "禁用",
    "regex": "正则",
    "constant": "常量",
    "noComment": "无注释",
    "edit": "编辑",
    "delete": "删除",
    "contentPreview": "内容预览",
    "noContent": "无内容",
    "secondaryKeywords": "次要关键词",
    "selectiveMatching": "选择性匹配:",
    "tokenCount": "令牌数:",
    "lastUpdated": "最后更新:",
    "totalKeywords": "关键词总数:",
    "notCalculated": "未计算",
    "yes": "是",
    "no": "否",
    "commentTitle": "注释/标题",
    "commentPlaceholder": "输入注释或标题",
    "insertionOrder": "插入顺序",
    "primaryKeywords": "主要关键词",
    "keywordPlaceholder": "输入关键词",
    "addKeyword": "添加关键词",
    "removeKeyword": "移除关键词",
    "depthLabel": "深度",
    "enabledLabel": "启用",
    "regexLabel": "正则表达式",
    "selectiveLabel": "选择性匹配",
    "constantLabel": "常量条目",
    "contentLabel": "内容",
    "contentPlaceholder": "输入世界书内容...",
    "characters": "字符",
    "save": "保存",
    "cancel": "取消",
    "saving": "保存中...",
    "positionOptions": {
      "systemPromptStart": "系统提示开头",
      "afterSystemPrompt": "系统提示之后",
      "userMessageStart": "用户消息开头",
      "afterResponseMode": "响应模式声明之后",
      "basedOnDepth": "基于深度"
    },
    "importFromJson": "从JSON导入",
    "importValidationFailed": "导入验证失败",
    "selectJsonFile": "选择JSON文件",
    "importFromGlobal": "从全局世界书导入",
    "noGlobalWorldBooks": "暂无全局世界书",
    "createGlobalWorldBookFirst": "请先创建全局世界书",
    "selectGlobalWorldBook": "选择全局世界书",
    "entryCount": "条目数量",
    "createdAt": "创建时间",
    "sourceCharacter": "来源角色",
    "filterBy": "筛选方式",
    "filterAll": "全部",
    "filterEnabled": "已启用",
    "filterDisabled": "已禁用",
    "filterImported": "全局",
    "filteredCount": "筛选结果",
    "ascending": "升序",
    "descending": "降序",
    "fullscreenContent": "大窗口编辑",
    "exitFullscreen": "关闭编辑器"
  },
  "regexScriptEditor": {
    "title": "正则脚本编辑器",
    "close": "关闭",
    "settings": "设置",
    "enableProcessing": "启用正则处理",
    "applyToPrompts": "应用到提示词",
    "applyToResponses": "应用到回复",
    "addNewScript": "添加新脚本",
    "existingScripts": "现有脚本",
    "noScripts": "暂无脚本",
    "noScriptsDescription": "点击添加新脚本开始创建您的第一个正则脚本",
    "priority": "优先级",
    "edit": "编辑",
    "enable": "启用",
    "disable": "禁用",
    "delete": "删除",
    "replace": "替换",
    "findRegex": "查找正则",
    "replaceString": "替换字符串",
    "trimStrings": "修剪字符串",
    "confirmDelete": "确定要删除这个脚本吗？",
    "deleteError": "删除脚本失败",
    "newScript": "新建脚本",
    "editScript": "编辑脚本",
    "scriptName": "脚本名称",
    "scriptNamePlaceholder": "输入脚本名称",
    "findRegexPlaceholder": "/pattern/flags 或 pattern",
    "replaceStringPlaceholder": "替换文本 (使用 $1, $2 表示分组)",
    "disabled": "禁用",
    "enabled": "启用",
    "cancel": "取消",
    "save": "保存",
    "saving": "保存中...",
    "loading": "加载中...",
    "requiredFields": "请填写所有必填字段",
    "saveError": "保存脚本失败",
    "totalCount": "总计",
    "enabledCount": "启用",
    "disabledCount": "禁用",
    "filteredCount": "筛选结果",
    "sortBy": "排序方式",
    "sortOrder": "排序顺序",
    "asc": "升序",
    "desc": "降序",
    "ascending": "升序",
    "descending": "降序",
    "filterBy": "筛选方式",
    "filterAll": "全部",
    "filterEnabled": "已启用",
    "filterDisabled": "已禁用",
    "filterImported": "全局",
    "name": "名称",
    "status": "状态",
    "globalEnabled": "全局启用",
    "applyToPrompt": "应用到提示词",
    "applyToResponse": "应用到回复",
    "yes": "是",
    "no": "否",
    "importScript": "导入脚本",
    "importRegexScript": "导入正则脚本",
    "importFromJson": "从JSON导入",
    "importFromGlobal": "从全局导入",
    "dragDropJson": "拖拽JSON文件到此处",
    "jsonFileOnly": "仅支持JSON文件",
    "saveAsGlobalRegexScript": "保存为全局正则脚本",
    "globalName": "全局名称",
    "description": "描述",
    "enterGlobalRegexScriptName": "默认自动填写文件名称",
    "enterDescriptionForThisGlobalRegexScript": "默认自动填写空描述",
    "importing": "导入中...",
    "importResults": "导入结果",
    "importedScripts": "已导入 {count} 个脚本",
    "skippedScripts": "跳过 {count} 个脚本",
    "importErrors": "导入错误",
    "noGlobalRegexScripts": "暂无全局正则脚本",
    "createGlobalRegexScriptFirst": "请先创建全局正则脚本",
    "selectGlobalRegexScript": "选择全局正则脚本",
    "willUseEachFileName": "将使用每个文件的名称作为脚本名称"
  },
  "tour": {
    "welcome": "欢迎使用 Narratium",
    "welcomeDescription": "Narratium 是一个智能角色对话平台，您可以与各种AI角色进行深度对话，创造独特的故事体验。让我们先了解一下基本功能。",
    "loginTitle": "首先登录账户",
    "loginDescription": "点击这里登录。请注意：您输入的用户名可能会被AI角色用作主角名称，所以建议使用您希望在故事中使用的名字。",
    "settingsTitle": "配置AI模型",
    "settingsDescription": "登录后，点击右上角的设置按钮来配置您的AI模型。您可以选择OpenAI或Ollama，并设置相应的API密钥和模型参数。",
    "worldbookTitle": "世界书功能",
    "worldbookDescription": "世界书用于定义角色的背景世界、设定和重要信息。AI会根据世界书中的内容来保持角色设定的一致性，让对话更加沉浸。",
    "regexTitle": "正则脚本",
    "regexDescription": "正则脚本允许您自定义AI回复的格式和处理逻辑。您可以设置特殊的文本替换规则，让角色的表达方式更加独特。",
    "presetTitle": "预设管理",
    "presetDescription": "预设功能让您可以保存和管理不同的对话设置，包括角色的语气、风格和特殊指令，方便在不同场景下快速切换。",
    "chatTitle": "开始对话",
    "chatDescription": "现在您可以在输入框中输入消息，开始与AI角色的精彩对话了！AI会根据您设置的世界书、正则脚本和预设来回应。",
    "next": "下一步",
    "previous": "上一步",
    "skip": "跳过",
    "finish": "完成",
    "resetTour": "重置引导"
  }
}
</file>

<file path="app/i18n/fonts.ts">
import { Language } from "./index";
⋮----
export const getLanguageFont = (language: Language): string =>
export const getLanguageSerifFont = (language: Language): string =>
export const getLanguageTitleFont = (language: Language): string =>
</file>

<file path="app/i18n/FontWrapper.tsx">
import { ReactNode } from "react";
import { useLanguage } from "./index";
interface FontWrapperProps {
  children: ReactNode;
}
export function FontWrapper(
export function TitleFontWrapper(
</file>

<file path="app/i18n/index.ts">
import { createContext, useContext } from "react";
⋮----
export type Language = typeof LANGUAGES[number];
⋮----
type LanguageContextType = {
  language: Language;
  setLanguage: (language: Language) => void;
  t: (key: string) => string;
  fontClass: string;
  titleFontClass: string;
  serifFontClass: string;
};
⋮----
export const useLanguage = () =>
export const getTranslation = (language: Language, key: string): string =>
export const getClientLanguage = (): Language =>
</file>

<file path="app/i18n/LanguageProvider.tsx">
import { ReactNode, useEffect, useState } from "react";
import { DEFAULT_LANGUAGE, Language, LANGUAGES, LanguageContext, getTranslation, getClientLanguage } from "./index";
import { getLanguageFont, getLanguageTitleFont, getLanguageSerifFont } from "./fonts";
import LoadingTransition from "@/components/LoadingTransition";
interface LanguageProviderProps {
  children: ReactNode;
}
export function LanguageProvider(
⋮----
const setLanguage = (newLanguage: Language) =>
const t = (key: string) =>
</file>

<file path="app/styles/fantasy-ui.css">
.fantasy-bg {
.magic-border {
.magic-border::before {
.logo-magic-container {
.logo-magic-container::after {
.logo-magic-container:hover::after {
.menu-item {
.menu-item::before {
.menu-item:hover::before {
.menu-item.active::before {
.menu-item:hover svg,
.menu-divider {
.menu-divider::before,
.menu-divider::before {
.menu-divider::after {
.session-card {
.session-card::before {
.session-card:hover {
.session-card:hover::before {
.user-avatar {
.user-avatar::after {
.user-avatar:hover::after {
.fantasy-scrollbar::-webkit-scrollbar {
.fantasy-scrollbar::-webkit-scrollbar-track {
.fantasy-scrollbar::-webkit-scrollbar-thumb {
.fantasy-scrollbar::-webkit-scrollbar-thumb:hover {
.magical-text {
.magical-login-text {
.magical-login-text span {
.login-fantasy-bg {
.login-fantasy-bg::after {
.login-fantasy-bg::before {
⋮----
.magical-input {
.magical-input::after {
.magical-input:focus-within::after {
.portal-button {
.portal-button::before {
.portal-button:hover {
.portal-button:hover::before {
.toggle-button {
.toggle-button::after {
.toggle-button:hover::after {
.fade-truncate {
.fade-truncate::after {
⋮----
.animate-pulse-slow {
⋮----
.animate-ring-pulse {
⋮----
.breathing-bg {
</file>

<file path="app/styles/fonts.css">
.font-source-sans {
.font-source-serif {
.font-cinzel {
.font-noto-sans-sc {
.font-noto-serif-sc {
html[lang="zh"] .font-sans {
html[lang="en"] .font-sans {
html[lang="zh"] .font-serif {
html[lang="en"] .font-serif {
html[lang="zh"] .font-title {
html[lang="en"] .font-title {
html[lang="zh"] .text-adjust {
html[lang="en"] .text-adjust {
body {
.font-serif,
</file>

<file path="app/styles/local-fonts.css">
@font-face {
⋮----
:root {
</file>

<file path="app/globals.css">
:root {
body {
html, body {
h1,
a {
a:hover {
button,
input,
input:focus,
.story-text {
.user-input {
::-webkit-scrollbar {
::-webkit-scrollbar-track {
::-webkit-scrollbar-thumb {
::-webkit-scrollbar-thumb:hover {
⋮----
.animate-gradient-x {
⋮----
.h-safe-area-inset-bottom {
⋮----
.mobile-bottom-nav {
</file>

<file path="app/layout.tsx">
import type { Metadata, Viewport } from "next";
⋮----
import MainLayout from "@/components/MainLayout";
import { LanguageProvider } from "@/app/i18n/LanguageProvider";
import { SoundProvider } from "@/contexts/SoundContext";
import GoogleAnalytics from "@/components/GoogleAnalytics";
import { Analytics } from "@vercel/analytics/react";
⋮----
export default function RootLayout({
  children,
}:
</file>

<file path="app/metadata.ts">
import { Metadata } from "next";
</file>

<file path="app/not-found.tsx">
import Link from "next/link";
import { motion } from "framer-motion";
import { useLanguage } from "./i18n";
⋮----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="app/page.tsx">
import { homeMetadata } from "./metadata";
⋮----
import { Suspense } from "react";
import HomeContent from "@/components/HomeContent";
⋮----
function HomeLoading()
</file>

<file path="components/__tests__/ChatHtmlBubble.test.ts">
import { describe, it, expect } from "vitest";
function processText(str: string): string
</file>

<file path="components/AdvancedSettingsEditor.tsx">
import React, { useState, useRef, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { TagColorEditor } from "@/components/TagColorEditor";
⋮----
interface AdvancedSettingsEditorProps {
  isOpen: boolean;
  onClose: () => void;
  onViewSwitch?: () => void;
}
⋮----
const handleClickOutside = (event: MouseEvent) =>
</file>

<file path="components/CharacterAvatarBackground.tsx">
import { useEffect, useState } from "react";
import { getBlob } from "@/lib/data/local-storage";
export function CharacterAvatarBackground(
⋮----
async function loadImage()
</file>

<file path="components/CharacterCardCarousel.tsx">
import React from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
interface CharacterCardCarouselProps {
  characters: Character[];
  onEditClick: (character: Character, e: React.MouseEvent) => void;
  onDeleteClick: (characterId: string) => void;
}
⋮----
const handleRotateLeft = () =>
const handleRotateRight = () =>
⋮----
onClick=
⋮----
trackButtonClick("delete_character_btn", "删除角色");
e.stopPropagation();
onDeleteClick(character.id);
⋮----
e.preventDefault();
⋮----
handleRotateLeft();
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
</file>

<file path="components/CharacterCardGrid.tsx">
import React from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import Tilt from "react-parallax-tilt";
import { useLanguage } from "@/app/i18n";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
interface CharacterCardGridProps {
  characters: Character[];
  onEditClick: (character: Character, e: React.MouseEvent) => void;
  onDeleteClick: (characterId: string) => void;
}
</file>

<file path="components/CharacterChatHeader.tsx">
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
import { useLanguage } from "@/app/i18n";
interface Props {
  character: {
    name: string;
    avatar_path?: string;
  };
  serifFontClass: string;
  sidebarCollapsed: boolean;
  activeView: "chat" | "worldbook" | "regex" | "preset";
  toggleSidebar: () => void;
  onSwitchToView: (view: "chat" | "worldbook" | "regex" | "preset") => void;
  onToggleView: () => void;
  onToggleRegexEditor: () => void;
}
</file>

<file path="components/CharacterChatPanel.tsx">
import { useEffect, useRef, useState } from "react";
import ChatHtmlBubble from "@/components/ChatHtmlBubble";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick, trackFormSubmit } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality?: string;
  avatar_path?: string;
}
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp?: string;
  isUser?: boolean;
}
interface Props {
  character: Character;
  messages: Message[];
  userInput: string;
  setUserInput: (val: string) => void;
  isSending: boolean;
  suggestedInputs: string[];
  onSubmit: (e: React.FormEvent) => void;
  onSuggestedInput: (input: string) => void;
  onTruncate: (id: string) => void;
  onRegenerate: (id: string) => void;
  fontClass: string;
  serifFontClass: string;
  t: (key: string) => string;
  activeModes: Record<string, any>;
  setActiveModes: React.Dispatch<React.SetStateAction<Record<string, any>>>;
}
⋮----
const scrollToBottom = () =>
const maybeScrollToBottom = (threshold = 120) =>
⋮----
const shouldShowRegenerateButton = (message: Message, index: number) =>
⋮----
trackFormSubmit("page", "提交表单");
onSubmit(event);
⋮----
onChange=
</file>

<file path="components/CharacterSidebar.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import Link from "next/link";
import DialogueTreeModal from "@/components/DialogueTreeModal";
import { trackButtonClick } from "@/utils/google-analytics";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { getAvailableGithubPresets, isPresetDownloaded, downloadPresetFromGithub, doesPresetExist, getPresetDisplayName, getPresetDescription } from "@/function/preset/download";
import AdvancedSettingsEditor from "@/components/AdvancedSettingsEditor";
interface CharacterSidebarProps {
  character: {
    id: string;
    name: string;
    personality?: string;
    avatar_path?: string;
    scenario?: string;
  };
  isCollapsed: boolean;
  toggleSidebar: () => void;
  responseLength?: number;
  onResponseLengthChange?: (length: number) => void;
  onDialogueEdit?: () => void;
  onViewSwitch?: () => void;
}
⋮----
const handleResponseLengthChange = (event: React.ChangeEvent<HTMLInputElement>) =>
const handleOpenPromptEditor = () =>
const handleDownloadAndEnablePreset = async (presetName: string) =>
⋮----
const loadGithubPresets = async () =>
⋮----
const handleResize = () =>
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 50 50">
⋮----
<span>
</file>

<file path="components/ChatHtmlBubble.tsx">
import { useEffect, useRef, memo, useState, useCallback, useMemo } from "react";
import { useSymbolColorStore } from "@/contexts/SymbolColorStore";
import { useLanguage } from "@/app/i18n";
class VirtualRenderQueue
⋮----
enqueue(task: () => void)
private scheduleProcessing()
private processQueue()
clear()
get length()
getNextTask()
⋮----
function convertMarkdown(str: string): string
function isCompleteHtmlDocument(str: string): boolean
function detectHtmlTags(str: string)
function generatePalette(uniqueTags: string[]): Record<string, string>
function replaceTags(html: string)
⋮----
function processHtml(htmlStr: string): string
function processSelfClosingTags(htmlStr: string): string
⋮----
interface Props {
  html: string;
  isLoading?: boolean;
  serifFontClass?: string;
  forceFullDocument?: boolean;
  enableStreaming?: boolean;
  onContentChange?: () => void;
}
⋮----
// Virtual queue integration for rendering optimization
⋮----
// Memoized HTML processing to prevent unnecessary recalculations
⋮----
// Batched update function using virtual queue
⋮----
// Queue the update if already processing
⋮----
// Clear any pending timeout
⋮----
// Batch the update with a small delay to collect multiple changes
⋮----
// Process any queued updates
⋮----
}, 16); // ~60fps
⋮----
// Optimized height adjustment using virtual queue
⋮----
// Silent error handling
⋮----
const handler = (e: MessageEvent) =>
⋮----
// Use virtual queue for height updates
⋮----
const resizeHandler = () =>
</file>

<file path="components/CreatePresetModal.tsx">
import { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { createPreset } from "@/function/preset/global";
import { toast } from "react-hot-toast";
interface CreatePresetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: () => void;
}
⋮----
const handleSubmit = async (e: React.FormEvent) =>
const handleClose = () =>
</file>

<file path="components/DialogueTreeModal.tsx">
import { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { useLanguage } from "@/app/i18n";
import ReactFlow, {
  MiniMap,
  Background,
  useNodesState,
  useEdgesState,
  Node,
  Edge,
  NodeTypes,
  ConnectionLineType,
  Panel,
  Handle,
  Position,
  NodeProps,
  ReactFlowInstance,
} from "reactflow";
⋮----
import ELK from "elkjs/lib/elk.bundled.js";
import { trackButtonClick } from "@/utils/google-analytics";
import { switchDialogueBranch } from "@/function/dialogue/truncate";
import { getCharacterDialogue } from "@/function/dialogue/info";
import { getIncrementalDialogue } from "@/function/dialogue/incremental-info";
import { editDialaogueNodeContent } from "@/function/dialogue/edit";
interface DialogueTreeModalProps {
  isOpen: boolean;
  onClose: () => void;
  characterId?: string;
  onDialogueEdit?: () => void;
}
interface ELKNode {
  id: string;
  width?: number;
  height?: number;
  x?: number;
  y?: number;
  children?: ELKNode[];
}
interface ELKEdge {
  id: string;
  sources: string[];
  targets: string[];
}
interface ELKGraph {
  id: string;
  children: ELKNode[];
  edges: ELKEdge[];
}
interface DialogueNode extends Node {
  data: {
    label: string;
    fullContent: string;
    userInput: string;
    assistantResponse: string;
    parsedContent: any;
    onEditClick: (id: string) => void;
    onJumpClick: (id: string) => void;
    isCurrentPath: boolean;
    characterId: string;
  };
}
⋮----
const handleNodeClick = () =>
const handleToggleExpand = (event: React.MouseEvent) =>
const handleJumpClick = async (event: React.MouseEvent) =>
⋮----
onClick=
⋮----
title=
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
function handleEditModalClickOutside(event: MouseEvent)
⋮----
const fetchIncrementalDialogueData = async (characterId: string) =>
const fetchDialogueData = async (characterId: string) =>
⋮----
position: { x: 0, y: 0 }, // Temporary position
⋮----
// Create edges first (for ELK layout calculation)
⋮----
const processIncrementalNodes = async (incrementalResponse: any, characterId: string) =>
⋮----
position: { x: 0, y: 0 }, // Temporary position
⋮----
// Create edges for new nodes
⋮----
const saveEditContent = async () =>
⋮----
<li key=
⋮----
aria-label=
</file>

<file path="components/DownloadCharacterModal.tsx">
import React, { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { handleCharacterUpload } from "@/function/character/import";
import { useLanguage } from "@/app/i18n";
⋮----
interface DownloadCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
interface GithubFile {
  name: string;
  download_url: string;
}
interface CharacterInfo {
  displayName: string;
  author: string;
}
⋮----
const handleDownloadAndImport = async (file: GithubFile) =>
const extractCharacterInfo = (fileName: string): CharacterInfo =>
</file>

<file path="components/EditCharacterModal.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { motion, AnimatePresence } from "framer-motion";
import { trackButtonClick } from "@/utils/google-analytics";
import { updateCharacter } from "@/function/dialogue/update";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
interface EditCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  characterId: string;
  characterData: {
    name: string;
    personality?: string;
    scenario?: string;
    first_mes?: string;
    creatorcomment?: string;
    avatar_path?: string;
  };
  onSave: () => void;
}
⋮----
const handleSubmit = async (e: React.FormEvent) =>
⋮----
onClick=
⋮----
xmlns="http://www.w3.org/2000/svg"
</file>

<file path="components/EditPromptModal.tsx">
import React, { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { updatePromptInPreset } from "@/function/preset/edit";
interface PresetPromptData {
  identifier: string;
  name: string;
  system_prompt?: boolean;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  injection_position?: number;
  injection_depth?: number;
  forbid_overrides?: boolean;
  contentLength: number;
}
interface EditPromptModalProps {
  isOpen: boolean;
  onClose: () => void;
  presetId: string;
  prompt: PresetPromptData | null;
  onSave: () => void;
}
⋮----
const handleSave = async () =>
</file>

<file path="components/GoogleAnalytics.tsx">
import Script from "next/script";
import { useEffect, Suspense } from "react";
import { usePathname, useSearchParams } from "next/navigation";
import { GA_MEASUREMENT_ID, initGA, pageview } from "@/utils/google-analytics";
function GoogleAnalyticsContent()
⋮----
src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
⋮----
export default function GoogleAnalytics()
</file>

<file path="components/HomeContent.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import Link from "next/link";
import { useLanguage } from "../app/i18n";
import UserTour from "@/components/UserTour";
import { useTour } from "@/hooks/useTour";
⋮----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="components/ImportCharacterModal.tsx">
import { useState, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
import { handleCharacterUpload } from "@/function/character/import";
interface ImportCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
⋮----
const handleDragOver = (e: React.DragEvent<HTMLDivElement>) =>
const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) =>
const handleDrop = (e: React.DragEvent<HTMLDivElement>) =>
const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleUpload = async () =>
const resetForm = () =>
const handleClose = () =>
</file>

<file path="components/ImportPresetModal.tsx">
import React, { useState, useRef } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importPresetFromJson } from "@/function/preset/import";
interface ImportPresetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
⋮----
const handleFileSelect = async (file: File) =>
⋮----
// 不立即导入，显示预览和自定义表单
⋮----
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleImport = async () =>
const handleClose = () =>
</file>

<file path="components/ImportRegexScriptModal.tsx">
import React, { useState, useRef, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importRegexScriptFromJson } from "@/function/regex/import";
import { listGlobalRegexScripts, importFromGlobalRegexScript, GlobalRegexScript, deleteGlobalRegexScript } from "@/function/regex/global";
interface ImportRegexScriptModalProps {
  isOpen: boolean;
  characterId: string;
  onClose: () => void;
  onImportSuccess: () => void;
}
⋮----
const loadGlobalRegexScripts = async () =>
const handleImportFromGlobal = async () =>
const handleFilesSelect = async (files: File[]) =>
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleClose = () =>
const handleDeleteGlobalScript = async (globalId: string, event: React.MouseEvent) =>
⋮----
onChange=
⋮----
onClick=
</file>

<file path="components/ImportWorldBookModal.tsx">
import React, { useState, useRef, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importWorldBookFromJson } from "@/function/worldbook/import";
import { listGlobalWorldBooks, importFromGlobalWorldBook, GlobalWorldBook, deleteGlobalWorldBook } from "@/function/worldbook/global";
interface ImportWorldBookModalProps {
  isOpen: boolean;
  characterId: string;
  onClose: () => void;
  onImportSuccess: () => void;
}
⋮----
const loadGlobalWorldBooks = async () =>
const handleImportFromGlobal = async () =>
const handleFileSelect = async (file: File) =>
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleClose = () =>
const handleDeleteGlobalWorldBook = async (globalId: string, event: React.MouseEvent) =>
⋮----
onChange=
⋮----
onClick=
</file>

<file path="components/LoadingTransition.tsx">
import { useEffect, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import gsap from "gsap";
import { useSoundContext } from "@/contexts/SoundContext";
interface LoadingTransitionProps {
  onAnimationComplete?: () => void;
  redirectUrl?: string;
  autoRedirect?: boolean;
  duration?: number;
}
⋮----
const startAnimation = () =>
const finishAnimation = () =>
const fadeOut = () =>
</file>

<file path="components/LoginModal.tsx">
import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useLanguage } from "@/app/i18n";
interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
}
⋮----
const handleClickOutside = (event: MouseEvent) =>
const handleEscape = (event: KeyboardEvent) =>
⋮----
const handleNext = () =>
const handlePrev = () =>
const handleKeyPress = (e: React.KeyboardEvent) =>
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleLogin = async (e: React.FormEvent) =>
const handleSendVerificationCode = () =>
⋮----
<a href="#" className="text-[#c0a480] hover:text-[#f9c86d] transition-colors text-xs">
</file>

<file path="components/MainLayout.tsx">
import { useState, useEffect } from "react";
import Sidebar from "@/components/Sidebar";
import ModelSidebar from "@/components/ModelSidebar";
import SettingsDropdown from "@/components/SettingsDropdown";
import LoginModal from "@/components/LoginModal";
import MobileBottomNav from "@/components/MobileBottomNav";
⋮----
const checkIfMobile = () =>
⋮----
const toggleSidebar = () =>
const toggleModelSidebar = () =>
</file>

<file path="components/MobileBottomNav.tsx">
import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter, usePathname } from "next/navigation";
import { useLanguage } from "@/app/i18n";
⋮----
interface MobileBottomNavProps {
  openLoginModal: () => void;
}
⋮----
const checkIfMobile = () =>
⋮----
const handleLogout = () =>
const isActive = (path: string) =>
</file>

<file path="components/ModelSidebar.tsx">
import { useState, useEffect } from "react";
⋮----
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
interface ModelSidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
}
type LLMType = "openai" | "ollama";
interface APIConfig {
  id: string;
  name: string;
  type: LLMType;
  baseUrl: string;
  model: string;
  apiKey?: string;
}
⋮----
/**
   * Loads saved configurations from localStorage and initializes the component state
   * Handles error cases and sets up initial active configuration
   */
⋮----
/**
   * Loads a configuration into the form fields
   * @param {APIConfig} config - The configuration to load
   */
const loadConfigToForm = (config: APIConfig) =>
/**
   * Generates a unique ID for new configurations
   * @returns {string} A unique identifier
   */
const generateId = () => `api_$
/**
   * Initiates the creation of a new configuration
   * Resets form fields and shows the new configuration form
   */
const handleCreateConfig = () =>
/**
   * Cancels the creation of a new configuration
   * Restores the previous state if available
   */
const handleCancelCreate = () =>
/**
   * Saves the current configuration
   * Handles both new configurations and updates to existing ones
   * Persists changes to localStorage
   */
const handleSave = () =>
const generateConfigName = (type: LLMType, model: string): string =>
const handleDeleteConfig = (id: string) =>
/**
   * Switches to a different configuration
   * @param {string} id - The ID of the configuration to switch to
   */
const handleSwitchConfig = (id: string) =>
const handleGetModelList = async (baseUrl: string, apiKey: string) =>
const handleStartEditName = (config: APIConfig, e: React.MouseEvent) =>
const handleSaveName = () =>
/**
   * Handles keyboard events during name editing
   * @param {React.KeyboardEvent} e - The keyboard event
   */
const handleKeyDown = (e: React.KeyboardEvent) =>
/**
   * Tests the current model configuration using LangChain
   * Sends a test request to verify the configuration works
   * Uses a minimal test prompt to check model connectivity and response
   */
const handleTestModel = async () =>
⋮----
// Initialize the appropriate LangChain client based on LLM type
⋮----
onChange=
⋮----
onClick=
</file>

<file path="components/PresetEditor.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { getAllPresets, getPreset, deletePreset, togglePresetEnabled, getPromptsForDisplay } from "@/function/preset/global";
import { deletePromptFromPreset, togglePromptEnabled } from "@/function/preset/edit";
import { useLanguage } from "@/app/i18n";
import ImportPresetModal from "@/components/ImportPresetModal";
import CreatePresetModal from "@/components/CreatePresetModal";
⋮----
import React from "react";
import EditPromptModal from "@/components/EditPromptModal";
interface PresetEditorProps {
  onClose: () => void;
  characterName?: string;
  characterId?: string;
}
interface PresetData {
  id: string;
  name: string;
  enabled?: boolean;
  prompts: PresetPromptData[];
  created_at?: string;
  updated_at?: string;
  totalPrompts: number;
  enabledPrompts: number;
  lastUpdated: number;
}
interface PresetPromptData {
  identifier: string;
  name: string;
  system_prompt?: boolean;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  injection_position?: number;
  injection_depth?: number;
  forbid_overrides?: boolean;
  contentLength: number;
}
⋮----
const loadSortPreferences = () =>
const loadFilterPreferences = () =>
const saveSortPreferences = (newSortBy: string, newSortOrder: "asc" | "desc") =>
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const saveFilterPreferences = (newFilterBy: string) =>
⋮----
const loadPresetData = async () =>
const filterPresets = (presets: PresetData[], filterBy: string) =>
const sortPresets = (presets: PresetData[], sortBy: string, sortOrder: "asc" | "desc") =>
⋮----
const handleCreatePreset = async () =>
const handleDeletePreset = async (presetId: string) =>
const handleSelectPreset = async (presetId: string) =>
const toggleRowExpansion = (presetId: string) =>
const handleDeletePrompt = async (presetId: string, promptIdentifier: string) =>
const handleEditPrompt = (prompt: PresetPromptData) =>
const handleCloseEditModal = () =>
const handleSaveEditPrompt = async () =>
const handleTogglePrompt = async (presetId: string, promptIdentifier: string, enableState: boolean) =>
const handleTogglePreset = async (presetId: string, enableState: boolean) =>
</file>

<file path="components/PromptEditor.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
interface PromptEditorProps {
  isOpen: boolean;
  onClose: () => void;
  characterId: string;
  characterName: string;
  onSave: (prompts: {
    prefixPrompt: string;
    chainOfThoughtPrompt: string;
    suffixPrompt: string;
  }) => void;
  initialPrompts?: {
    prefixPrompt: string;
    chainOfThoughtPrompt: string;
    suffixPrompt: string;
  };
}
⋮----
const handleResize = () =>
⋮----
const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) =>
const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) =>
const handleMouseUp = () =>
const handleSave = () =>
⋮----
onClick=
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
</file>

<file path="components/RegexScriptEditor.tsx">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { RegexScript, RegexScriptSettings } from "@/lib/models/regex-script-model";
import { trackButtonClick } from "@/utils/google-analytics";
import RegexScriptEntryEditor from "@/components/RegexScriptEntryEditor";
import ImportRegexScriptModal from "@/components/ImportRegexScriptModal";
import { updateRegexScriptSettings } from "@/function/regex/update-setting";
import { getRegexScripts } from "@/function/regex/get";
import { getRegexScriptSettings } from "@/function/regex/get-setting";
import { addRegexScript } from "@/function/regex/add";
import { updateRegexScript } from "@/function/regex/update";
import { deleteRegexScript } from "@/function/regex/delete";
interface Props {
  onClose: () => void;
  characterName: string;
  characterId: string;
}
⋮----
const loadScriptsAndSettings = async () =>
const handleSaveScript = async (script: Partial<RegexScript &
const handleDeleteScript = async (scriptId: string) =>
const handleToggleScript = async (scriptId: string) =>
const handleUpdateSettings = async (updates: Partial<RegexScriptSettings>) =>
const toggleScriptExpansion = (scriptId: string) =>
const filterScripts = (scripts: Record<string, RegexScript>, filterBy: string) =>
const sortScripts = (scriptEntries: [string, RegexScript][], sortBy: string, sortOrder: "asc" | "desc") =>
⋮----
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const truncateText = (text: string, maxLength: number = 50) =>
</file>

<file path="components/RegexScriptEntryEditor.tsx">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { RegexScript } from "@/lib/models/regex-script-model";
import { toast } from "react-hot-toast";
interface RegexScriptEntryEditorProps {
  isOpen: boolean;
  editingScript: Partial<RegexScript> | null;
  isSaving: boolean;
  onClose: () => void;
  onSave: (script: Partial<RegexScript>) => Promise<void>;
  onScriptChange: (script: Partial<RegexScript>) => void;
}
⋮----
const updateScript = (updates: Partial<RegexScript>) =>
const handleSave = async () =>
⋮----
onChange=
⋮----
</file>

<file path="components/SettingsDropdown.tsx">
import { useState, useRef, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { useSoundContext } from "@/contexts/SoundContext";
import { useTour } from "@/hooks/useTour";
import { exportDataToFile, importDataFromFile, generateExportFilename, downloadFile } from "@/function/data/export-import";
import { backupToGoogle, getFolderList, getGoogleCodeByUrl, getGoogleLoginUrl, getBackUpFile } from "@/function/data/google-control";
interface SettingsDropdownProps {
  toggleModelSidebar: () => void;
}
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
const toggleLanguage = () =>
const openModelSettings = () =>
const handleExportData = async () =>
const handleImportData = async () =>
async function handleImportDataFromGoogle()
async function handleExportDataToGoogle()
</file>

<file path="components/Sidebar.tsx">
import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useLanguage } from "@/app/i18n";
import { isUpdateAvailable, fetchLatestRelease } from "@/utils/version-compare";
⋮----
interface SidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
  openLoginModal: () => void;
}
⋮----
const checkIfMobile = () =>
⋮----
const checkForUpdates = async () =>
⋮----
const handleLogout = () =>
</file>

<file path="components/TagColorEditor.tsx">
import React, { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { SketchPicker } from "react-color";
import { useSymbolColorStore } from "@/contexts/SymbolColorStore";
import { toast } from "react-hot-toast";
interface SymbolColor {
  symbol: string;
  color: string;
}
interface TagColorEditorProps {
  onSave: (colors: SymbolColor[]) => void;
  onViewSwitch?: () => void;
}
⋮----
const handleAddSymbol = () =>
const handleColorChange = (symbol: string, color: string) =>
const handleSave = async () =>
const handleDeleteSymbol = (symbolToDelete: string) =>
const handlePredefinedColorSelect = (symbol: string, color: string) =>
⋮----
onChange=
placeholder=
</file>

<file path="components/UserTour.tsx">
import { useState, useEffect, useRef } from "react";
import { useLanguage } from "@/app/i18n";
interface TourStep {
  target: string;
  title: string;
  content: string;
  position: "top" | "bottom" | "left" | "right";
  allowSkip?: boolean;
  isLanguageSelection?: boolean;
}
interface UserTourProps {
  steps: TourStep[];
  isVisible: boolean;
  onComplete: () => void;
  onSkip: () => void;
}
⋮----
const updateTargetPosition = () =>
⋮----
const nextStep = () =>
const prevStep = () =>
const skipTour = () =>
⋮----
const getTooltipPosition = () =>
</file>

<file path="components/WorldBookEditor.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { getWorldBookEntries } from "@/function/worldbook/info";
import { deleteWorldBookEntry } from "@/function/worldbook/delete";
import { saveAdvancedWorldBookEntry } from "@/function/worldbook/edit";
import { bulkToggleWorldBookEntries } from "@/function/worldbook/bulk-operations";
import { getWorldBookSettings } from "@/function/worldbook/settings";
import { useLanguage } from "@/app/i18n";
import WorldBookEntryEditor from "@/components/WorldBookEntryEditor";
import ImportWorldBookModal from "@/components/ImportWorldBookModal";
⋮----
import React from "react";
import { v4 as uuidv4 } from "uuid";
interface WorldBookEditorProps {
  onClose: () => void;
  characterName: string;
  characterId: string;
}
interface WorldBookEntryData {
  entry_id: string;
  id?: number;
  content: string;
  keys: string[];
  secondary_keys: string[];
  selective: boolean;
  constant: boolean;
  position: string | number;
  insertion_order: number;
  enabled: boolean;
  use_regex: boolean;
  depth: number;
  comment: string;
  tokens?: number;
  extensions?: any;
  primaryKey: string;
  keyCount: number;
  secondaryKeyCount: number;
  contentLength: number;
  isActive: boolean;
  lastUpdated: number;
  isImported: boolean;
  importedAt: number | null;
}
interface EditingEntry {
  entry_id: string;
  id?: number;
  comment: string;
  keys: string[];
  secondary_keys: string[];
  content: string;
  position: number;
  depth: number;
  enabled: boolean;
  use_regex: boolean;
  selective: boolean;
  constant: boolean;
  insertion_order: number;
}
⋮----
const loadSortPreferences = () =>
const loadFilterPreferences = () =>
const saveSortPreferences = (newSortBy: string, newSortOrder: "asc" | "desc") =>
const cleanupOldSortPreferences = () =>
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const saveFilterPreferences = (newFilterBy: string) =>
⋮----
const loadWorldBookData = async () =>
const loadSettings = async () =>
const filterEntries = (entries: WorldBookEntryData[], filterBy: string) =>
const sortEntries = (entries: WorldBookEntryData[], sortBy: string, sortOrder: "asc" | "desc") =>
⋮----
const handleEditEntry = (entry?: WorldBookEntryData) =>
const handleSaveEntry = async () =>
const toggleRowExpansion = (entryId: string) =>
const getPositionText = (position: string | number) =>
const handleBulkToggleAll = async (enabled: boolean) =>
const handleDeleteEntry = async (entryId: string) =>
const handleToggleEntry = async (entryId: string, newEnabled: boolean) =>
⋮----
<span className="block truncate text-[10px] sm:text-sm" title=
⋮----
onClick=
</file>

<file path="components/WorldBookEntryEditor.tsx">
import { useLanguage } from "@/app/i18n";
import { useState } from "react";
interface EditingEntry {
  entry_id: string;
  id?: number;
  comment: string;
  keys: string[];
  secondary_keys: string[];
  content: string;
  position: number;
  depth: number;
  enabled: boolean;
  use_regex: boolean;
  selective: boolean;
  constant: boolean;
  insertion_order: number;
}
interface WorldBookEntryEditorProps {
  isOpen: boolean;
  editingEntry: EditingEntry | null;
  isSaving: boolean;
  onClose: () => void;
  onSave: () => void;
  onEntryChange: (entry: EditingEntry) => void;
}
⋮----
const handleKeywordChange = (index: number, value: string) =>
const handleRemoveKeyword = (index: number) =>
const handleAddKeyword = () =>
const handleSecondaryKeywordChange = (index: number, value: string) =>
const handleRemoveSecondaryKeyword = (index: number) =>
const handleAddSecondaryKeyword = () =>
⋮----
onChange=
⋮----
placeholder=
⋮----
<span className="text-sm text-[#eae6db] group-hover:text-amber-200 transition-colors duration-300">
⋮----
<span className="text-sm text-[#eae6db] group-hover:text-green-200 transition-colors duration-300">
</file>

<file path="contexts/SoundContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
interface SoundContextType {
  soundEnabled: boolean;
  toggleSound: () => void;
}
⋮----
export function useSoundContext()
interface SoundProviderProps {
  children: ReactNode;
}
export function SoundProvider(
⋮----
const toggleSound = () =>
</file>

<file path="contexts/SymbolColorStore.ts">
import { create } from "zustand";
import { persist } from "zustand/middleware";
export interface SymbolColor {
  symbol: string;
  color: string;
}
⋮----
interface SymbolColorStore {
  symbolColors: SymbolColor[];
  updateSymbolColors: (colors: SymbolColor[]) => void;
  getColorForSymbol: (symbol: string) => string | undefined;
  getColorForHtmlTag: (tagName: string, className?: string) => string | undefined;
  getPredefinedColors: (symbol: string) => string[];
  addCustomTag: (tagName: string, color?: string) => void;
}
</file>

<file path="docs/GETTING_STARTED.md">
# Getting Started with Narratium.ai

This guide will help you get Narratium.ai up and running on your system.

## Prerequisites

- Node.js (v16 or higher)
- pnpm (recommended) or npm
- Git

## Installation Steps

### 1. Clone the project

```bash
git clone https://github.com/Narratium/Narratium.ai.git
cd Narratium
```

### 2. Install dependencies

```bash
pnpm install
```

### 3. Run the project

```bash
pnpm run dev
```

Once the development server starts, visit: [http://localhost:3000](http://localhost:3000)

## Self-packaging

If you want to create a standalone application:

1. First, install the pake-cli globally:
```bash
npm install -g pake-cli
```

2. Then, depending on your operating system, run one of the following commands:

For Docker:
```bash
docker-compose up --build
```

For macOS:
```bash
pnpm pake-mac
```

For Linux:
```bash
pnpm pake-linux
```

For Windows:
```bash
pnpm pake-win
```

### Troubleshooting

#### macOS Installation Fix

If you encounter a "damaged" display after installation on macOS, run this command in terminal:

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```

## Next Steps

- Check out our [documentation](https://deepwiki.com/Narratium/Narratium.ai/) for detailed guides
- Join our community for support and updates
- Star the repository to stay updated with new releases
</file>

<file path="docs/PROBLEM.md">
mac 安装后显示损坏解决方案：打开命令行，输入：

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```

Solution for "damaged" display after macOS installation: Open the terminal and enter:

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```
</file>

<file path="docs/VERCEL_DEPLOYMENT.md">
# Vercel Deployment Guide / Vercel 部署指南

## English

### Quick Deploy
Click the button below to deploy Narratium.ai to Vercel with one click:

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/Narratium.ai)

### Manual Deployment Steps

1. **Fork the Repository**
   - Fork this repository to your GitHub account

2. **Import to Vercel**
   - Go to [vercel.com](https://vercel.com)
   - Click "New Project"
   - Import your forked repository

3. **Configure Build Settings**
   - Framework Preset: `Next.js`
   - Build Command: `pnpm build` (or leave default)
   - Output Directory: `.next` (default)

4. **Environment Variables** (if needed)
   - Add any required environment variables in Vercel dashboard
   - Common variables: API keys, database URLs, etc.

5. **Deploy**
   - Click "Deploy"
   - Your app will be available at `your-project.vercel.app`

### Auto-Deploy
Once connected, Vercel will automatically deploy when you push to your main branch.

**Please make sure to review the LICENSE file for fork permissions and restrictions, especially regarding brand elements and generated content.**

### Support

For deployment issues, check [Vercel Documentation](https://vercel.com/docs)

---

## 中文

### 快速部署
点击下方按钮一键部署 Narratium.ai 到 Vercel：

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/Narratium.ai)

### 手动部署步骤

1. **Fork 仓库**
   - 将此仓库 Fork 到您的 GitHub 账户

2. **导入到 Vercel**
   - 访问 [vercel.com](https://vercel.com)
   - 点击 "New Project"
   - 导入您 Fork 的仓库

3. **配置构建设置**
   - 框架预设：`Next.js`
   - 构建命令：`pnpm build`（或保持默认）
   - 输出目录：`.next`（默认）

4. **环境变量**（如需要）
   - 在 Vercel 控制台添加所需的环境变量
   - 常见变量：API 密钥、数据库 URL 等

5. **部署**
   - 点击 "Deploy"
   - 您的应用将在 `your-project.vercel.app` 可用

### 自动部署
连接后，每当您推送到主分支时，Vercel 将自动部署。

**请务必查阅 LICENSE 文件，了解 fork 权限和限制，特别是关于品牌元素和生成内容的相关规定。**

### 支持

部署问题请查看 [Vercel 文档](https://vercel.com/docs)
</file>

<file path="function/character/delete.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { deleteBlob } from "@/lib/data/local-storage";
export async function deleteCharacter(character_id: string): Promise<
</file>

<file path="function/character/import.ts">
import { parseCharacterCard } from "@/utils/character-parser";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { setBlob } from "@/lib/data/local-storage";
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
import { v4 as uuidv4 } from "uuid";
export async function handleCharacterUpload(file: File)
</file>

<file path="function/character/list.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { adaptCharacterData } from "@/lib/adapter/tagReplacer";
export async function getAllCharacters(language: "en" | "zh", username?: string)
</file>

<file path="function/data/export-import.ts">
import { exportAllData, importAllData } from "@/lib/data/local-storage";
export async function exportDataToFile(): Promise<Blob>
export async function importDataFromFile(file: File): Promise<void>
export function generateExportFilename(): string
export function downloadFile(blob: Blob, filename: string): void
</file>

<file path="function/data/google-control.ts">
import { createRequest } from "@/function/data/google-request";
⋮----
export function getGoogleLoginUrl()
export function getGoogleToken(code: string)
export function refreshGoogleToken()
export async function getGoogleCodeByUrl(url: Location)
export async function backupToGoogle(info:
export async function getFolderList()
async function createDefaultFolder()
export async function getBackUpFile(folderId:string)
</file>

<file path="function/data/google-request.ts">
import { refreshGoogleToken } from "./google-control";
export async function createRequest<T = any>(url: string, info: Partial<RequestInit &
</file>

<file path="function/dialogue/chat.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { PromptType } from "@/lib/models/character-prompts-model";
import { ParsedResponse } from "@/lib/models/parsed-response";
import { DialogueWorkflow, DialogueWorkflowParams } from "@/lib/workflow/examples/DialogueWorkflow";
export async function handleCharacterChatRequest(payload: {
  username?: string;
  characterId: string;
  message: string;
  modelName: string;
  baseUrl: string;
  apiKey: string;
  llmType?: string;
  streaming?: boolean;
  language?: "zh" | "en";
  promptType?: PromptType;
  number?: number;
  nodeId: string;
  fastModel: boolean;
}): Promise<Response>
async function processPostResponseAsync({
  characterId,
  message,
  fullResponse,
  screenContent,
  event,
  nextPrompts,
  nodeId,
}: {
  characterId: string;
  message: string;
  fullResponse: string;
  screenContent: string;
  event: string;
  nextPrompts: string[];
  nodeId: string;
})
</file>

<file path="function/dialogue/delete.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
interface DeleteDialogueNodeOptions {
  characterId: string;
  nodeId: string;
}
export async function deleteDialogueNode(
</file>

<file path="function/dialogue/edit.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { CharacterDialogue } from "@/lib/core/character-dialogue";
import { parseEvent } from "@/utils/response-parser";
import { DialogueNode } from "@/lib/models/node-model";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
interface EditDialogueNodeRequest {
  characterId: string;
  nodeId: string;
  assistantResponse: string;
  model_name: string;
  api_key: string;
  base_url: string;
  llm_type: string;
  language: string;
}
export async function editDialaogueNodeContent(input: EditDialogueNodeRequest)
</file>

<file path="function/dialogue/incremental-info.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
interface IncrementalDialogueParams {
  characterId: string;
  lastKnownNodeIds?: string[];
  lastUpdateTime?: string;
  language?: "en" | "zh";
}
interface IncrementalDialogueResponse {
  success: boolean;
  hasNewData: boolean;
  newNodes: any[];
  updatedNodes: any[];
  deletedNodeIds: string[];
  currentNodeId: string;
  totalNodeCount: number;
  lastUpdateTime: string;
}
export async function getIncrementalDialogue(params: IncrementalDialogueParams): Promise<IncrementalDialogueResponse>
export async function hasNewDialogueNodes(characterId: string, lastKnownNodeCount: number): Promise<boolean>
</file>

<file path="function/dialogue/info.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
export async function getCharacterDialogue(characterId: string, language: "en" | "zh" = "zh", username?: string)
</file>

<file path="function/dialogue/init.ts">
import { Character } from "@/lib/core/character";
import { CharacterDialogue } from "@/lib/core/character-dialogue";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { PromptType } from "@/lib/models/character-prompts-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
import { RegexProcessor } from "@/lib/core/regex-processor";
interface InitCharacterDialogueOptions {
  username?: string;
  characterId: string;
  language?: "zh" | "en";
  modelName: string;
  baseUrl: string;
  apiKey: string;
  llmType: "openai" | "ollama";
}
export async function initCharacterDialogue(options: InitCharacterDialogueOptions)
</file>

<file path="function/dialogue/save-prompts.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
interface SaveCharacterPromptsOptions {
  characterId: string;
  prompts: any;
}
export async function saveCharacterPrompts(
</file>

<file path="function/dialogue/truncate.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
interface SwitchDialogueBranchOptions {
  characterId: string;
  nodeId: string;
}
export async function switchDialogueBranch(
</file>

<file path="function/dialogue/update.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
export async function updateCharacter(
  character_id: string,
  character_data: any,
): Promise<
</file>

<file path="function/preset/download.ts">
import { importPresetFromJson } from "@/function/preset/import";
import { PresetOperations } from "@/lib/data/preset-operation";
interface GithubPreset {
  name: string;
  displayName: {
    zh: string;
    en: string;
  };
  description: {
    zh: string;
    en: string;
  };
  filename: string;
}
⋮----
export function getAvailableGithubPresets(): GithubPreset[]
export function getPresetDisplayName(presetName: string, language: "zh" | "en" = "zh"): string
export function getPresetDescription(presetName: string, language: "zh" | "en" = "zh"): string
export async function isPresetDownloaded(presetName: string): Promise<boolean>
export async function doesPresetExist(presetName: string): Promise<boolean>
export async function downloadPresetFromGithub(presetName: string, language: "zh" | "en" = "zh"): Promise<
function markPresetAsDownloaded(presetName: string): void
</file>

<file path="function/preset/edit.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
export async function deletePromptFromPreset(
  presetId: string,
  promptIdentifier: string,
)
export async function togglePromptEnabled(
  presetId: string,
  promptIdentifier: string,
  enabled: boolean,
)
export async function updatePromptInPreset(
  presetId: string,
  promptIdentifier: string,
  updates: { content?: string; enabled?: boolean; position?: number },
)
</file>

<file path="function/preset/global.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
import { Preset } from "@/lib/models/preset-model";
export async function getAllPresets()
export async function getPreset(presetId: string)
export async function createPreset(preset: Preset)
export async function deletePreset(presetId: string)
export async function togglePresetEnabled(presetId: string, enabled: boolean)
export async function getPromptsForDisplay(presetId: string)
</file>

<file path="function/preset/import.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
export async function importPresetFromJson(jsonContent: string, customName?: string): Promise<
</file>

<file path="function/regex/add.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function addRegexScript(characterId: string, script: RegexScript): Promise<string | null>
</file>

<file path="function/regex/delete.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function deleteRegexScript(characterId: string, scriptId: string): Promise<boolean>
</file>

<file path="function/regex/get-setting.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function getRegexScriptSettings(characterId: string): Promise<RegexScriptSettings>
</file>

<file path="function/regex/get.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function getRegexScripts(characterId: string): Promise<Record<string, RegexScript> | null>
</file>

<file path="function/regex/global.ts">
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
export interface GlobalRegexScript {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  scriptCount: number;
  sourceCharacterId?: string;
  sourceCharacterName?: string;
}
export interface GlobalRegexScriptResult {
  success: boolean;
  message: string;
  globalId?: string;
  regexScript?: GlobalRegexScript;
}
export interface ListGlobalRegexScriptsResult {
  success: boolean;
  globalRegexScripts: GlobalRegexScript[];
  message?: string;
}
export async function getNextGlobalId(): Promise<string>
export async function listGlobalRegexScripts(): Promise<ListGlobalRegexScriptsResult>
export async function getGlobalRegexScript(globalId: string): Promise<
export async function importFromGlobalRegexScript(
  characterId: string,
  globalId: string,
): Promise<
export async function deleteGlobalRegexScript(globalId: string): Promise<
</file>

<file path="function/regex/import.ts">
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
import { v4 as uuidv4 } from "uuid";
export interface ImportRegexScriptResult {
  success: boolean;
  message: string;
  importedCount: number;
  skippedCount: number;
  errors: string[];
  globalId?: string;
  successfulFiles?: string[];
  failedFiles?: string[];
}
export async function importRegexScriptFromJson(
  characterId: string,
  jsonData: any,
  options?: {
    saveAsGlobal?: boolean;
    globalName?: string;
    globalDescription?: string;
    sourceCharacterName?: string;
  },
): Promise<ImportRegexScriptResult>
export function validateRegexScriptJson(jsonData: any):
</file>

<file path="function/regex/update-setting.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function updateRegexScriptSettings(
  characterId: string,
  updates: Partial<RegexScriptSettings>,
): Promise<RegexScriptSettings>
</file>

<file path="function/regex/update.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function updateRegexScript(
  characterId: string,
  scriptId: string,
  updates: Partial<RegexScript>,
): Promise<boolean>
</file>

<file path="function/worldbook/bulk-operations.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function bulkToggleWorldBookEntries(
  characterId: string,
  entryIds: string[],
  enabled: boolean,
)
</file>

<file path="function/worldbook/delete.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function deleteWorldBookEntry(characterId: string, entryId: string)
</file>

<file path="function/worldbook/edit.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export async function saveAdvancedWorldBookEntry(
  characterId: string,
  entry: Partial<WorldBookEntry> & {
    entry_id: string;
    keys: string[];
    content: string;
  },
)
</file>

<file path="function/worldbook/global.ts">
import { WorldBookOperations, WorldBookSettings } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface GlobalWorldBook {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  entryCount: number;
  sourceCharacterId?: string;
  sourceCharacterName?: string;
}
export interface GlobalWorldBookResult {
  success: boolean;
  message: string;
  globalId?: string;
  worldBook?: GlobalWorldBook;
}
export interface ListGlobalWorldBooksResult {
  success: boolean;
  globalWorldBooks: GlobalWorldBook[];
  message?: string;
}
export async function getNextGlobalId(): Promise<string>
export async function saveAsGlobalWorldBook(
  characterId: string,
  name: string,
  description?: string,
  sourceCharacterName?: string,
): Promise<GlobalWorldBookResult>
export async function listGlobalWorldBooks(): Promise<ListGlobalWorldBooksResult>
export async function getGlobalWorldBook(globalId: string): Promise<
export async function importFromGlobalWorldBook(
  characterId: string,
  globalId: string,
): Promise<
export async function deleteGlobalWorldBook(globalId: string): Promise<
</file>

<file path="function/worldbook/import.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { v4 as uuidv4 } from "uuid";
import { saveAsGlobalWorldBook } from "./global";
export interface ImportWorldBookResult {
  success: boolean;
  message: string;
  importedCount: number;
  skippedCount: number;
  errors: string[];
  globalId?: string;
}
export async function importWorldBookFromJson(
  characterId: string,
  jsonData: any,
  options?: {
    saveAsGlobal?: boolean;
    globalName?: string;
    globalDescription?: string;
    sourceCharacterName?: string;
  },
): Promise<ImportWorldBookResult>
export function validateWorldBookJson(jsonData: any):
</file>

<file path="function/worldbook/info.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function getWorldBookEntries(characterId: string)
</file>

<file path="function/worldbook/settings.ts">
import { WorldBookOperations, WorldBookSettings } from "@/lib/data/world-book-operation";
export async function getWorldBookSettings(characterId: string)
export async function updateWorldBookSettings(
  characterId: string,
  updates: Partial<WorldBookSettings>,
)
</file>

<file path="hooks/useTour.ts">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
export interface TourStep {
  target: string;
  title: string;
  content: string;
  position: "top" | "bottom" | "left" | "right";
  allowSkip?: boolean;
  isLanguageSelection?: boolean;
}
⋮----
export function useTour()
⋮----
const startHomeTour = () =>
const startCharacterTour = () =>
const completeTour = () =>
const skipTour = () =>
const resetTour = () =>
</file>

<file path="lib/adapter/tagReplacer.ts">
export function adaptText(text: string, language: "en" | "zh", username?: string, charName?: string): string
export function adaptCharacterData(
  characterData: any,
  language: "en" | "zh",
  username?: string,
): any
</file>

<file path="lib/core/agent-engine.ts">
import {
  AgentConversation,
  AgentStep,
  AgentMessage,
  AgentTaskStatus,
  AgentCapability,
  AgentExecutionContext,
  AgentTool,
} from "@/lib/models/agent-model";
import {
  AgentConversationOperations,
  AgentToolOperations,
} from "@/lib/data/agent-operation";
import {
  AgentToolRegistry,
  registerAllTools,
} from "@/lib/core/agent-tools";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { v4 as uuidv4 } from "uuid";
interface AgentDecision {
  action: "use_tool" | "ask_user" | "complete_task" | "request_clarification";
  toolId?: string;
  toolInput?: any;
  message?: string;
  reasoning?: string;
  isComplete?: boolean;
  result?: any;
}
export class AgentEngine
⋮----
constructor(conversationId: string, llmConfig: {
    modelName: string;
    apiKey: string;
    baseUrl?: string;
    llmType: "openai" | "ollama";
    temperature?: number;
})
async initialize(): Promise<void>
async executeWorkflow(userInput: string): Promise<
async continueWorkflow(userResponse: string): Promise<
private async getNextDecision(): Promise<AgentDecision>
private async executeDecision(decision: AgentDecision, stepsExecuted: AgentStep[]): Promise<
private async executeStep(capability: AgentCapability, input: any, reasoning?: string): Promise<AgentStep>
private async getLLM()
private getCurrentStatus(): string
private updateWorkingMemoryFromTool(toolId: string, output: any): void
private finalizeOutput(): void
private formatStepMessage(capability: AgentCapability, output: any): string
getContext(): AgentExecutionContext
getWorkingMemory(): Record<string, any>
</file>

<file path="lib/core/agent-service.ts">
import { AgentEngine } from "./agent-engine";
import { AgentConversationOperations } from "@/lib/data/agent-operation";
import { AgentConversation, AgentTaskStatus } from "@/lib/models/agent-model";
export class AgentService
⋮----
async startGeneration(
    title: string,
    userInput: string,
    llmConfig: {
      modelName: string;
      apiKey: string;
      baseUrl?: string;
      llmType: "openai" | "ollama";
      temperature?: number;
    },
): Promise<
async continueGeneration(
    conversationId: string,
    userResponse: string,
): Promise<
async getConversationStatus(conversationId: string): Promise<
async listConversations(): Promise<AgentConversation[]>
async deleteConversation(conversationId: string): Promise<boolean>
async exportConversation(conversationId: string): Promise<
async getGenerationStats(): Promise<
async cleanup(conversationId: string): Promise<void>
getEngine(conversationId: string): AgentEngine | undefined
</file>

<file path="lib/core/agent-tools.ts">
import { AgentTool, AgentCapability, AgentExecutionContext } from "@/lib/models/agent-model";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
export class AgentToolRegistry
⋮----
static register(tool: AgentTool): void
static get(toolId: string): AgentTool | undefined
static getAll(): AgentTool[]
static getByCapability(capability: AgentCapability): AgentTool[]
static clear(): void
⋮----
export abstract class BaseTool implements AgentTool
⋮----
abstract execute(input: any, context: AgentExecutionContext): Promise<any>;
protected async getLLM(context: AgentExecutionContext)
protected async callLLM(
    systemPrompt: string,
    userPrompt: string,
    context: AgentExecutionContext,
): Promise<string>
⋮----
export class AnalyzeTool extends BaseTool
⋮----
async execute(input: any, context: AgentExecutionContext): Promise<any>
⋮----
export class AskTool extends BaseTool
⋮----
private formatQuestions(questions: string[], context?: string): string
⋮----
export class SearchTool extends BaseTool
/**
 * PLAN Tool - Creates generation plan and structure
 */
export class PlanTool extends BaseTool
export class OutputTool extends BaseTool
⋮----
private async generateCharacter(input: any, context: AgentExecutionContext): Promise<any>
private async generateWorldbook(input: any, context: AgentExecutionContext): Promise<any>
⋮----
// Fallback if JSON parsing fails
⋮----
private async generateIntegrationNotes(result: any, context: AgentExecutionContext): Promise<string>
⋮----
/**
 * VALIDATE Tool - Validates content quality and consistency
 */
export class ValidateTool extends BaseTool
⋮----
private async validateCharacter(characterData: any, requirements: any, context: AgentExecutionContext): Promise<any>
private async validateWorldbook(worldbookData: any[], requirements: any, context: AgentExecutionContext): Promise<any>
private async validateIntegration(characterData: any, worldbookData: any[], context: AgentExecutionContext): Promise<any>
⋮----
export class RefineTool extends BaseTool
⋮----
private async refineCharacter(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private async refineWorldbook(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private async refineIntegration(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private extractRemainingIssues(validationResults: any): string[]
private extractAddressedIssues(validationResults: any): string[]
⋮----
export function registerAllTools(): void
</file>

<file path="lib/core/character-dialogue.ts">
import { Character } from "@/lib/core/character";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { PromptAssembler } from "@/lib/core/prompt-assembler";
import { RunnablePassthrough } from "@langchain/core/runnables";
import { PromptType } from "@/lib/models/character-prompts-model";
import { getCharacterCompressorPromptZh, getCharacterCompressorPromptEn } from "@/lib/prompts/character-prompts";
import { CharacterHistory } from "@/lib/core/character-history";
import { DialogueOptions } from "@/lib/models/character-dialogue-model";
export class CharacterDialogue
⋮----
constructor(character: Character)
async initialize(options?: DialogueOptions): Promise<void>
async getFirstMessage(): Promise<string[]>
setupLLM(options?: DialogueOptions): void
⋮----
type LLMSettings = {
      temperature: number;
      maxTokens?: number;
      timeout?: number;
      maxRetries: number;
      topP?: number;
      frequencyPenalty?: number;
      presencePenalty?: number;
      topK?: number;
      repeatPenalty?: number;
    };
⋮----
setupDialogueChain(): void
async compressStory(userInput: string, story: string): Promise<string>
</file>

<file path="lib/core/character-history.ts">
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
class DialogueStory
⋮----
constructor(language: string, userInput: string[] | null = null, responses: string[] | null = null)
getStory(startIndex: number | null = null, endIndex: number | null = null): string
⋮----
export class CharacterHistory
⋮----
constructor(language: string, systemMessage: string = "", memLen: number = 10)
getRecentHistory(): string
getCompressedHistory(): string
getSystemMessage(): string
getMessages(): DialogueMessage[]
</file>

<file path="lib/core/character.ts">
import { CharacterRecord } from "@/lib/data/character-record-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { CharacterData } from "@/lib/models/character-model";
import { adaptCharacterData } from "@/lib/adapter/tagReplacer";
export class Character
⋮----
constructor(characterRecord: CharacterRecord)
private processCharacterBook(characterBook: any): WorldBookEntry[] | Record<string, WorldBookEntry>
async getFirstMessage(): Promise<string[]>
getData(language: "en" | "zh" = "zh", username?: string): CharacterData
getSystemPrompt(language: "en" | "zh" = "zh", username?: string): string
</file>

<file path="lib/core/preset-assembler.ts">
import { PresetPrompt } from "@/lib/models/preset-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
import { MULTI_MODE_PROMPT, MULTI_MODE_CHAIN_OF_THOUGHT, OUTPUT_STRUCTURE_SOFT_GUIDE } from "@/lib/prompts/preset-prompts";
export class PresetAssembler
⋮----
static assemblePrompts(
    prompts: PresetPrompt[],
    language: "zh" | "en" = "zh",
    fastModel:boolean,
    contextData: { username?: string; charName?: string; number?: number } = {},
):
private static _getDefaultFramework(language: "zh" | "en" = "zh", contextData:
private static _formatPromptContent(
    prompt: PresetPrompt,
    language: "zh" | "en",
    contextData: { username?: string; charName?: string; number?: number },
): string
</file>

<file path="lib/core/prompt-assembler.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { WorldBookManager } from "@/lib/core/world-book";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
export interface PromptAssemblerOptions {
  language: "zh" | "en";
  contextWindow?: number;
}
export class PromptAssembler
⋮----
constructor(options: PromptAssemblerOptions)
assemblePrompt(
    worldBook: WorldBookEntry[] | Record<string, WorldBookEntry> | undefined,
    baseSystemMessage: string,
    userMessage: string,
    chatHistory: DialogueMessage[],
    currentUserInput: string,
    username?: string,
    charName?: string,
):
private formatWorldBookEntries(
    entries: WorldBookEntry[],
    username?: string,
    charName?: string,
): string
private adjustChatHistoryByTurns(chatHistory: DialogueMessage[]): DialogueMessage[]
</file>

<file path="lib/core/regex-processor.ts">
import { RegexReplacementResult } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export interface RegexProcessorOptions {
  ownerId: string;
}
export class RegexProcessor
⋮----
private static handleEscapeSequences(pattern: string): string
static async processFullContext(
    fullContext: string,
    options: RegexProcessorOptions,
): Promise<RegexReplacementResult>
</file>

<file path="lib/core/world-book.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
export interface WorldBookJson {
  entries: Record<string, WorldBookEntry> | WorldBookEntry[];
}
export class WorldBookManager
⋮----
static getMatchingEntries(
    worldBook: WorldBookEntry[] | Record<string, WorldBookEntry> | undefined,
    message: string,
    chatHistory: DialogueMessage[],
    options: {
      contextWindow?: number;
    } = {},
): WorldBookEntry[]
static normalizeWorldBookEntries(worldBook: any): WorldBookEntry[]
static organizeEntriesByPosition(
    entries: WorldBookEntry[],
): Record<number, WorldBookEntry[]>
</file>

<file path="lib/data/agent-operation.ts">
import {
  readData,
  writeData,
  AGENT_CONVERSATIONS_FILE,
} from "@/lib/data/local-storage";
import {
  AgentConversation,
  AgentStep,
  AgentMessage,
  AgentTaskStatus,
  AgentCapability,
} from "@/lib/models/agent-model";
import { v4 as uuidv4 } from "uuid";
export class AgentConversationOperations
⋮----
static async createConversation(title: string): Promise<AgentConversation>
static async getConversationById(id: string): Promise<AgentConversation | null>
static async getAllConversations(): Promise<AgentConversation[]>
static async addMessage(
    conversationId: string,
    message: Omit<AgentMessage, "id" | "timestamp">,
): Promise<AgentMessage>
static async addStep(
    conversationId: string,
    step: Omit<AgentStep, "id" | "timestamp">,
): Promise<AgentStep>
static async updateStatus(conversationId: string, status: AgentTaskStatus): Promise<AgentConversation | null>
static async updateOutput(
    conversationId: string,
    output: { characterData?: any; worldbookData?: any; combinedData?: any },
): Promise<AgentConversation | null>
static async updateMetadata(
    conversationId: string,
    metadata: Partial<AgentConversation["metadata"]>,
): Promise<AgentConversation | null>
static async updateContext(
    conversationId: string,
    context: Partial<AgentConversation["context"]>,
): Promise<AgentConversation | null>
static async updateConversation(conversation: AgentConversation): Promise<AgentConversation>
static async clearCurrentSteps(conversationId: string): Promise<AgentConversation | null>
static async getConversationHistory(conversationId: string, limit?: number): Promise<AgentMessage[]>
static async getCurrentSteps(conversationId: string): Promise<AgentStep[]>
static async getStepByCapability(conversationId: string, capability: AgentCapability): Promise<AgentStep | null>
static async deleteConversation(id: string): Promise<boolean>
static async cleanupOldConversations(daysOld: number = 30): Promise<number>
static async getConversationStats(): Promise<
⋮----
export class AgentToolOperations
⋮----
static async recordToolUsage(
    conversationId: string,
    toolId: string,
    input: any,
    output: any,
    stepId: string,
    executionTime?: number,
): Promise<void>
static async getToolUsageStats(conversationId: string): Promise<
static async getAvailableTools(conversationId: string): Promise<string[]>
static async setAvailableTools(conversationId: string, toolIds: string[]): Promise<void>
static async clearToolHistory(conversationId: string): Promise<void>
static async getGlobalToolMetrics(): Promise<
</file>

<file path="lib/data/character-dialogue-operation.ts">
import { readData, writeData, CHARACTER_DIALOGUES_FILE } from "@/lib/data/local-storage";
import { DialogueNode, DialogueTree } from "@/lib/models/node-model";
import { v4 as uuidv4 } from "uuid";
import { ParsedResponse } from "@/lib/models/parsed-response";
export class LocalCharacterDialogueOperations
⋮----
static async createDialogueTree(characterId: string): Promise<DialogueTree>
static async getDialogueTreeById(dialogueId: string): Promise<DialogueTree | null>
static async addNodeToDialogueTree(
    dialogueId: string,
    parentNodeId: string,
    userInput: string,
    assistantResponse: string,
    fullResponse: string,
    parsedContent?: ParsedResponse,
    nodeId?: string,
): Promise<string>
static async updateDialogueTree(dialogueId: string, updatedDialogue: DialogueTree): Promise<boolean>
static async updateNodeInDialogueTree(
    dialogueId: string,
    nodeId: string,
    updates: Partial<DialogueNode>,
): Promise<DialogueTree | null>
static async switchBranch(dialogueId: string, nodeId: string): Promise<DialogueTree | null>
static async clearDialogueHistory(dialogueId: string): Promise<DialogueTree | null>
static async deleteDialogueTree(dialogueId: string): Promise<boolean>
static async deleteNode(dialogueId: string, nodeId: string): Promise<DialogueTree | null>
⋮----
const collectNodesToDelete = (currentNodeId: string) =>
⋮----
static async getDialoguePathToNode(dialogueId: string, nodeId: string): Promise<DialogueNode[]>
static async getChildNodes(dialogueId: string, parentNodeId: string): Promise<DialogueNode[]>
static async getAllDialoguesForCharacter(characterId: string): Promise<DialogueTree[]>
private static convertToDialogueTree(data: any): DialogueTree
static async getSystemMessage(characterId: string): Promise<string>
static async getLastNodeId(characterId: string): Promise<string>
static async nodeExists(characterId: string, nodeId: string): Promise<boolean>
</file>

<file path="lib/data/character-record-operation.ts">
import { readData, writeData, CHARACTERS_RECORD_FILE } from "@/lib/data/local-storage";
import { RawCharacterData } from "@/lib/models/rawdata-model";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
export interface CharacterRecord {
  id: string;
  data: RawCharacterData;
  imagePath: string;
  created_at: string;
  updated_at: string;
}
export class LocalCharacterRecordOperations
⋮----
static async createCharacter(characterId: string, rawCharacterData: RawCharacterData, imagePath: string): Promise<CharacterRecord>
static async getAllCharacters(): Promise<CharacterRecord[]>
static async getCharacterById(characterId: string): Promise<CharacterRecord>
static async updateCharacter(characterId: string, characterData: Partial<RawCharacterData>): Promise<CharacterRecord | null>
static async deleteCharacter(characterId: string): Promise<boolean>
</file>

<file path="lib/data/local-storage.ts">
function openDB(): Promise<IDBDatabase>
export async function readData(storeName: string): Promise<any[]>
export async function writeData(storeName: string, data: any[]): Promise<void>
export async function initializeDataFiles(): Promise<void>
export async function setBlob(key: string, blob: Blob): Promise<void>
export async function getBlob(key: string): Promise<Blob | null>
export async function deleteBlob(key: string): Promise<void>
export async function exportAllData(): Promise<Record<string, any>>
export async function importAllData(data: Record<string, any>): Promise<void>
async function blobToBase64(blob: Blob): Promise<string>
async function base64ToBlob(base64: string): Promise<Blob>
</file>

<file path="lib/data/preset-operation.ts">
import { readData, writeData, PRESET_FILE } from "@/lib/data/local-storage";
import { Preset, PresetPrompt } from "@/lib/models/preset-model";
export class PresetOperations
⋮----
static async getPresets(): Promise<Record<string, any>>
private static async savePresets(presets: Record<string, any>): Promise<void>
static async getAllPresets(): Promise<Preset[]>
static async getPreset(presetId: string): Promise<Preset | null>
static async createPreset(preset: Preset): Promise<string | null>
static async updatePreset(presetId: string, updates: Partial<Preset>): Promise<boolean>
static async deletePreset(presetId: string): Promise<boolean>
static async importPreset(jsonData: string | object, customName?: string): Promise<string | null>
static async getOrderedPrompts(presetId: string): Promise<PresetPrompt[]>
static async getPromptsOrderedForDisplay(presetId: string): Promise<PresetPrompt[]>
static async updateCharacterPrompt(
    presetId: string,
    characterId: string | number,
    promptData: {
      identifier: string;
      name: string;
      content?: string;
      enabled?: boolean;
      position?: number;
      [key: string]: any;
    },
): Promise<boolean>
</file>

<file path="lib/data/regex-script-operation.ts">
import { readData, writeData, REGEX_SCRIPTS_FILE } from "@/lib/data/local-storage";
import { RegexScript } from "@/lib/models/regex-script-model";
export interface RegexScriptSettings {
  enabled: boolean;
  applyToPrompt: boolean;
  applyToResponse: boolean;
  metadata?: any;
}
⋮----
export class RegexScriptOperations
⋮----
private static async getRegexScriptStore(): Promise<Record<string, any>>
private static async saveRegexScriptStore(store: Record<string, any>): Promise<boolean>
static async getRegexScripts(ownerId: string): Promise<Record<string, RegexScript> | null>
static async updateRegexScript(
    ownerId: string,
    scriptId: string,
    updates: Partial<RegexScript>,
): Promise<boolean>
static async addRegexScript(
    ownerId: string,
    script: RegexScript,
): Promise<string | null>
static async deleteRegexScript(ownerId: string, scriptId: string): Promise<boolean>
private static async updateOwnerScripts(ownerId: string, scripts: Record<string, RegexScript>): Promise<boolean>
static async updateRegexScripts(
    ownerId: string,
    regexScripts: Record<string, RegexScript> | RegexScript[],
): Promise<boolean>
⋮----
const processScript = (script: RegexScript): RegexScript =>
⋮----
static async getRegexScriptSettings(ownerId: string): Promise<RegexScriptSettings>
static async updateRegexScriptSettings(
    ownerId: string,
    updates: Partial<RegexScriptSettings>,
): Promise<RegexScriptSettings>
static async getAllScriptsForProcessing(
    ownerId: string,
): Promise<RegexScript[]>
</file>

<file path="lib/data/world-book-operation.ts">
import { readData, writeData, WORLD_BOOK_FILE } from "@/lib/data/local-storage";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface WorldBookSettings {
  enabled: boolean;
  maxEntries: number;
  contextWindow: number;
  metadata?: any;
}
⋮----
export class WorldBookOperations
⋮----
static async getWorldBooks(): Promise<Record<string, any>>
private static async saveWorldBooks(worldBooks: Record<string, any>): Promise<void>
static async getWorldBook(characterId: string): Promise<Record<string, WorldBookEntry> | null>
static async updateWorldBook(
    characterId: string,
    worldBook: Record<string, WorldBookEntry> | WorldBookEntry[],
): Promise<boolean>
⋮----
const processEntry = (entry: WorldBookEntry): WorldBookEntry =>
⋮----
static async addWorldBookEntry(
    characterId: string,
    entry: WorldBookEntry,
): Promise<string | null>
static async updateWorldBookEntry(
    characterId: string,
    entryId: string,
    updates: Partial<WorldBookEntry>,
): Promise<boolean>
static async deleteWorldBookEntry(characterId: string, entryId: string): Promise<boolean>
static async getWorldBookSettings(characterId: string): Promise<WorldBookSettings>
static async updateWorldBookSettings(
    characterId: string,
    updates: Partial<WorldBookSettings>,
): Promise<WorldBookSettings>
</file>

<file path="lib/models/agent-model.ts">
export enum AgentCapability {
  SEARCH = "search",
  PLAN = "plan",
  OUTPUT = "output",
  ASK = "ask",
  VALIDATE = "validate",
  REFINE = "refine",
  ANALYZE = "analyze"
}
export enum AgentTaskStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed",
  FAILED = "failed",
  WAITING_FOR_USER = "waiting_for_user"
}
export interface AgentStep {
  id: string;
  capability: AgentCapability;
  input: any;
  output: any;
  reasoning?: string;
  status: AgentTaskStatus;
  executionOrder: number;
  timestamp: string;
  userQuestion?: string;
  userResponse?: any;
  isWaitingForUser?: boolean;
}
export interface AgentMessage {
  id: string;
  role: "user" | "agent" | "system";
  content: string;
  messageType: "text" | "task_request" | "task_result" | "step_update" | "user_question" | "user_response";
  metadata?: {
    capability?: AgentCapability;
    reasoning?: string;
    attachments?: any[];
    questionId?: string;
    stepId?: string;
  };
  timestamp: string;
}
export interface AgentTool {
  id: string;
  name: string;
  description: string;
  capabilities: AgentCapability[];
  inputSchema: any;
  outputSchema: any;
  execute: (input: any, context: AgentExecutionContext) => Promise<any>;
}
export interface AgentConversation {
  id: string;
  title: string;
  status: AgentTaskStatus;
  messages: AgentMessage[];
  currentSteps: AgentStep[];
  availableTools: string[];
  output?: {
    characterData?: any;
    worldbookData?: any;
    combinedData?: any;
  };
  metadata: {
    iterations: number;
    totalTokens?: number;
    executionTime?: number;
    modelUsed?: string;
    temperature?: number;
    toolsUsed?: string[];
  };
  context: {
    userPreferences?: any;
    referenceData?: any;
    constraints?: any;
    pendingQuestions?: Array<{
      id: string;
      question: string;
      stepId: string;
      timestamp: string;
    }>;
    toolUsageHistory?: Array<{
      toolId: string;
      stepId: string;
      input: any;
      output: any;
      timestamp: string;
      executionTime: number;
    }>;
  };
  created_at: string;
  updated_at: string;
}
export interface AgentExecutionContext {
  conversationId: string;
  currentStepIndex: number;
  workingMemory: Record<string, any>;
  availableTools: AgentTool[];
  constraints: {
    maxTokens?: number;
    timeoutMs?: number;
    maxSteps?: number;
  };
  llmConfig?: {
    modelName: string;
    apiKey: string;
    baseUrl?: string;
    llmType: "openai" | "ollama";
    temperature?: number;
  };
}
</file>

<file path="lib/models/character-dialogue-model.ts">
import { ParsedResponse } from "@/lib/models/parsed-response";
import { PromptType } from "@/lib/models/character-prompts-model";
export interface DialogueMessage {
  role: "user" | "assistant" | "system" | "sample";
  content: string;
  parsedContent?: ParsedResponse;
  id: number;
}
export interface DialogueOptions {
  modelName: string;
  apiKey: string;
  baseUrl: string;
  llmType: "openai" | "ollama";
  temperature?: number;
  maxTokens?: number;
  streaming?: boolean;
  language?: "zh" | "en";
  promptType?: PromptType;
  contextWindow?: number;
}
</file>

<file path="lib/models/character-model.ts">
export interface CharacterData {
  name: string;
  description: string;
  personality: string;
  first_mes: string;
  scenario: string;
  mes_example: string;
  creatorcomment: string;
  avatar: string;
  creator_notes?: string;
  imagePath?: string;
  alternate_greetings:string[];
}
</file>

<file path="lib/models/character-prompts-model.ts">
export interface CharacterPromptParams {
  username?: string;
  name: string;
  number: number;
  prefixPrompt?: string;
  chainOfThoughtPrompt?: string;
  suffixPrompt?: string;
  language?: "zh" | "en";
  systemPrompt?: string;
  storyHistory?: string;
  conversationHistory?: string;
  userInput?: string;
  sampleStatus?: string;
}
export enum PromptType {
  COMPANION = "companion",
  NSFW = "nsfw",
  EXPLICIT = "explicit",
  CUSTOM = "custom"
}
</file>

<file path="lib/models/node-model.ts">
import { ParsedResponse } from "@/lib/models/parsed-response";
export class DialogueNode
⋮----
constructor(
    node_id: string,
    parent_node_id: string,
    user_input: string,
    assistant_response: string,
    full_response: string,
    parsed_content?: ParsedResponse,
    created_at: string = new Date().toISOString(),
)
⋮----
export class DialogueTree
⋮----
constructor(
    id: string,
    character_id: string,
    nodes: DialogueNode[] = [],
    current_node_id: string = "root",
    created_at: string = new Date().toISOString(),
    updated_at: string = new Date().toISOString(),
)
</file>

<file path="lib/models/parsed-response.ts">
export interface ParsedResponse {
    regexResult?: string;
    nextPrompts?: string[];
    compressedContent?: string;
  }
</file>

<file path="lib/models/preset-model.ts">
export interface PresetPrompt {
  identifier: string;
  name: string;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  forbid_overrides?: boolean;
  group_id?: string | number;
  position?: number;
}
export interface Preset {
  id?: string;
  name: string;
  enabled?: boolean;
  prompts: PresetPrompt[];
  created_at?: string;
  updated_at?: string;
}
</file>

<file path="lib/models/rawdata-model.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface RawCharacterData {
  id: any;
  name: string;
  description: string;
  personality: string;
  first_mes: string;
  scenario: string;
  mes_example: string;
  creatorcomment: string;
  avatar: string;
  sample_status: string;
  data:{
    name: string;
    description: string;
    personality: string;
    first_mes: string;
    scenario: string;
    mes_example: string;
    creator_notes: string;
    system_prompt: string;
    post_history_instructions: string;
    tags: string[];
    creator: string;
    character_version: string;
    alternate_greetings: string[];
    character_book:{
      entries: {
        comment: string;
        content: string;
        disable?: boolean;
        position?: number;
        constant?: boolean;
        key?: string[];
        order?: number;
        depth?: number;
      }[] | Record<string, WorldBookEntry>;
    }
  },
}
</file>

<file path="lib/models/regex-script-model.ts">
export interface RegexScript {
  scriptKey: string;
  id?: string;
  scriptName: string;
  findRegex: string;
  replaceString?: string | null;
  trimStrings: string[];
  placement: number[];
  disabled?: boolean;
  extensions?: {
    imported?: boolean;
    importedAt?: number;
    globalSource?: boolean;
    globalSourceId?: string;
    globalSourceName?: string;
  };
}
export enum RegexScriptOwnerType {
  CHARACTER = "character",
  GLOBAL = "global",
  CONVERSATION = "conversation"
}
export interface RegexReplacementResult {
  originalText: string;
  replacedText: string;
  appliedScripts: string[];
  success: boolean;
}
export interface RegexScriptSettings {
  enabled: boolean;
  applyToPrompt: boolean;
  applyToResponse: boolean;
  metadata?: any;
}
</file>

<file path="lib/models/world-book-model.ts">
interface WorldBookEntryExtensions {
  position?: number;
  [key: string]: any;
}
export interface WorldBookEntry {
  entry_id?: string;
  id?: number;
  content: string;
  keys: string[];
  secondary_keys?: string[];
  selective: boolean;
  constant: boolean;
  position: string | number;
  insertion_order?: number;
  enabled?: boolean;
  use_regex?: boolean;
  depth?: number;
  comment?: string;
  tokens?: number;
  extensions?: WorldBookEntryExtensions;
}
</file>

<file path="lib/nodeflow/ContextNode/ContextNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { ContextNodeTools } from "./ContextNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class ContextNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/ContextNode/ContextNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
export class DialogueStory
⋮----
constructor(language: string, userInput: string[] | null = null, responses: string[] | null = null)
getStory(startIndex: number | null = null, endIndex: number | null = null): string
⋮----
export class ContextNodeTools extends NodeTool
⋮----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async assembleChatHistory(
    userMessage: string,
    characterId: string,
    memoryLength: number = 10,
): Promise<
static async loadCharacterHistory(
    characterId: string,
): Promise<
static formatChatHistory(
    historyData: {
      systemMessage: string;
      recentDialogue: DialogueStory;
      historyDialogue: DialogueStory;
    },
    memoryLength: number,
): string
static getRecentHistory(dialogue: DialogueStory, memLen: number): string
static getCompressedHistory(dialogue: DialogueStory, memLen: number): string
</file>

<file path="lib/nodeflow/LLMNode/LLMNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { LLMNodeTools } from "./LLMNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class LLMNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/LLMNode/LLMNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { RunnablePassthrough } from "@langchain/core/runnables";
export interface LLMConfig {
  modelName: string;
  apiKey: string;
  baseUrl?: string;
  llmType: "openai" | "ollama";
  temperature?: number;
  maxTokens?:number;
  maxRetries?: number,
  topP?: number,
  frequencyPenalty?: number,
  presencePenalty?: number,
  topK?: number,
  repeatPenalty?: number,
  streaming?: boolean;
  streamUsage?: boolean;
  language?: "zh" | "en";
}
export class LLMNodeTools extends NodeTool
⋮----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async invokeLLM(
    systemMessage: string,
    userMessage: string,
    config: LLMConfig,
): Promise<string>
private static createLLM(config: LLMConfig): ChatOpenAI | ChatOllama
private static createDialogueChain(llm: ChatOpenAI | ChatOllama): any
</file>

<file path="lib/nodeflow/OutputNode/OutputNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
export class OutputNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/PresetNode/PresetNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { PresetNodeTools } from "./PresetNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class PresetNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/PresetNode/PresetNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { PresetOperations } from "@/lib/data/preset-operation";
import { PresetAssembler } from "@/lib/core/preset-assembler";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
export class PresetNodeTools extends NodeTool
⋮----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async buildPromptFramework(
    characterId: string,
    language: "zh" | "en" = "zh",
    username?: string,
    charName?: string,
    number?: number,
    fastModel: boolean = false,
): Promise<
private static enrichPromptsWithCharacterInfo(
    prompts: any[],
    character: Character,
): any[]
</file>

<file path="lib/nodeflow/RegexNode/RegexNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { RegexNodeTools } from "./RegexNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class RegexNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/RegexNode/RegexNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { RegexProcessor } from "@/lib/core/regex-processor";
export class RegexNodeTools extends NodeTool
⋮----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async processRegex(
    response: string,
    characterId: string,
): Promise<
</file>

<file path="lib/nodeflow/UserInputNode/UserInputNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
export class UserInputNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async beforeExecute(input: NodeInput): Promise<void>
protected async afterExecute(output: NodeOutput): Promise<void>
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/WorldBookNode/WorldBookNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { WorldBookNodeTools } from "./WorldBookNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class WorldBookNode extends NodeBase
⋮----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/WorldBookNode/WorldBookNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { Character } from "@/lib/core/character";
import { PromptAssembler } from "@/lib/core/prompt-assembler";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
export class WorldBookNodeTools extends NodeTool
⋮----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async assemblePromptWithWorldBook(
    characterId: string,
    baseSystemMessage: string,
    userMessage: string,
    currentUserInput: string,
    language: "zh" | "en" = "zh",
    contextWindow: number = 5,
    username?: string,
    charName?: string,
): Promise<
private static async getChatHistory(characterId: string, contextWindow: number = 5): Promise<DialogueMessage[]>
</file>

<file path="lib/nodeflow/NodeBase.ts">
import { NodeConfig, NodeInput, NodeOutput, NodeExecutionStatus, NodeExecutionResult, NodeCategory } from "@/lib/nodeflow/types";
import { NodeContext } from "@/lib/nodeflow/NodeContext";
import { NodeTool, NodeToolRegistry } from "@/lib/nodeflow/NodeTool";
export abstract class NodeBase
⋮----
constructor(config: NodeConfig)
protected getInitParams(): string[]
protected getInputFields(): string[]
protected getOutputFields(): string[]
protected getConfigValue<T>(key: string, defaultValue?: T): T | undefined
protected getState<T>(key: string, defaultValue?: T): T | undefined
protected setState<T>(key: string, value: T): void
protected abstract getDefaultCategory(): NodeCategory;
getCategory(): NodeCategory
isEntryNode(): boolean
isExitNode(): boolean
isMiddleNode(): boolean
protected initializeTools(): void
protected async executeTool(methodName: string, ...params: any[]): Promise<any>
getId(): string
getName(): string
getNext(): string[]
protected async resolveInput(context: NodeContext): Promise<NodeInput>
protected async publishOutput(output: NodeOutput, context: NodeContext): Promise<void>
⋮----
const storeData = (key: string, value: any) =>
⋮----
async execute(context: NodeContext): Promise<NodeExecutionResult>
protected async beforeExecute(input: NodeInput): Promise<void>
protected async afterExecute(output: NodeOutput): Promise<void>
protected async _call(input: NodeInput): Promise<NodeOutput>
getStatus(): Record<string, any>
toJSON(): NodeConfig
</file>

<file path="lib/nodeflow/NodeContext.ts">
export class NodeContext
⋮----
constructor(inputData?: Record<string, any>, cacheData?: Record<string, any>, outputData?: Record<string, any>)
setCache(key: string, value: any): void
getCache(key: string): any
hasCache(key: string): boolean
setInput(key: string, value: any): void
getInput(key: string): any
hasInput(key: string): boolean
setOutput(key: string, value: any): void
getOutput(key: string): any
hasOutput(key: string): boolean
clearOutput(): void
clearInput(): void
clearCache(): void
clear(): void
toJSON(): Record<string, any>
static fromJSON(json: Record<string, any>): NodeContext
</file>

<file path="lib/nodeflow/NodeTool.ts">
export abstract class NodeTool
⋮----
static getToolType(): string
static getVersion(): string
protected static logExecution(methodName: string, params?: any): void
protected static handleError(error: Error, methodName: string): never
static getAvailableMethods(): string[]
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
⋮----
export interface ToolMetadata {
  type: string;
  version: string;
  methods: string[];
}
export interface ToolMethodDescriptor {
  name: string;
  description: string;
  parameters: ToolParameterDescriptor[];
  returnType: string;
}
export interface ToolParameterDescriptor {
  name: string;
  type: string;
  required: boolean;
  description?: string;
  defaultValue?: any;
}
export function ToolMethod(description: string, parameters: ToolParameterDescriptor[] = [])
export class NodeToolRegistry
⋮----
static register(toolClass: typeof NodeTool): void
static get(toolType: string): typeof NodeTool | undefined
static isRegistered(toolClass: typeof NodeTool): boolean
static getRegisteredTypes(): string[]
</file>

<file path="lib/nodeflow/types.ts">
export enum NodeCategory {
  ENTRY = "entry",
  MIDDLE = "middle",
  EXIT = "exit"
}
export interface NodeConfig {
  id: string;
  name: string;
  category: NodeCategory;
  next?: string[];
  initParams?: string[];
  inputFields?: string[];
  outputFields?: string[];
  inputMapping?: Record<string, string>;
}
export type NodeInput = Record<string, any>;
export type NodeOutput = Record<string, any>;
export enum NodeExecutionStatus {
  PENDING = "pending",
  RUNNING = "running",
  COMPLETED = "completed",
  FAILED = "failed",
  SKIPPED = "skipped"
}
export interface NodeExecutionResult {
  nodeId: string;
  status: NodeExecutionStatus;
  input: NodeInput;
  output?: NodeOutput;
  error?: Error;
  startTime: Date;
  endTime?: Date;
}
export interface WorkflowConfig {
  id: string;
  name: string;
  nodes: NodeConfig[];
}
export interface WorkflowExecutionResult {
  workflowId: string;
  status: NodeExecutionStatus;
  results: NodeExecutionResult[];
  outputData?: Record<string, any>;
  startTime: Date;
  endTime?: Date;
}
export interface NodeRegistryEntry {
  nodeClass: any;
}
export type NodeRegistry = Record<string, NodeRegistryEntry>;
</file>

<file path="lib/nodeflow/WorkflowEngine.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeContext } from "@/lib/nodeflow/NodeContext";
import {
  NodeInput,
  NodeOutput,
  NodeRegistry,
  WorkflowConfig,
  NodeExecutionStatus,
  WorkflowExecutionResult,
} from "@/lib/nodeflow/types";
export class WorkflowEngine
⋮----
constructor(
    config: WorkflowConfig,
    registry: NodeRegistry,
    context: NodeContext,
)
private initializeNodes(context: NodeContext): void
private getEntryNodes(): NodeBase[]
private getNextNodes(nodeId: string): NodeBase[]
private async executeNode(
    node: NodeBase,
    context: NodeContext,
): Promise<NodeOutput>
private async executeParallel(
    nodes: NodeBase[],
    context: NodeContext,
): Promise<NodeOutput[]>
async execute(
    initialWorkflowInput: NodeInput,
    context?: NodeContext,
): Promise<WorkflowExecutionResult>
async *executeAsync(
    initialWorkflowInput: NodeInput,
    context?: NodeContext,
): AsyncGenerator<NodeOutput[], WorkflowExecutionResult, undefined>
validate(): boolean
private detectCycles(): void
⋮----
const dfs = (nodeId: string): void =>
</file>

<file path="lib/prompts/character-prompts.ts">
export function getCharacterCompressorPromptZh(userInput: string, story: string): string
export function getCharacterCompressorPromptEn(userInput: string, story: string): string
export function getStatusPromptZh(info: string)
export function getStatusPromptEn(info: string)
</file>

<file path="lib/prompts/preset-prompts.ts">

</file>

<file path="lib/workflow/examples/DialogueWorkflow.ts">
import { BaseWorkflow, WorkflowConfig } from "@/lib/workflow/BaseWorkflow";
import { NodeCategory } from "@/lib/nodeflow/types";
import { UserInputNode } from "@/lib/nodeflow/UserInputNode/UserInputNode";
import { ContextNode } from "@/lib/nodeflow/ContextNode/ContextNode";
import { WorldBookNode } from "@/lib/nodeflow/WorldBookNode/WorldBookNode";
import { PresetNode } from "@/lib/nodeflow/PresetNode/PresetNode";
import { LLMNode } from "@/lib/nodeflow/LLMNode/LLMNode";
import { RegexNode } from "@/lib/nodeflow/RegexNode/RegexNode";
import { OutputNode } from "@/lib/nodeflow/OutputNode/OutputNode";
import { PromptType } from "@/lib/models/character-prompts-model";
export interface DialogueWorkflowParams {
  characterId: string;
  userInput: string;
  number?: number;
  promptType?: PromptType;
  language?: "zh" | "en";
  username?: string;
  modelName: string;
  apiKey: string;
  baseUrl?: string;
  llmType?: "openai" | "ollama";
  temperature?: number;
  maxTokens?: number;
  maxRetries?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  topK?: number;
  repeatPenalty?: number;
  streaming?: boolean;
  streamUsage?: boolean;
  fastModel?: boolean;
}
export class DialogueWorkflow extends BaseWorkflow
⋮----
protected getNodeRegistry()
protected getWorkflowConfig(): WorkflowConfig
</file>

<file path="lib/workflow/BaseWorkflow.ts">
import { NodeContext } from "../nodeflow/NodeContext";
import { WorkflowEngine } from "../nodeflow/WorkflowEngine";
import { NodeCategory } from "../nodeflow/types";
export interface WorkflowConfig {
  id: string;
  name: string;
  nodes: WorkflowNode[];
}
export interface WorkflowNode {
  id: string;
  name: string;
  category: NodeCategory;
  next: string[];
  initParams: string[];
  inputFields: string[];
  outputFields: string[];
  inputMapping?: Record<string, string>;
}
export interface WorkflowParams {
  [key: string]: any;
}
export class ValidationError extends Error
⋮----
constructor(message: string)
⋮----
export abstract class BaseWorkflow
⋮----
constructor()
protected abstract getNodeRegistry():
protected abstract getWorkflowConfig(): WorkflowConfig;
protected validateWorkflowConfig(): void
private validateEntryNode(node: WorkflowNode): void
private validateInputFields(node: WorkflowNode, availableOutputs: Set<string>): void
private validateNodeConnections(node: WorkflowNode, index: number, nodes: WorkflowNode[]): void
private validateNodeCategories(nodes: WorkflowNode[]): void
public async execute(params: WorkflowParams): Promise<any>
public getContext(): NodeContext
public resetContext(): void
</file>

<file path="utils/character-parser.ts">
import extract from "png-chunks-extract";
import encode from "png-chunks-encode";
import PNGtext from "png-chunk-text";
const encodeBase64 = (str: string): string =>
const decodeBase64 = (b64: string): string =>
export const writeCharacterToPng = async (file: File, data: string): Promise<Blob> =>
export const readCharacterFromPng = async (file: File): Promise<string> =>
export const parseCharacterCard = async (file: File): Promise<string> =>
</file>

<file path="utils/google-analytics.ts">
interface Window {
    gtag: (...args: any[]) => void;
    dataLayer: any[];
  }
⋮----
export const initGA = () =>
export const pageview = (url: string) =>
export const gtagEvent = (eventName: string, params: Record<string, any>) =>
export const trackButtonClick = (buttonId: string, buttonName: string) =>
export const trackFormSubmit = (formId: string, formName: string) =>
</file>

<file path="utils/response-parser.ts">
export function parseEvent(story: string): string
</file>

<file path="utils/version-compare.ts">
export function isUpdateAvailable(current: string, latest: string): boolean
⋮----
// Ensure both arrays have the same length by padding with zeros
⋮----
// Compare each part
⋮----
/**
 * Fetch the latest release information from GitHub API
 * @returns Promise<{version: string, url: string} | null>
 */
export async function fetchLatestRelease(): Promise<
</file>

<file path=".env.example">
# Google OAuth Configuration
# Copy this file to .env.local and fill in your actual values
GOOGLE_OAUTH_CLIENT_ID=your_google_oauth_client_id_here
GOOGLE_OAUTH_CLIENT_SECRET=your_google_oauth_client_secret_here
GOOGLE_OAUTH_REDIRECT_URI=https://www.narratium.org/oauth2callback
NEXT_PUBLIC_API_KEY=your_api_key
NEXT_PUBLIC_API_URL=your_base_url
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions
# testing
/coverage
show.html

# next.js
/.next/
/out/
/public/characters

# production
/build
!/data
/data/*
# misc
.DS_Store
*.pem
action.txt

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# resources
/resources

Narratium.dmg
Narratium.msi
narratium.deb
</file>

<file path="docker-compose.yml">
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_BASE_URL=http://localhost:3000
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
</file>

<file path="Dockerfile">
FROM node:20.12-alpine AS builder

RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

COPY . .
RUN pnpm build

FROM node:20.12-alpine AS runner

RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app

COPY --from=builder /app/out ./out

RUN pnpm add serve

EXPOSE 3000

CMD ["npx", "serve", "-s", "out", "-l", "3000"]
</file>

<file path="eslint.config.mjs">

</file>

<file path="LICENSE">
# Project License

This project is composed of two distinct parts: source code and user-contributed content.

## 1. Code License (MIT)

All source code in this repository is licensed under the MIT License:

---

MIT License

Copyright (c) [2025] [Narratium/Narratium.ai]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights  
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  
copies of the Software, and to permit persons to whom the Software is  
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  
SOFTWARE.

---

## 2. Community-Contributed Content License (CC BY-NC-SA 4.0)

All community-contributed content — including but not limited to character cards, story elements, names, descriptions, and visual assets — is licensed under the **Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)** license.

You are free to:

- Share — copy and redistribute the material in any medium or format  
- Adapt — remix, transform, and build upon the material  

**Under the following terms:**

- **Attribution** — You must give appropriate credit to the original creators.  
- **NonCommercial** — You may not use the material for commercial purposes.  
- **ShareAlike** — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.

For full details of the CC BY-NC-SA 4.0 license, see:  
[https://creativecommons.org/licenses/by-nc-sa/4.0/](https://creativecommons.org/licenses/by-nc-sa/4.0/)

---

## 3. Additional Restrictions on Generated Content and Brand Elements

**IMPORTANT NOTICE:** While the source code is licensed under MIT, the following restrictions apply:

### Generated Content Ownership and Restrictions
All content generated by this software — including but not limited to:
- Generated text, stories, dialogues
- Generated images, artwork, visual content
- Generated character cards and character data
- Any other AI-generated or software-generated content

**Ownership**: Generated content is jointly owned by **Narratium** and the **actual creator/user who performed the creative work**. Fork developers or redistributors of the code do NOT acquire ownership rights to content created by others using their fork.

**Commercial Use**: Generated content **IS STRICTLY PROHIBITED FROM COMMERCIAL USE** without explicit written permission from both Narratium and the original content creator.

### Brand Protection
The following Narratium brand elements are proprietary and **NOT COVERED BY THE MIT LICENSE**:
- The "Narratium" name and trademark
- Project logos, branding, and visual identity
- UI design elements, styles, and layouts specific to Narratium
- Any fork or derivative work that incorporates these elements

**Commercial use of the above brand elements and generated content is strictly forbidden without explicit written permission from Narratium.**

### Permitted Use
You may:
- Use the code for personal, educational, or non-commercial purposes
- Create derivative works for non-commercial use (with proper attribution)
- Study and learn from the codebase

You may NOT:
- Use any generated content for commercial purposes (unless you are the original creator AND have Narratium's permission)
- Use Narratium branding in commercial projects
- Create commercial services using this codebase without removing all Narratium branding
- Claim ownership of content created by other users of your fork

---

## Summary

- ✅ **Code**: MIT License — open for commercial and non-commercial use with attribution
- 🔒 **Community Content**: CC BY-NC-SA 4.0 — non-commercial use only, with attribution and same-license sharing required
- 🚫 **Generated Content**: No commercial use permitted, belongs to Narratium
- 🚫 **Brand Elements**: Proprietary to Narratium, commercial use prohibited

Please review all license terms carefully before using, contributing to, or distributing this project.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";
</file>

<file path="package.json">
{
  "name": "Narratium",
  "version": "0.1.0",
  "private": true,
  "main": "electron/main.js",
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "lint": "next lint",
    "preview": "serve -s out",
    "test": "vitest",
    "pake-mac": "pake out/index.html --name Narratium --use-local-file --icon ./public/icon.icns --multi-arch",
    "pake-win": "pake out/index.html --name Narratium --use-local-file --icon ./public/icon.ico",
    "pake-linux": "pake out/index.html --name narratium --use-local-file --icon ./public/icon.png"
  },
  "dependencies": {
    "@langchain/core": "^0.3.44",
    "@langchain/ollama": "^0.2.0",
    "@langchain/openai": "^0.5.5",
    "@supabase/supabase-js": "^2.50.0",
    "@types/react-color": "^3.0.13",
    "@vercel/analytics": "^1.5.0",
    "better-sqlite3": "^11.9.1",
    "dotenv": "^16.5.0",
    "elkjs": "^0.10.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "framer-motion": "^12.6.3",
    "gsap": "^3.12.7",
    "langchain": "^0.3.24",
    "lucide-react": "^0.514.0",
    "marked": "^15.0.12",
    "next": "15.2.4",
    "png-chunk-text": "^1.0.0",
    "png-chunks-encode": "^1.0.0",
    "png-chunks-extract": "^1.0.0",
    "react": "^19.0.0",
    "react-color": "^2.19.3",
    "react-dom": "^19.0.0",
    "react-hot-toast": "^2.5.2",
    "react-markdown": "^10.1.0",
    "react-parallax-tilt": "^1.7.297",
    "reactflow": "^11.11.4",
    "uuid": "^11.1.0",
    "zod": "^3.25.67",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@next/eslint-plugin-next": "^15.3.1",
    "@tailwindcss/postcss": "^4",
    "@types/better-sqlite3": "^7.6.13",
    "@types/node": "^20",
    "@types/png-chunk-text": "^1.0.3",
    "@types/png-chunks-encode": "^1.0.2",
    "@types/png-chunks-extract": "^1.0.2",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@typescript-eslint/eslint-plugin": "^8.31.0",
    "@typescript-eslint/parser": "^8.31.0",
    "@vitest/expect": "^3.2.2",
    "concurrently": "^9.1.2",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^4",
    "typescript": "^5",
    "vitest": "^3.2.2"
  }
}
</file>

<file path="postcss.config.mjs">

</file>

<file path="README_ZH.md">
<h1 style="border-bottom: none" align="center">
  <a href="https://narratium.org/">Narratium.ai</a>
  <br />
  <p>创建、游玩和与AI角色扮演</p>
</h1>

<div align="center">
  <blockquote>
    <em><strong>世界广阔无垠，让想象力引领前行，但人心永远不可直视</strong></em><br>
    <em><strong>The world is vast, let imagination lead, but human hearts remain forever inscrutable</strong></em>
  </blockquote>
</div>

<br>

![Narratium.ai](/public/banner.png)

<p align="center">
  <em>一个开源的AI角色平台，用于构建、定制和与虚拟角色聊天</em>
  <br>
  <em>为构建互动世界的作家、开发者和故事讲述者而设计</em>
</p>

<div align="center">
  <a href="https://narratium.org">🔗 Live Demo</a> &nbsp;|&nbsp;
  <a href="https://deepwiki.com/Narratium/Narratium.ai/">📖 DeepWiki Docs</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/stargazers">⭐ Star Us</a> &nbsp;|&nbsp;
  <a href="https://discord.gg/PP7EpSzDfU">💬 Discord Community</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/releases">💾 Download</a> &nbsp;|&nbsp;
  <a href="./README_ZH.md">🇨🇳 中文文档</a>
</div>

<br>

<div align="center">

![GitHub stars](https://img.shields.io/github/stars/Narratium/Narratium.ai?style=social)
![GitHub forks](https://img.shields.io/github/forks/Narratium/Narratium.ai?style=social)
![GitHub commits](https://img.shields.io/github/commit-activity/m/Narratium/Narratium.ai)
![GitHub Downloads](https://img.shields.io/github/downloads/Narratium/Narratium.ai/total)

</div>

<div align="center">
  <em><strong>角色、世界和对话 — 在Narratium中完美统一</strong></em>
</div>

<br>

<img src="./assets/demo_show.gif" style="width: 100%"/>

## 开始使用并关注我们

<div align="center">
  <strong>给我们星标，您将及时收到GitHub的所有发布通知！</strong>
</div>

<br>

<img src="./assets/welcome_star.gif" style="width: 100%"/>

| 什么是Narratium |
| :---------------- |

[Narratium.ai](https://narratium.org/) 是一个用于创建AI角色、沉浸式世界和动态对话的开源平台。它是您构建个性化角色扮演冒险的创意工作室 — 从情感旅程到史诗传奇。

| 快速开始 |
| :---------- |

如需详细的安装和设置说明，请参阅我们的[快速开始指南](./docs/GETTING_STARTED.md)

如需详细的 Vercel 部署说明，请参阅 [Vercel 部署指南](./docs/VERCEL_DEPLOYMENT.md)。

如需客户端下载版本，请访问 [Mac、Windows、Linux 下载页面](https://github.com/Narratium/Narratium.ai/releases)

| 功能特性 |
| :------- |

- **沉浸式冒险模式**: 创建个性化世界并做出重要的决策。
- **可视化记忆管理**: 基于React Flow的会话追踪和分支。
- **角色卡片与背景**: 兼容SillyTavern卡片，在一处管理所有内容。

| Narratium与其他AI角色扮演平台对比 |
| :---------------------------------------- |

<table style="width: 100%;">
  <tr>
    <th align="center">功能</th>
    <th align="center">Narratium.ai</th>
    <th align="center">SillyTavern</th>
    <th align="center">AI Dungeon</th>
  </tr>
  <tr>
    <td><strong>开源</strong></td>
    <td align="center">✅</td>
    <td align="center">✅</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>新手友好</strong></td>
    <td align="center">✅</td>
    <td align="center">❌ (复杂设置)</td>
    <td align="center">✅ (但流程有限)</td>
  </tr>
  <tr>
    <td><strong>角色记忆与追踪</strong></td>
    <td align="center">✅</td>
    <td align="center">⚠️ (基于插件)</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>世界书支持</strong></td>
    <td align="center">✅</td>
    <td align="center">⚠️ (通过扩展)</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>长期对话支持</strong></td>
    <td align="center">✅</td>
    <td align="center">✅</td>
    <td align="center">❌ (上下文有限)</td>
  </tr>
  <tr>
    <td><strong>离线/本地部署</strong></td>
    <td align="center">✅</td>
    <td align="center">✅</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>可视化界面/UI精美</strong></td>
    <td align="center">✅</td>
    <td align="center">❌ (极简)</td>
    <td align="center">✅</td>
  </tr>
  <tr>
    <td><strong>无限分支故事情节</strong></td>
    <td align="center">✅</td>
    <td align="center">⚠️ (需要手动努力)</td>
    <td align="center">✅ (但不稳定)</td>
  </tr>
</table>

| 许可证概览 |
| :--------------- |

本项目由两个具有独立许可证的不同部分组成：

- ✅ 代码: MIT许可证 — 开放用于商业和非商业用途，需要署名。
- 🔒 内容: CC BY-NC-SA 4.0 — 仅限非商业用途，需要署名和相同许可证共享。

> 有关完整许可证详情，请参阅 [LICENSE](./LICENSE)。

| 联系与支持 |
| :---------------- |

* 如果你喜欢这个项目，我们非常欢迎你加入
* If you like this project, we warmly welcome you to join us
[Discord社区](https://discord.gg/PP7EpSzDfU)

| 代码贡献者 |
| :--------------- |

[![Contributors](https://contrib.rocks/image?repo=Narratium/Narratium.ai)](https://github.com/Narratium/Narratium.ai/graphs/contributors)

| 其他 |
| :----- |

感谢所有官方网站测试API赞助商

| 星标增长 |
| :---------- |

[![Stargazers over time](https://starchart.cc/Narratium/Narratium.ai.svg?variant=adaptive)](https://starchart.cc/Narratium/Narratium.ai)
</file>

<file path="README.md">
<h1 style="border-bottom: none" align="center">
  <a href=https://narratium.org/">Narratium.ai</a>
  <br />
  <p>Create, Play, and Roleplay with AI</p>
</h1>

<div align="center">
  <blockquote>
    <em><strong>The world is vast, let imagination lead, but human hearts remain forever inscrutable</strong></em><br>
    <em><strong>世界广阔无垠，让想象力引领前行，但人心永远不可直视</strong></em>
  </blockquote>
</div>

<br>

![Narratium.ai](/public/banner.png)

<p align="center">
  <em>An open-source AI character platform to build, customize, and chat with virtual personas</em>
  <br>
  <em>For writers, developers, and storytellers building interactive worlds</em>
</p>

<div align="center">
  <a href="https://narratium.org">🔗 Live Demo</a> &nbsp;|&nbsp;
  <a href="https://deepwiki.com/Narratium/Narratium.ai/">📖 DeepWiki Docs</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/stargazers">⭐ Star Us</a> &nbsp;|&nbsp;
  <a href="https://discord.gg/PP7EpSzDfU">💬 Discord Community</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/releases">💾 Download</a> &nbsp;|&nbsp;
  <a href="./README_ZH.md">🇨🇳 中文文档</a>
</div>

<br>

<div align="center">

![GitHub stars](https://img.shields.io/github/stars/Narratium/Narratium.ai?style=social)
![GitHub forks](https://img.shields.io/github/forks/Narratium/Narratium.ai?style=social)
![GitHub commits](https://img.shields.io/github/commit-activity/m/Narratium/Narratium.ai)
![GitHub Downloads](https://img.shields.io/github/downloads/Narratium/Narratium.ai/total)

</div>

<div align="center">
  <em><strong>Characters, worlds, and conversations — beautifully unified in Narratium</strong></em>
</div>

<br>

<img src="./assets/demo_show.gif" style="width: 100%"/>

## Getting started & staying tuned with us

<div align="center">
  <strong>Star us, and you will receive all release notifications from GitHub without any delay!</strong>
</div>

<br>

<img src="./assets/welcome_star.gif" style="width: 100%"/>

| What is Narratium |
| :---------------- |

[Narratium.ai](https://narratium.org/) is an open-source platform for creating AI characters, immersive worlds, and dynamic conversations.It's your creative studio for building personalized roleplay adventures — from emotional journeys to epic sagas.

| Quickly Start |
| :---------- |

For detailed installation and setup instructions, please refer to our [Getting Started Guide](./docs/GETTING_STARTED.md)

For detailed Vercel deployment instructions, please refer to the [Vercel Deployment Guide](./docs/VERCEL_DEPLOYMENT.md).

For Download Version: please refer to the [Download for Mac, Windows, Linux](https://github.com/Narratium/Narratium.ai/releases)

| Features |
| :------- |

- **Immersive Adventure Mode**: Create personalized worlds and make decisions that matter.
- **Visual Memory Management**: React Flow-powered session tracing and branching.
- **Character Cards & Lore**: Compatible with SillyTavern cards, manage everything in one place.

| Narratium vs. Other AI Roleplay Platforms |
| :---------------------------------------- |

<table style="width: 100%;">
  <tr>
    <th align="center">Feature</th>
    <th align="center">Narratium.ai</th>
    <th align="center">SillyTavern</th>
    <th align="center">AI Dungeon</th>
  </tr>
  <tr>
    <td><strong>Open Source</strong></td>
    <td align="center">✅</td>
    <td align="center">✅</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>Beginner Friendly</strong></td>
    <td align="center">✅</td>
    <td align="center">❌ (complex setup)</td>
    <td align="center">✅ (but limited flow)</td>
  </tr>
  <tr>
    <td><strong>Character Memory &amp; Tracking</strong></td>
    <td align="center">✅</td>
    <td align="center">⚠️ (plugin-based)</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>Worldbook Support</strong></td>
    <td align="center">✅</td>
    <td align="center">⚠️ (via extensions)</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>Long-term Conversation Support</strong></td>
    <td align="center">✅</td>
    <td align="center">✅</td>
    <td align="center">❌ (limited context)</td>
  </tr>
  <tr>
    <td><strong>Offline / Local Deployment</strong></td>
    <td align="center">✅</td>
    <td align="center">✅</td>
    <td align="center">❌</td>
  </tr>
  <tr>
    <td><strong>Visual Interface / UI Polish</strong></td>
    <td align="center">✅</td>
    <td align="center">❌ (minimal)</td>
    <td align="center">✅</td>
  </tr>
  <tr>
    <td><strong>Infinite Branching Storylines</strong></td>
    <td align="center">✅</td>
    <td align="center">⚠️ (manual effort)</td>
    <td align="center">✅ (but unstable)</td>
  </tr>
</table>

| License Overview |
| :--------------- |

This project consists of two distinct parts with independent licenses:

- ✅ Code: MIT License — open for commercial and non-commercial use with attribution.
- 🔒 Content: CC BY-NC-SA 4.0 — non-commercial use only, with attribution and same-license sharing required.

> For full license details, please refer to the [LICENSE](./LICENSE).

| Contact & Support |
| :---------------- |

* 如果你喜欢这个项目，我们非常欢迎你加入
* If you like this project, we warmly welcome you to join us
[Discord community](https://discord.gg/PP7EpSzDfU)

| Code Contributer |
| :--------------- |

[![Contributors](https://contrib.rocks/image?repo=Narratium/Narratium.ai)](https://github.com/Narratium/Narratium.ai/graphs/contributors)

| Others |
| :----- |

Thanks all Official Website Test API Sponsor

| Star Growth |
| :---------- |

[![Stargazers over time](https://starchart.cc/Narratium/Narratium.ai.svg?variant=adaptive)](https://starchart.cc/Narratium/Narratium.ai)
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "out/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

</files>
