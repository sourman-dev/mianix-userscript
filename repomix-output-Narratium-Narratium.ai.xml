This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ‚ãÆ---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ‚ãÆ---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build.yml
    BuildDockerImage.yml
    sync.yml
app/
  character/
    page.tsx
  character-cards/
    page.tsx
  contexts/
    SoundContext.tsx
  creator-area/
    page.tsx
  creator-input/
    page.tsx
  i18n/
    locales/
      en.json
      zh.json
    fonts.ts
    FontWrapper.tsx
    index.ts
    LanguageProvider.tsx
  styles/
    fantasy-ui.css
    fonts.css
    local-fonts.css
  globals.css
  layout.tsx
  metadata.ts
  not-found.tsx
  page.tsx
components/
  __tests__/
    ChatHtmlBubble.test.ts
  AdvancedSettingsEditor.tsx
  CharacterAvatarBackground.tsx
  CharacterCardCarousel.tsx
  CharacterCardGrid.tsx
  CharacterChatHeader.tsx
  CharacterChatPanel.tsx
  CharacterSidebar.tsx
  ChatHtmlBubble.tsx
  CreatePresetModal.tsx
  DialogueTreeModal.tsx
  DownloadCharacterModal.tsx
  EditCharacterModal.tsx
  EditPromptModal.tsx
  GoogleAnalytics.tsx
  HomeContent.tsx
  ImportCharacterModal.tsx
  ImportPresetModal.tsx
  ImportRegexScriptModal.tsx
  ImportWorldBookModal.tsx
  LoadingTransition.tsx
  LoginModal.tsx
  MainLayout.tsx
  MobileBottomNav.tsx
  ModelSidebar.tsx
  PresetEditor.tsx
  PromptEditor.tsx
  RegexScriptEditor.tsx
  RegexScriptEntryEditor.tsx
  SettingsDropdown.tsx
  Sidebar.tsx
  TagColorEditor.tsx
  UserTour.tsx
  WorldBookEditor.tsx
  WorldBookEntryEditor.tsx
contexts/
  SoundContext.tsx
  SymbolColorStore.ts
docs/
  GETTING_STARTED.md
  PROBLEM.md
  VERCEL_DEPLOYMENT.md
function/
  character/
    delete.ts
    import.ts
    list.ts
  data/
    export-import.ts
    google-control.ts
    google-request.ts
  dialogue/
    chat.ts
    delete.ts
    edit.ts
    incremental-info.ts
    info.ts
    init.ts
    save-prompts.ts
    truncate.ts
    update.ts
  preset/
    download.ts
    edit.ts
    global.ts
    import.ts
  regex/
    add.ts
    delete.ts
    get-setting.ts
    get.ts
    global.ts
    import.ts
    update-setting.ts
    update.ts
  worldbook/
    bulk-operations.ts
    delete.ts
    edit.ts
    global.ts
    import.ts
    info.ts
    settings.ts
hooks/
  useTour.ts
lib/
  adapter/
    tagReplacer.ts
  core/
    agent-engine.ts
    agent-service.ts
    agent-tools.ts
    character-dialogue.ts
    character-history.ts
    character.ts
    preset-assembler.ts
    prompt-assembler.ts
    regex-processor.ts
    world-book.ts
  data/
    agent-operation.ts
    character-dialogue-operation.ts
    character-record-operation.ts
    local-storage.ts
    preset-operation.ts
    regex-script-operation.ts
    world-book-operation.ts
  models/
    agent-model.ts
    character-dialogue-model.ts
    character-model.ts
    character-prompts-model.ts
    node-model.ts
    parsed-response.ts
    preset-model.ts
    rawdata-model.ts
    regex-script-model.ts
    world-book-model.ts
  nodeflow/
    ContextNode/
      ContextNode.ts
      ContextNodeTools.ts
    LLMNode/
      LLMNode.ts
      LLMNodeTools.ts
    OutputNode/
      OutputNode.ts
    PresetNode/
      PresetNode.ts
      PresetNodeTools.ts
    RegexNode/
      RegexNode.ts
      RegexNodeTools.ts
    UserInputNode/
      UserInputNode.ts
    WorldBookNode/
      WorldBookNode.ts
      WorldBookNodeTools.ts
    NodeBase.ts
    NodeContext.ts
    NodeTool.ts
    types.ts
    WorkflowEngine.ts
  prompts/
    character-prompts.ts
    preset-prompts.ts
  workflow/
    examples/
      DialogueWorkflow.ts
    BaseWorkflow.ts
utils/
  character-parser.ts
  google-analytics.ts
  response-parser.ts
  version-compare.ts
.env.example
.gitignore
docker-compose.yml
Dockerfile
eslint.config.mjs
LICENSE
next.config.ts
package.json
postcss.config.mjs
README_ZH.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/build.yml">
name: Build and Package
on:
  workflow_dispatch:
jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        include:
          - os: ubuntu-latest
            artifact_name: Narratium-linux
            asset_name: narratium-linux.tar.gz
            output_dir: pake/Narratium-linux
          - os: windows-latest
            artifact_name: Narratium-windows
            asset_name: narratium-windows.zip
            output_dir: pake/Narratium-win32
          - os: macos-latest
            artifact_name: Narratium-macos
            asset_name: narratium-macos.dmg
            output_dir: pake/Narratium.app
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
    - name: Install Linux dependencies
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt update
        sudo apt install -y libwebkit2gtk-4.1-dev \
          build-essential \
          curl \
          wget \
          file \
          libxdo-dev \
          libssl-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev
    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
        run_install: false
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    - name: Install dependencies
      run: pnpm install
    - name: Build Next.js app
      run: pnpm build
    - name: Install Pake CLI
      run: npm install -g pake-cli
    - name: Debug - Check icon files
      if: matrix.os != 'windows-latest'
      run: |
        echo "Checking icon files:"
        ls -la public/
        echo "Icon file exists:"
        if [ -f "public/icon.ico" ]; then echo "Yes"; else echo "No"; fi
        if [ -f "public/icon.png" ]; then echo "Yes"; else echo "No"; fi
        if [ -f "public/icon.icns" ]; then echo "Yes"; else echo "No"; fi
    - name: Debug - Check icon files (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        echo "Checking icon files:"
        Get-ChildItem -Path public/
        echo "Icon file exists:"
        if (Test-Path -Path "public/icon.ico") { echo "Yes" } else { echo "No" }
        if (Test-Path -Path "public/icon.png") { echo "Yes" } else { echo "No" }
        if (Test-Path -Path "public/icon.icns") { echo "Yes" } else { echo "No" }
    - name: Build with Pake (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: pake out/index.html --name Narratium --use-local-file --icon public/icon.png
    - name: Build with Pake (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        mkdir -p pake/icons
        Copy-Item "public\icon.ico" "pake\icons\icon.ico" -Force
        pake out/index.html --name Narratium
    - name: Build with Pake (macOS)
      if: matrix.os == 'macos-latest'
      run: pake out/index.html --name Narratium --use-local-file --icon public/icon.icns
    - name: Debug - List files (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        echo "Current directory:"
        pwd
        echo "Files in current directory:"
        ls -la
        echo "Files in pake directory (if exists):"
        ls -la pake || echo "pake directory not found"
        echo "Finding DMG files:"
        find . -name "*.dmg"
    - name: Package artifacts (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        mkdir -p dist
        echo "Current directory:"
        pwd
        echo "Files in current directory:"
        ls -la
        if [ -f "pake.deb" ]; then
          echo "Found pake.deb file, using it as the artifact"
          cp pake.deb dist/${{ matrix.asset_name }}
        else
          DEB_FILE=$(find . -name "*.deb" | head -n 1)
          if [ -n "$DEB_FILE" ]; then
            echo "Found .deb file: $DEB_FILE"
            cp "$DEB_FILE" dist/${{ matrix.asset_name }}
          else
            echo "No .deb file found, trying to find Narratium directory"
            NARRATIUM_DIR=$(find . -type d -name "Narratium*" | grep -v "node_modules" | head -n 1)
            if [ -z "$NARRATIUM_DIR" ]; then
              echo "Error: Could not find Narratium directory or .deb file"
              exit 1
            else
              echo "Found Narratium directory: $NARRATIUM_DIR"
              tar -czf dist/${{ matrix.asset_name }} "$NARRATIUM_DIR"
            fi
          fi
        fi
    - name: Package artifacts (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        mkdir -p dist
        New-Item -Path "temp_for_zip" -ItemType Directory -Force
        $msiFile = Get-ChildItem -Path "C:\npm\prefix\node_modules\pake-cli\src-tauri\target\release\bundle\msi\*.msi" -File | Select-Object -First 1
        if ($msiFile) {
          echo "Found MSI file: $($msiFile.FullName)"
          Copy-Item $msiFile.FullName -Destination "temp_for_zip\Narratium.msi"
          $exeFile = Get-ChildItem -Path "C:\npm\prefix\node_modules\pake-cli\src-tauri\target\release\*.exe" -File | Select-Object -First 1
          if ($exeFile) {
            echo "Found EXE file: $($exeFile.FullName)"
            Copy-Item $exeFile.FullName -Destination "temp_for_zip\Narratium.exe"
          }
          Set-Content -Path "temp_for_zip\README.txt" -Value "Narratium Windows Installation`n`nThis package contains:`n- Narratium.msi: Windows installer`n`nTo install, double-click the MSI file."
          Compress-Archive -Path "temp_for_zip\*" -DestinationPath "dist\${{ matrix.asset_name }}" -Force
        } else {
          $msiFile = Get-ChildItem -Path . -Recurse -Filter "*.msi" | Where-Object { $_.FullName -like "*Narratium*.msi" } | Select-Object -First 1
          if ($msiFile) {
            echo "Found MSI file via fallback search: $($msiFile.FullName)"
            Copy-Item $msiFile.FullName -Destination "temp_for_zip\Narratium.msi"
            Set-Content -Path "temp_for_zip\README.txt" -Value "Narratium Windows Installation`n`nThis package contains:`n- Narratium.msi: Windows installer`n`nTo install, double-click the MSI file."
            Compress-Archive -Path "temp_for_zip\*" -DestinationPath "dist\${{ matrix.asset_name }}" -Force
          } else {
            echo "Error: Could not find MSI file"
            exit 1
          }
        }
    - name: Package artifacts (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        mkdir -p dist
        DMG_FILE=$(find . -name "Narratium*.dmg" | head -n 1)
        if [ -z "$DMG_FILE" ]; then
          echo "Error: DMG file not found"
          exit 1
        else
          echo "Found DMG file: $DMG_FILE"
          cp "$DMG_FILE" dist/${{ matrix.asset_name }}
        fi
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: dist/${{ matrix.asset_name }}
        retention-days: 30
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/Narratium-linux/narratium-linux.tar.gz
            artifacts/Narratium-windows/narratium-windows.zip
            artifacts/Narratium-macos/narratium-macos.dmg
          draft: false
          prerelease: false
</file>

<file path=".github/workflows/BuildDockerImage.yml">
name: Build and Push Docker Image
on:
  workflow_dispatch:
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get latest tag as version
        id: get_latest_tag
        run: |
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "latest")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/narratium-ai:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/narratium-ai:${{ env.LATEST_TAG }}
</file>

<file path=".github/workflows/sync.yml">
name: Upstream Sync
permissions:
  contents: write
on:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:
jobs:
  sync_latest_from_upstream:
    name: Sync latest commits from upstream repo
    runs-on: ubuntu-latest
    if: ${{ github.event.repository.fork }}
    steps:
      - name: Checkout target repo
        uses: actions/checkout@v3
      - name: Sync upstream changes
        id: sync
        uses: aormsby/Fork-Sync-With-Upstream-action@v3.4
        with:
          upstream_sync_repo: Narratium/Narratium.ai
          upstream_sync_branch: main
          target_sync_branch: main
          target_repo_token: ${{ secrets.GITHUB_TOKEN }}
          test_mode: false
      - name: Sync check
        if: failure()
        run: |
          echo "[Error] Áî±‰∫é‰∏äÊ∏∏‰ªìÂ∫ìÁöÑ workflow Êñá‰ª∂ÂèòÊõ¥ÔºåÂØºËá¥ GitHub Ëá™Âä®ÊöÇÂÅú‰∫ÜÊú¨Ê¨°Ëá™Âä®Êõ¥Êñ∞Ôºå‰Ω†ÈúÄË¶ÅÊâãÂä® Sync Fork ‰∏ÄÊ¨°„ÄÇ"
          exit 1
</file>

<file path="app/character/page.tsx">
import { useState, useEffect, useRef } from "react";
import { useSearchParams } from "next/navigation";
import { useLanguage } from "@/app/i18n";
import CharacterSidebar from "@/components/CharacterSidebar";
import { PromptType } from "@/lib/models/character-prompts-model";
import { v4 as uuidv4 } from "uuid";
import { initCharacterDialogue } from "@/function/dialogue/init";
import { getCharacterDialogue } from "@/function/dialogue/info";
import { handleCharacterChatRequest } from "@/function/dialogue/chat";
import { switchDialogueBranch } from "@/function/dialogue/truncate";
import { deleteDialogueNode } from "@/function/dialogue/delete";
import CharacterChatPanel from "@/components/CharacterChatPanel";
import WorldBookEditor from "@/components/WorldBookEditor";
import RegexScriptEditor from "@/components/RegexScriptEditor";
import PresetEditor from "@/components/PresetEditor";
import CharacterChatHeader from "@/components/CharacterChatHeader";
import UserTour from "@/components/UserTour";
import { useTour } from "@/hooks/useTour";
interface Character {
  id: string;
  name: string;
  personality?: string;
  avatar_path?: string;
}
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp?: string;
}
‚ãÆ----
const switchToView = (targetView: "chat" | "worldbook" | "regex" | "preset") =>
const toggleView = () =>
const toggleRegexEditor = () =>
const truncateMessagesAfter = async (nodeId: string) =>
const handleRegenerate = async (nodeId: string) =>
const fetchLatestDialogue = async () =>
‚ãÆ----
const loadCharacterAndDialogue = async () =>
‚ãÆ----
const initializeNewDialogue = async (charId: string) =>
const handleSendMessage = async (message: string) =>
‚ãÆ----
const handleSwitchToPresetView = (event: any) =>
‚ãÆ----
const toggleSidebar = () =>
const handleSuggestedInput = (input: string) =>
‚ãÆ----
onViewSwitch=
</file>

<file path="app/character-cards/page.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { motion } from "framer-motion";
import ImportCharacterModal from "@/components/ImportCharacterModal";
import EditCharacterModal from "@/components/EditCharacterModal";
import DownloadCharacterModal from "@/components/DownloadCharacterModal";
import CharacterCardGrid from "@/components/CharacterCardGrid";
import CharacterCardCarousel from "@/components/CharacterCardCarousel";
import { getAllCharacters } from "@/function/character/list";
import { deleteCharacter } from "@/function/character/delete";
import { handleCharacterUpload } from "@/function/character/import";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
‚ãÆ----
const checkMobile = () =>
‚ãÆ----
const fetchCharacters = async () =>
const handleDeleteCharacter = async (characterId: string) =>
const handleEditClick = (character: Character, e: React.MouseEvent) =>
const handleEditSuccess = () =>
const downloadPresetCharacters = async () =>
</file>

<file path="app/contexts/SoundContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
interface SoundContextType {
  soundEnabled: boolean;
  toggleSound: () => void;
}
‚ãÆ----
export function useSoundContext()
interface SoundProviderProps {
  children: ReactNode;
}
export function SoundProvider(
‚ãÆ----
const toggleSound = () =>
</file>

<file path="app/creator-area/page.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
</file>

<file path="app/creator-input/page.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import { Send, Sparkles } from "lucide-react";
import { useRouter } from "next/navigation";
import { useLanguage } from "../i18n";
‚ãÆ----
const handleSubmit = async (e: React.FormEvent) =>
const handleKeyPress = (e: React.KeyboardEvent) =>
‚ãÆ----
onChange=
‚ãÆ----
placeholder=
</file>

<file path="app/i18n/locales/en.json">
{
  "common": {
    "save": "Save",
    "cancel": "Cancel",
    "close": "Close",
    "return": "Return",
    "settings": "Settings",
    "switchToEnglish": "Switch to English",
    "switchToChinese": "Switch to Chinese",
    "soundOn": "Sound On",
    "soundOff": "Sound Off",
    "saving": "Saving...",
    "defaultAutoFillFileName": "Default: Auto-fill from file name",
    "exportData": "Export Data",
    "exportDataToGoogle": "Export Data To Google",
    "importData": "Import Data",
    "importDataFromGoogle": "Import Data From Google",
    "exportFailed": "Export failed, please try again",
    "importFailed": "Import failed, please try again"
  },
  "sidebar": {
    "home": "Home",
    "gameArea": "Game Area",
    "creator": "Creator",
    "creationArea": "Creation Area",
    "historyRecords": "History Records",
    "newStory": "New Adventure",
    "storyCollection": "Story Collection",
    "characterCards": "Character Cards",
    "characterMarket": "Character Market",
    "login": "Login & Explore",
    "nologin": "Define User Name",
    "logout": "Logout",
    "collapseHome": "Collapse Home",
    "expandHome": "Expand Home",
    "collapseCreation": "Collapse Game Area",
    "expandCreation": "Expand Game Area",
    "collapseCreator": "Collapse Creation Area",
    "expandCreator": "Expand Creation Area",
    "goToUpdate": "Go to Update",
    "newVersionAvailable": "New Version Available",
    "currentVersion": "Current: v{version}"
  },
  "modelSettings": {
    "title": "Model Settings",
    "llmType": "LLM Type",
    "baseUrl": "Base URL",
    "model": "Model",
    "apiKey": "API Key",
    "language": "Output Language",
    "chinese": "Chinese",
    "english": "English",
    "saveSettings": "Click to enable",
    "settingsSaved": "Settings Saved",
    "commonModels": "Common Models:",
    "modelList": "Model List",
    "selectModel": "Select a model...",
    "modelListUnavailable": "Model list unavailable",
    "configurations": "API Configurations",
    "newConfig": "New Config",
    "configName": "Configuration Name",
    "configNamePlaceholder": "My API Configuration",
    "createConfig": "Create Configuration",
    "nameRequired": "Name is required",
    "cannotDeleteLastConfig": "Cannot delete the last configuration",
    "confirmDelete": "Are you sure you want to delete this configuration?",
    "createFirstConfig": "Create Your First Configuration",
    "noConfigs": "No API configurations yet",
    "getModelList": "Get Model List",
    "getModelListSuccess": "Get Model List Success",
    "getModelListError": "Get Model List Error",
    "configCreated": "Configuration created",
    "doubleClickToEditName": "Double click to edit name",
    "testModel": "Test Model",
    "testing": "Testing...",
    "testSuccess": "Model test successful",
    "testError": "Model test failed",
    "apiTestFailed": "API test failed",
    "modelTestFailed": "Model test failed"
  },
  "llmSettings": {
    "title": "Settings",
    "modelType": "Model Type",
    "presets": "Presets",
    "creative": "Creative",
    "balanced": "Balanced",
    "precise": "Precise",
    "commonParams": "Common",
    "advancedParams": "Advanced",
    "temperature": "Temperature",
    "temperatureDescription": "Controls randomness in text generation. Higher values produce more diverse outputs, lower values produce more deterministic outputs.",
    "maxTokens": "Max Tokens",
    "maxTokensDescription": "Maximum number of tokens to generate. Leave empty to use model default.",
    "timeout": "Timeout",
    "timeoutDescription": "Timeout for API requests in milliseconds. Leave empty to use default.",
    "maxRetries": "Max Retries",
    "maxRetriesDescription": "Maximum number of retries when API requests fail.",
    "topP": "Top P",
    "topPDescription": "Controls diversity via nucleus sampling. Lower values consider fewer high-probability options.",
    "frequencyPenalty": "Frequency Penalty",
    "frequencyPenaltyDescription": "Penalizes tokens based on their frequency in the text so far. Higher values reduce repetition.",
    "presencePenalty": "Presence Penalty",
    "presencePenaltyDescription": "Penalizes tokens that have appeared in the text so far. Higher values encourage new topics.",
    "topK": "Top K",
    "topKDescription": "Limits token selection to the K most likely tokens. Lower values make output more focused.",
    "repeatPenalty": "Repeat Penalty",
    "repeatPenaltyDescription": "Penalizes repeated tokens. Higher values reduce repetition in Ollama models.",
    "optional": "Optional, leave empty for default"
  },
  "sessionList": {
    "loading": "Summoning history scrolls...",
    "noHistory": "No history records yet",
    "continue": "Continue",
    "delete": "Delete"
  },
  "homePage": {
    "slogan": "Within each of us burns a flame",
    "newAdventure": "Begin a New Adventure",
    "continueJourney": "Continue Your Journey",
    "immediatelyStart": "Immediately Start"
  },
  "auth": {
    "username": "Username",
    "password": "Password",
    "login": "Login",
    "register": "Register",
    "welcomeBack": "Welcome Back",
    "continueJourney": "Sign in to continue your journey",
    "emailPlaceholder": "Press Enter to apply username",
    "passwordPlaceholder": "Enter your password...",
    "codePlaceholder": "Enter the verification code...",
    "wizardQuestion": "‚ú® Brave adventurer, please leave your name",
    "spellQuestion": "üîÆ Cast your protective spell, it will guard your fantastic journey!",
    "codeQuestion": "‚ö° Enter the mysterious runes sent by the cosmic sea to prove your identity!",
    "getCode": "Get Code",
    "openingMagicDoor": "Opening the magic door...",
    "magicSpell": "Password Login",
    "starCode": "Verification Code",
    "agreementText": "By continuing, you agree to our",
    "termsOfService": "Terms of Service",
    "privacyPolicy": "Privacy Policy"
  },
  "storiesPage": {
    "title": "My Story Collection",
    "createNewStory": "Create New Story",
    "loading": "Loading stories...",
    "noStories": "You haven't created any stories yet",
    "createFirstStory": "Create Your First Story",
    "recentlyCreated": "Recently Created",
    "fetchError": "Failed to fetch stories",
    "edit": "Edit",
    "delete": "Delete",
    "play": "Play",
    "deleteConfirm": "Are you sure you want to delete this story?",
    "deleteSuccess": "Story deleted",
    "deleteFailed": "Failed to delete story"
  },
  "newStory": {
    "title": "Create New Story",
    "editTitle": "Edit Story",
    "storyTitle": "Story Title",
    "storyFramework": "Story Setting",
    "characterInfo": "Character Information",
    "questionTitle": "‚ú® What name shall your legend be known by?",
    "questionFramework": "‚ú® In what mystical realm will your adventure unfold?",
    "questionCharacter": "‚ú® What form will you take in this immortal tale?",
    "titlePlaceholder": "Name your epic tale",
    "frameworkPlaceholder": "Describe your fantasy world",
    "characterPlaceholder": "Reveal your hero's identity",
    "create": "Begin Your Legend",
    "creating": "Weaving your legendary tale...",
    "update": "Update Story",
    "updating": "Updating...",
    "cancel": "Cancel",
    "fillAllFields": "Please fill in all required fields",
    "createFailed": "Failed to create story, please try again",
    "updateFailed": "Failed to update story, please try again",
    "updateSuccess": "Story updated successfully"
  },
  "notFound": {
    "title": "The Path Ahead Is Not Yet Open",
    "subtitle": "This Realm Is Still Under Construction",
    "message": "Noble Dreamer, the magical scroll you seek appears to be lost or not yet created.",
    "backToHome": "Return to Home",
    "exploreMore": "Explore Later"
  },
  "game": {
    "fetchStoryFailed": "Failed to fetch story details",
    "fetchStoryFailedRetry": "Failed to fetch story details, please try again",
    "loadSessionFailed": "Failed to load session history",
    "loadSessionFailedRetry": "Failed to load session history, please try again",
    "initializeFailed": "Game initialization failed",
    "setupFailed": "Game setup failed",
    "cannotReadResponseStream": "Cannot read response stream",
    "generatingStory": "Generating story...",
    "actionFailed": "Action failed",
    "confirmDelete": "Are you sure you want to delete this story? This action cannot be undone.",
    "deleteFailed": "Failed to delete story",
    "deleteFailedRetry": "Failed to delete story, please try again",
    "storyNotExist": "Story of Session Not Found", 
    "cannotFindStory": "Cannot find story with ID {id}",
    "backToStoryList": "Back to Story List",
    "expandSidebar": "Expand Sidebar",
    "collapseSidebar": "Collapse Sidebar",
    "storySummary": "Story Summary",
    "storyFramework": "Story Framework",
    "characterInfo": "Character Information",
    "starting": "Starting...",
    "startAdventure": "Begin Adventure",
    "inputCustomAction": "Enter custom action...",
    "execute": "Execute",
    "deleting": "Deleting...",
    "deleteStory": "Delete Story",
    "gameInfo": "Game Information",
    "memoryManagement": "Memory Management",
    "navigation": "Navigation",
    "collapse": "Collapse",
    "expand": "Expand",
    "memoryPlaceholder": "Game memories will be displayed here",
    "memoryDescription": "Memory management allows you to view and edit segments of the game",
    "memoryInstructions": "Click a node to view full content, edges show your actions",
    "editMemory": "Edit Memory",
    "memorySummary": "Memory Summary",
    "fullMemoryContent": "Full Memory Content",
    "editMemoryPlaceholder": "Edit your game memory...",
    "noSessionFound": "No Session Found",
    "startSessionFirst": "Please start a game session first to view memories",
    "loadingMemories": "Loading memories...",
    "jumpToNode": "Jump to this node",
    "expandMemory": "Expand memory content"
  },
  "characterCardsPage": {
    "title": "Character Cards",
    "importCharacter": "Import Character",
    "importFirstCharacter": "Import Your First Character",
    "noCharacters": "You don't have any characters yet",
    "loading": "Loading...",
    "downloadingPresets": "Downloading preset characters...",
    "fetchError": "Failed to fetch characters",
    "deleteFailed": "Failed to delete character",
    "delete": "Delete",
    "edit": "Edit",
    "chat": "Chat",
    "recentlyCreated": "Recently Created",
    "downloadCharacter": "Community Download Character"
  },
  "editCharacterModal": {
    "title": "Edit Character",
    "name": "Name",
    "description": "Description",
    "personality": "Personality",
    "scenario": "Scenario",
    "firstMessage": "Opening Message",
    "mesExample": "Message Examples",
    "creatorComment": "Creator Comments",
    "save": "Save",
    "cancel": "Cancel"
  },
  "importCharacterModal": {
    "title": "Import Character",
    "description": "Select or drag and drop a SillyTavern PNG character card file to import",
    "dragOrClick": "Drag file here or click to select",
    "pngFormat": "Only SillyTavern PNG character card files are supported",
    "pngOnly": "Please select a SillyTavern PNG file",
    "noFileSelected": "Please select a file first",
    "uploadFailed": "Upload failed, please try again",
    "import": "Import",
    "uploading": "Uploading..."
  },
  "characterMarketPage": {
    "description": "Explore a variety of fascinating characters to bring your stories to life",
    "searchPlaceholder": "Search character names or descriptions",
    "allTags": "All",
    "loading": "Loading characters...",
    "noResults": "No matching characters found",
    "clearFilters": "Clear Filters",
    "by": "By:",
    "download": "Download Character",
    "viewDetails": "View Details"
  },
  "characterChat": {
    "navigation": "Navigation",
    "characterInfo": "Character Info",
    "actions": "Actions",
    "expandSidebar": "Expand Sidebar",
    "collapseSidebar": "Collapse Sidebar",
    "backToCharacters": "Back to Characters",
    "Conversation": "Context Manager",
    "noPersonality": "No personality defined",
    "typeMessage": "Type a message...",
    "startConversation": "Start a conversation...",
    "send": "Send",
    "isTyping": "is typing...",
    "suggestedResponse1": "Tell me more",
    "suggestedResponse2": "What happened next?",
    "suggestedResponse3": "How do you feel about that?",
    "promptMode": "Prompt Mode",
    "companionMode": "Progression Mode",
    "nsfwMode": "Companion Mode",
    "explicitMode": "NSFW Mode",
    "customMode":"custom Mode",
    "innerThought": "Inner Thought",
    "screen": "Screen",
    "speech": "Speech",
    "nextPrompt": "Next Step",
    "storyProgress": "Story Progress",
    "storyProgressHint": "Please advance the story plot forward, make the story more interesting and engaging.",
    "perspective": "Perspective",
    "novelPerspective": "Novel Perspective",
    "protagonistPerspective": "Protagonist Perspective",
    "novelPerspectiveHint": "Please use a novel perspective to narrate, describing the scene and character actions in third person.",
    "protagonistPerspectiveHint": "Please use the protagonist's perspective to narrate, using first person to describe thoughts and feelings.",
    "sceneTransition": "Scene Setting",
    "sceneTransitionHint": "Please add scene descriptions and environmental details to enhance the atmosphere.",
    "screenPlaceholder": "Describe the scene or actions...",
    "speechPlaceholder": "What does the character say...",
    "innerThoughtPlaceholder": "What does the character think...",
    "playerInput": "Player Input",
    "responseInstructions": "Response Instructions",
    "characterStatus": "Character Status",
    "responseLength": "Model Response Length",
    "customPrompt": "Custom Prompt",
    "customPromptFor": "Custom Prompts",
    "presets": "Presets",
    "presetEditor": "Preset Editor",
    "githubPresets": "GitHub Presets",
    "noPresets": "No presets available",
    "prefixPrompt": "Prefix Prompt",
    "chainOfThoughtPrompt": "Chain of Thought",
    "suffixPrompt": "Suffix Prompt",
    "prefixPromptDescription": "The prefix prompt is placed at the beginning of the prompt, used to set the character's basic behavior and background.",
    "chainOfThoughtPromptDescription": "The chain of thought prompt is placed in the middle of the prompt, used to guide the character's thinking process.",
    "suffixPromptDescription": "The suffix prompt is placed at the end of the prompt, used to emphasize the character's response format and restrictions.",
    "prefixPromptPlaceholder": "Enter prefix prompt...",
    "chainOfThoughtPromptPlaceholder": "Enter chain of thought prompt...",
    "suffixPromptPlaceholder": "Enter suffix prompt...",
    "autoSaveEnabled": "Auto-save enabled",
    "initializing": "Initializing character...",
    "extractingTemplate": "Extracting character template...",
    "loadingTimeHint": "Loading usually takes 5-20 seconds. If it exceeds 30 seconds, please check your API configuration.",
    "error": "Error",
    "characterNotFound": "Character not found",
    "loading": "Loading...Parsing status, please wait...",
    "worldBook": "World Book",
    "regex": "Regex Script",
    "preset": "Preset",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "filtered": "Filtered",
    "advancedSettings": "Advanced Settings",
    "tagColorEditor": "Tag Color Editor",
    "enterTagName": "Enter tag name...",
    "add": "Add",
    "saveChanges": "Save Changes",
    "enterSymbol": "When entering a tag, it will match <tag>...</tag>",
    "enableStreaming": "Enable Streaming",
    "disableStreaming": "Disable Streaming",
    "jumpToMessage": "Jump to Message",
    "regenerateMessage": "Regenerate Message",
    "enableFastModel": "Enable Fast Mode",
    "disableFastModel": "Disable Fast Mode"
  },
  "preset": {
    "title": "Preset Manager",
    "createPreset": "Create Preset",
    "importPreset": "Import Preset",
    "sortBy": "Sort By",
    "sortOrder": "Sort Order",
    "filterBy": "Filter By",
    "ascending": "Ascending",
    "descending": "Descending",
    "asc": "Asc",
    "desc": "Desc",
    "all": "All",
    "active": "With Prompts",
    "empty": "Empty",
    "name": "Name",
    "promptCount": "Prompt Count",
    "lastUpdated": "Last Updated",
    "status": "Status",
    "prompts": "Prompts",
    "updated": "Updated",
    "actions": "Actions",
    "active_status": "Active",
    "empty_status": "Empty",
    "total": "Total",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "filtered": "Filtered",
    "loading": "Loading Presets...",
    "noPresetsFound": "No Presets Found",
    "createFirstPreset": "Create your first preset to get started",
    "enterPresetName": "Enter preset name:",
    "createSuccess": "Preset created successfully",
    "createFailed": "Failed to create preset",
    "deleteConfirm": "Are you sure you want to delete this preset?",
    "deleteSuccess": "Preset deleted successfully",
    "deleteFailed": "Failed to delete preset",
    "loadFailed": "Failed to load presets",
    "loadDetailsFailed": "Failed to load preset details",
    "expandDetails": "Expand details",
    "collapseDetails": "Collapse details",
    "promptsTitle": "Prompts",
    "addPrompt": "Add Prompt",
    "enterPromptName": "Enter prompt name:",
    "addPromptSuccess": "Prompt added successfully",
    "addPromptFailed": "Failed to add prompt",
    "deletePromptConfirm": "Are you sure you want to delete this prompt?",
    "deletePromptSuccess": "Prompt deleted successfully",
    "deletePromptFailed": "Failed to delete prompt",
    "noPromptsInPreset": "No prompts in this preset",
    "enabled_prompt": "Enabled",
    "disabled_prompt": "Disabled",
    "system": "System",
    "deletePrompt": "Delete prompt",
    "promptEnabledSuccess": "Prompt enabled successfully",
    "promptDisabledSuccess": "Prompt disabled successfully",
    "togglePromptFailed": "Failed to toggle prompt",
    "applyPresetSuccess": "Preset applied successfully",
    "applyPresetFailed": "Failed to apply preset",
    "applyPreset": "Apply Preset",
    "presetApplied": "Preset Active",
    "cannotApplyEmpty": "Cannot apply empty preset",
    "enablePreset": "Enable preset",
    "disablePreset": "Disable preset",
    "presetEnabledSuccess": "Preset enabled successfully",
    "presetEnabledExclusiveSuccess": "Preset enabled successfully (other presets disabled)",
    "presetDisabledSuccess": "Preset disabled successfully",
    "togglePresetFailed": "Failed to toggle preset",
    "presetDisabled": "Preset is disabled",
    "cannotApplyDisabled": "Cannot apply disabled preset",
    "toggle": "Toggle",
    "presetName": "Preset Name",
    "presetNamePlaceholder": "Enter preset name",
    "presetNameRequired": "Preset name is required",
    "creating": "Creating...",
    "create": "Create",
    "cancel": "Cancel",
    "editPrompt": "Edit Prompt",
    "promptContent": "Prompt Content",
    "saving": "Saving",
    "save": "Save"
  },
  "importPreset": {
    "title": "Import Preset",
    "dragDropFile": "Import Preset File",
    "dropFileHere": "Drop your file here",
    "browseFiles": "Browse Files",
    "dragAndDrop": "Drag and drop a JSON preset file, or click to browse",
    "importing": "Importing...",
    "importSuccess": "Import Successful",
    "importFailed": "Import Failed",
    "presetImported": "Preset has been imported successfully!",
    "importError": "An error occurred during import",
    "customizePreset": "Customize Preset",
    "presetName": "Preset Name",
    "presetNameDesc": "Leave empty to use the original name from the file",
    "confirmImport": "Confirm Import",
    "guidelines": "Import Guidelines",
    "jsonFormat": "Preset files must be in JSON format",
    "validStructure": "Files should contain valid preset structure with prompts",
    "noOverwrite": "Existing presets with same name will not be overwritten",
    "maxFileSize": "Maximum file size: 10MB",
    "selectJsonFile": "Please select a JSON file",
    "failedToImport": "Failed to import",
    "cancel": "Cancel"
  },
  "worldBook": {
    "title": "World Book",
    "addEntry": "Add Entry",
    "sortBy": "Sort by",
    "sortOrder": "Sort Order",
    "asc": "Ascending",
    "desc": "Descending",
    "importing": "Importing",
    "imported": "Global",
    "importedAt": "Imported at:",
    "saveAsGlobalWorldBook": "Save as Global World Book",
    "globalName": "Global Name",
    "description": "Description (Optional)",
    "enterGlobalWorldBookName": "Default to use filename",
    "enterDescriptionForThisGlobalWorldBook": "Default to empty description",
    "importWorldBook": "Import World Book",
    "dragDropJson": "Drag and drop JSON file here",
    "jsonFileOnly": "JSON files only",
    "importResults": "Import Results",
    "importedEntries": "Imported {count} entries",
    "skippedEntries": "Skipped {count} entries",
    "importErrors": "Import Errors",
    "loading": "Loading world book data...",
    "noEntries": "No world book entries yet",
    "noEntriesDescription": "Click \"Create Entry\" to start creating your first world book entry",
    "createEntry": "Create Entry",
    "editEntry": "Edit Entry",
    "newEntry": "New World Book Entry",
    "deleteEntry": "Delete Entry",
    "bulkOperations": "Bulk Operations",
    "enableAll": "Enable All",
    "disableAll": "Disable All",
    "enableDisabled": "Enable Disabled",
    "disableEnabled": "Disable Enabled",
    "enabledAll": "All entries enabled",
    "disabledAll": "All entries disabled",
    "noEntriesWithStatus": "No entries found with status \"{status}\"",
    "bulkEnable": "Bulk Enable",
    "bulkDisable": "Bulk Disable",
    "bulkDelete": "Bulk Delete",
    "selectAll": "Select All",
    "selectEntriesFirst": "Please select entries to operate on first",
    "confirmDelete": "Are you sure you want to delete this entry?",
    "saveSuccess": "Save successful",
    "saveFailed": "Save failed",
    "deleteSuccess": "Delete successful",
    "deleteFailed": "Delete failed",
    "bulkOperationFailed": "Bulk operation failed",
    "keywordRequired": "At least one keyword is required",
    "contentRequired": "Content cannot be empty",
    "totalCount": "Total:",
    "enabledCount": "Enabled:",
    "disabledCount": "Disabled:",
    "selectedItems": "Selected",
    "items": "items",
    "contextWindow": "Context Window:",
    "status": "Status",
    "comment": "Comment",
    "keywords": "Keywords",
    "position": "Position",
    "depth": "Depth",
    "characterCount": "Characters",
    "priority": "Priority",
    "actions": "Actions",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "regex": "Regex",
    "constant": "Constant",
    "noComment": "No comment",
    "edit": "Edit",
    "delete": "Delete",
    "contentPreview": "Content Preview",
    "noContent": "No content",
    "secondaryKeywords": "Secondary Keywords",
    "selectiveMatching": "Selective Matching:",
    "tokenCount": "Token Count:",
    "lastUpdated": "Last Updated:",
    "totalKeywords": "Total Keywords:",
    "notCalculated": "Not calculated",
    "yes": "Yes",
    "no": "No",
    "commentTitle": "Comment/Title",
    "commentPlaceholder": "Enter comment or title",
    "insertionOrder": "Insertion Order",
    "primaryKeywords": "Primary Keywords",
    "keywordPlaceholder": "Enter keyword",
    "addKeyword": "Add Keyword",
    "removeKeyword": "Remove Keyword",
    "depthLabel": "Depth",
    "enabledLabel": "Enabled",
    "regexLabel": "Regular Expression",
    "selectiveLabel": "Selective Matching",
    "constantLabel": "Constant Entry",
    "contentLabel": "Content",
    "contentPlaceholder": "Enter world book content...",
    "characters": "characters",
    "save": "Save",
    "cancel": "Cancel",
    "saving": "Saving...",
    "positionOptions": {
      "systemPromptStart": "System Prompt Start",
      "afterSystemPrompt": "After System Prompt",
      "userMessageStart": "User Message Start",
      "afterResponseMode": "After Response Mode",
      "basedOnDepth": "Based on Depth"
    },
    "toggleFailed": "Toggle failed",
    "enableEntry": "Enable entry",
    "disableEntry": "Disable entry",
    "toggle": "Toggle",
    "item": "item",
    "confirmBulkDisable": "This action will disable all entries",
    "importFromJson": "Import from JSON",
    "importValidationFailed": "Import validation failed",
    "selectJsonFile": "Select JSON file",
    "importFromGlobal": "Import from Global World Book",
    "noGlobalWorldBooks": "No global world books available",
    "createGlobalWorldBookFirst": "Create a global world book first",
    "selectGlobalWorldBook": "Select Global World Book",
    "entryCount": "Entry Count",
    "createdAt": "Created At",
    "sourceCharacter": "Source Character",
    "filterBy": "Filter By",
    "filterAll": "All",
    "filterEnabled": "Enabled",
    "filterDisabled": "Disabled",
    "filterImported": "Global",
    "filteredCount": "Filtered",
    "ascending": "Ascending",
    "descending": "Descending",
    "fullscreenContent": "Large Editor",
    "exitFullscreen": "Close Editor"
  },
  "regexScriptEditor": {
    "title": "Regex Script Editor",
    "close": "Close",
    "settings": "Settings",
    "enableProcessing": "Enable regex processing",
    "applyToPrompts": "Apply to prompts",
    "applyToResponses": "Apply to responses",
    "addNewScript": "Add New Script",
    "existingScripts": "Existing Scripts",
    "noScripts": "No scripts found",
    "noScriptsDescription": "Click Add New Script to create your first regex script",
    "priority": "Priority",
    "edit": "Edit",
    "enable": "Enable",
    "disable": "Disable",
    "delete": "Delete",
    "replace": "Replace",
    "findRegex": "Find Regex",
    "replaceString": "Replace String",
    "trimStrings": "Trim Strings",
    "confirmDelete": "Are you sure you want to delete this script?",
    "deleteError": "Failed to delete script",
    "newScript": "New Script",
    "editScript": "Edit Script",
    "scriptName": "Script Name",
    "scriptNamePlaceholder": "Enter script name",
    "findRegexPlaceholder": "/pattern/flags or pattern",
    "replaceStringPlaceholder": "Replacement text (use $1, $2 for groups)",
    "disabled": "Disabled",
    "enabled": "Enabled",
    "cancel": "Cancel",
    "save": "Save",
    "saving": "Saving...",
    "loading": "Loading...",
    "requiredFields": "Please fill in all required fields",
    "saveError": "Failed to save script",
    "totalCount": "Total",
    "enabledCount": "Enabled",
    "disabledCount": "Disabled",
    "filteredCount": "Filtered",
    "sortBy": "Sort By",
    "sortOrder": "Sort Order",
    "asc": "Ascending",
    "desc": "Descending",
    "filterBy": "Filter By",
    "filterAll": "All",
    "filterEnabled": "Enabled",
    "filterDisabled": "Disabled",
    "filterImported": "Global",
    "name": "Name",
    "status": "Status",
    "globalEnabled": "Global Enabled",
    "applyToPrompt": "Apply to Prompt",
    "applyToResponse": "Apply to Response",
    "yes": "Yes",
    "no": "No",
    "importScript": "Import Script",
    "importRegexScript": "Import Regex Script",
    "importFromJson": "Import from JSON",
    "importFromGlobal": "Import from Global",
    "dragDropJson": "Drag and drop JSON file here",
    "jsonFileOnly": "JSON files only",
    "saveAsGlobalRegexScript": "Save as Global Regex Script",
    "globalName": "Global Name",
    "description": "Description",
    "enterGlobalRegexScriptName": "Default to use filename",
    "enterDescriptionForThisGlobalRegexScript": "Default to empty description",
    "importing": "Importing...",
    "importResults": "Import Results",
    "importedScripts": "Imported {count} scripts",
    "skippedScripts": "Skipped {count} scripts",
    "importErrors": "Import Errors",
    "noGlobalRegexScripts": "No global regex scripts available",
    "createGlobalRegexScriptFirst": "Create a global regex script first",
    "selectGlobalRegexScript": "Select Global Regex Script",
    "willUseEachFileName": "Each file's name will be used as the script name"
  },
  "dialogue": {
    "treeVisualization": "Context Manager",
    "node": "Dialogue Node",
    "systemMessage": "System Message",
    "jumpToNode": "Jump to Node",
    "expandNode": "Expand Node",
    "editNode": "Edit Node",
    "userInput": "User Input",
    "assistantResponse": "Assistant Response",
    "noCharacterSelected": "No Character Selected",
    "selectCharacterFirst": "Please select a character first",
    "loadingDialogue": "Loading dialogue data...",
    "noDialogueNodes": "No Dialogue Nodes",
    "startConversation": "Start a conversation to create a dialogue tree",
    "memorySummary": "Memory Summary",
    "nodeId": "Node ID",
    "startingPoint": "Opening Scene",
    "rootNodeCannotJump": "Root node is the starting point of the dialogue and cannot be jumped to",
    "response": "Response Content",
    "responsePlaceholder": "Edit the response content...",
    "resetLayout": "Reset Layout",
    "manualPositions": "Manual Positions"
  },
  "downloadModal": {
      "title": "Download Character from Community Repository",
      "loading": "Loading...",
      "fetchError": "Unable to fetch character list",
      "downloadFailed": "Download failed",
      "importFailed": "Import failed",
      "importing": "Importing...",
      "downloadAndImport": "Download and Import",
      "by": "By:",
      "unknownAuthor": "Anonymous"
  },
  "creatorInput": {
    "title": "Creator Studio",
    "subtitle": "Start creating epic stories",
    "placeholder": "Enter your creative ideas...",
    "sendMessage": "Send message",
    "enterToSend": "Press Enter to send, Shift + Enter for new line",
    "characterCount": "{count}/1000",
    "exampleStories": "Survival, Harry Potter, Lord of the Rings - any story at your will"
  },
  "tour": {
    "welcome": "Welcome to Narratium",
    "welcomeDescription": "Narratium is an intelligent character dialogue platform where you can have in-depth conversations with various AI characters and create unique story experiences. Let's explore the basic features.",
    "loginTitle": "First, Login to Your Account",
    "loginDescription": "Click here to login. Note: The username you enter may be used by AI characters as the protagonist's name, so we recommend using a name you'd like to use in stories.",
    "settingsTitle": "Configure AI Model",
    "settingsDescription": "After logging in, click the settings button in the top right corner to configure your AI model. You can choose OpenAI or Ollama and set the corresponding API keys and model parameters.",
    "worldbookTitle": "World Book Feature",
    "worldbookDescription": "World Book is used to define the character's background world, settings, and important information. AI will maintain character consistency based on the content in the World Book, making conversations more immersive.",
    "regexTitle": "Regex Scripts",
    "regexDescription": "Regex scripts allow you to customize the format and processing logic of AI replies. You can set special text replacement rules to make character expressions more unique.",
    "presetTitle": "Preset Management",
    "presetDescription": "Preset features let you save and manage different conversation settings, including character tone, style, and special instructions, making it easy to switch between different scenarios.",
    "chatTitle": "Start Conversation",
    "chatDescription": "Now you can enter messages in the input box and start exciting conversations with AI characters! AI will respond based on your World Book, regex scripts, and presets.",
    "next": "Next",
    "previous": "Previous",
    "skip": "Skip",
    "finish": "Finish",
    "resetTour": "Reset Tour"
  }
}
</file>

<file path="app/i18n/locales/zh.json">
{
  "common": {
    "save": "‰øùÂ≠ò",
    "cancel": "ÂèñÊ∂à",
    "close": "ÂÖ≥Èó≠",
    "return": "ËøîÂõû",
    "settings": "ËÆæÁΩÆ",
    "switchToEnglish": "ÂàáÊç¢‰∏∫Ëã±Êñá",
    "switchToChinese": "ÂàáÊç¢‰∏∫‰∏≠Êñá",
    "soundOn": "Â£∞Èü≥ÂºÄÂêØ",
    "soundOff": "Â£∞Èü≥ÂÖ≥Èó≠",
    "saving": "‰øùÂ≠ò‰∏≠...",
    "defaultAutoFillFileName": "ÈªòËÆ§ÔºöËá™Âä®Â°´ÂÜôÊñá‰ª∂Âêç",
    "exportData": "ÂØºÂá∫Êï∞ÊçÆ",
    "exportDataToGoogle": "ÂØºÂá∫Êï∞ÊçÆÂà∞Ë∞∑Ê≠å",
    "importData": "ÂØºÂÖ•Êï∞ÊçÆ",
    "importDataFromGoogle": "‰ªéË∞∑Ê≠åÂØºÂÖ•Êï∞ÊçÆ",
    "exportFailed": "ÂØºÂá∫Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "importFailed": "ÂØºÂÖ•Â§±Ë¥•ÔºåËØ∑ÈáçËØï"
  },
  "sidebar": {
    "home": "È¶ñÈ°µ",
    "gameArea": "Ê∏∏ÊàèÂå∫",
    "creator": "ÂàõÈÄ†ËÄÖ",
    "creationArea": "Âàõ‰ΩúÂå∫",
    "historyRecords": "ÂéÜÂè≤ËÆ∞ÂΩï",
    "newStory": "Êñ∞ÂÜíÈô©",
    "storyCollection": "ÊïÖ‰∫ãÈõÜ",
    "characterCards": "ËßíËâ≤Âç°",
    "characterMarket": "ËßíËâ≤Â∏ÇÂú∫",
    "login": "ÁôªÂΩïÂπ∂Êé¢Á¥¢Êõ¥Â§ö",
    "nologin": "ÂÆö‰πâ User ÂêçÁß∞",
    "logout": "ÈÄÄÂá∫ÁôªÂΩï",
    "collapseHome": "Êî∂Ëµ∑È¶ñÈ°µ",
    "expandHome": "Â±ïÂºÄÈ¶ñÈ°µ",
    "collapseCreation": "Êî∂Ëµ∑Ê∏∏ÊàèÂå∫",
    "expandCreation": "Â±ïÂºÄÊ∏∏ÊàèÂå∫",
    "collapseCreator": "Êî∂Ëµ∑Âàõ‰ΩúÂå∫",
    "expandCreator": "Â±ïÂºÄÂàõ‰ΩúÂå∫",
    "goToUpdate": "ÂâçÂæÄÊõ¥Êñ∞",
    "newVersionAvailable": "ÂèëÁé∞Êñ∞ÁâàÊú¨",
    "currentVersion": "ÂΩìÂâçÁâàÊú¨: v{version}"
  },
  "modelSettings": {
    "title": "Ê®°ÂûãËÆæÁΩÆ",
    "llmType": "LLM Á±ªÂûã",
    "baseUrl": "Base URL",
    "model": "Ê®°Âûã",
    "apiKey": "API Key",
    "language": "ËæìÂá∫ËØ≠Ë®Ä",
    "chinese": "‰∏≠Êñá",
    "english": "Ëã±Êñá",
    "saveSettings": "ÁÇπÂáªÂêØÁî®",
    "settingsSaved": "ËÆæÁΩÆÂ∑≤‰øùÂ≠ò",
    "commonModels": "Â∏∏Áî®Ê®°ÂûãÊé®Ëçê:",
    "modelList": "Ê®°ÂûãÂàóË°®",
    "selectModel": "ÈÄâÊã©Ê®°Âûã",
    "modelListUnavailable": "Ê®°ÂûãÂàóË°®‰∏çÂèØÁî®",
    "configurations": "API ÈÖçÁΩÆ",
    "newConfig": "Êñ∞Âª∫ÈÖçÁΩÆ",
    "configName": "ÈÖçÁΩÆÂêçÁß∞",
    "configNamePlaceholder": "ÊàëÁöÑ API ÈÖçÁΩÆ",
    "createConfig": "ÂàõÂª∫ÈÖçÁΩÆ",
    "nameRequired": "ÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫",
    "cannotDeleteLastConfig": "Êó†Ê≥ïÂà†Èô§ÊúÄÂêé‰∏Ä‰∏™ÈÖçÁΩÆ",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ÈÖçÁΩÆÂêóÔºü",
    "configCreated": "ÈÖçÁΩÆÂ∑≤ÂàõÂª∫",
    "noConfigs": "ÊöÇÊó†APIÈÖçÁΩÆ",
    "createFirstConfig": "ÂàõÂª∫‰Ω†ÁöÑÁ¨¨‰∏Ä‰∏™ÈÖçÁΩÆ",
    "getModelList": "Ëé∑ÂèñÊ®°ÂûãÂàóË°®",
    "getModelListSuccess": "Ëé∑ÂèñÊ®°ÂûãÂàóË°®ÊàêÂäü",
    "getModelListError": "Ëé∑ÂèñÊ®°ÂûãÂàóË°®Â§±Ë¥•",
    "doubleClickToEditName": "ÂèåÂáªÂèØ‰øÆÊîπÂêçÁß∞",
    "testModel": "ÊµãËØïÊ®°Âûã",
    "testing": "ÊµãËØï‰∏≠...",
    "testSuccess": "Ê®°ÂûãÊµãËØïÊàêÂäü",
    "testError": "Ê®°ÂûãÊµãËØïÂ§±Ë¥•",
    "apiTestFailed": "API ÊµãËØïÂ§±Ë¥•",
    "modelTestFailed": "Ê®°ÂûãÊµãËØïÂ§±Ë¥•"
  },
  "llmSettings": {
    "title": "ËÆæÁΩÆ",
    "modelType": "Ê®°ÂûãÁ±ªÂûã",
    "presets": "È¢ÑËÆæ",
    "creative": "ÂàõÊÑè",
    "balanced": "Âπ≥Ë°°",
    "precise": "Á≤æÁ°Æ",
    "commonParams": "Â∏∏Áî®ÂèÇÊï∞",
    "advancedParams": "È´òÁ∫ßÂèÇÊï∞",
    "temperature": "Ê∏©Â∫¶",
    "temperatureDescription": "ÊéßÂà∂ÁîüÊàêÊñáÊú¨ÁöÑÈöèÊú∫ÊÄß„ÄÇËæÉÈ´òÁöÑÂÄº‰ºö‰∫ßÁîüÊõ¥Â§öÊ†∑ÂåñÁöÑËæìÂá∫ÔºåËæÉ‰ΩéÁöÑÂÄº‰ºö‰∫ßÁîüÊõ¥Á°ÆÂÆöÁöÑËæìÂá∫„ÄÇ",
    "maxTokens": "ÊúÄÂ§ßÊ†áËÆ∞Êï∞",
    "maxTokensDescription": "ÁîüÊàêÊñáÊú¨ÁöÑÊúÄÂ§ßÊ†áËÆ∞Êï∞„ÄÇÁïôÁ©∫‰ΩøÁî®Ê®°ÂûãÈªòËÆ§ÂÄº„ÄÇ",
    "timeout": "Ë∂ÖÊó∂Êó∂Èó¥",
    "timeoutDescription": "API ËØ∑Ê±ÇÁöÑË∂ÖÊó∂Êó∂Èó¥ÔºàÊØ´ÁßíÔºâ„ÄÇÁïôÁ©∫‰ΩøÁî®ÈªòËÆ§ÂÄº„ÄÇ",
    "maxRetries": "ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞",
    "maxRetriesDescription": "ÂΩì API ËØ∑Ê±ÇÂ§±Ë¥•Êó∂ÁöÑÊúÄÂ§ßÈáçËØïÊ¨°Êï∞„ÄÇ",
    "topP": "Top P ÈááÊ†∑",
    "topPDescription": "ÈÄöËøáÊ†∏ÈááÊ†∑ÊéßÂà∂Â§öÊ†∑ÊÄß„ÄÇËæÉ‰ΩéÁöÑÂÄº‰ºöËÄÉËôëÊõ¥Â∞ëÁöÑÈ´òÊ¶ÇÁéáÈÄâÈ°π„ÄÇ",
    "frequencyPenalty": "È¢ëÁéáÊÉ©ÁΩö",
    "frequencyPenaltyDescription": "Ê†πÊçÆÊ†áËÆ∞Âú®ÊñáÊú¨‰∏≠ÁöÑÈ¢ëÁéáËøõË°åÊÉ©ÁΩö„ÄÇËæÉÈ´òÁöÑÂÄº‰ºöÂáèÂ∞ëÈáçÂ§ç„ÄÇ",
    "presencePenalty": "Â≠òÂú®ÊÉ©ÁΩö",
    "presencePenaltyDescription": "ÊÉ©ÁΩöÂ∑≤ÁªèÂá∫Áé∞Âú®ÊñáÊú¨‰∏≠ÁöÑÊ†áËÆ∞„ÄÇËæÉÈ´òÁöÑÂÄº‰ºöÈºìÂä±Êñ∞‰∏ªÈ¢ò„ÄÇ",
    "topK": "Top K ÈááÊ†∑",
    "topKDescription": "Â∞ÜÊ†áËÆ∞ÈÄâÊã©ÈôêÂà∂‰∏∫ K ‰∏™ÊúÄÂèØËÉΩÁöÑÊ†áËÆ∞„ÄÇËæÉ‰ΩéÁöÑÂÄº‰ΩøËæìÂá∫Êõ¥Âä†ÈõÜ‰∏≠„ÄÇ",
    "repeatPenalty": "ÈáçÂ§çÊÉ©ÁΩö",
    "repeatPenaltyDescription": "ÊÉ©ÁΩöÈáçÂ§çÁöÑÊ†áËÆ∞„ÄÇËæÉÈ´òÁöÑÂÄº‰ºöÂáèÂ∞ë Ollama Ê®°Âûã‰∏≠ÁöÑÈáçÂ§ç„ÄÇ",
    "optional": "ÂèØÈÄâÈ°πÔºåÁïôÁ©∫‰ΩøÁî®ÈªòËÆ§ÂÄº"
  },
  "sessionList": {
    "loading": "Âè¨Âî§ÂéÜÂè≤Âç∑ËΩ¥‰∏≠...",
    "noHistory": "ÊöÇÊó†ÂéÜÂè≤ËÆ∞ÂΩï",
    "continue": "ÁªßÁª≠Ê∏∏Êàè",
    "delete": "Âà†Èô§ËÆ∞ÂΩï"
  },
  "homePage": {
    "slogan": "Êàë‰ª¨ÊØè‰∏™‰∫∫ÁöÑÂøÉÈáåÔºåÈÉΩÊòØ‰∏ÄÂõ¢ÁÅ´ÁÑ∞",
    "newAdventure": "ÂºÄÂêØÊñ∞ÁöÑÂÜíÈô©",
    "continueJourney": "ÁªßÁª≠Êú™ÂÆåÁöÑÊóÖÁ®ã",
    "immediatelyStart": "Á´ãÂàªÂºÄÂßã"
  },
  "auth": {
    "username": "Áî®Êà∑Âêç",
    "password": "ÂØÜÁ†Å",
    "login": "ÁôªÂΩï",
    "register": "Ê≥®ÂÜå",
    "welcomeBack": "Ê¨¢ËøéÂõûÊù•",
    "continueJourney": "ÁôªÂΩï‰ª•ÁªßÁª≠ÊÇ®ÁöÑÊóÖÁ®ã",
    "emailPlaceholder": "ÂõûËΩ¶‰ª•Â∫îÁî®Áî®Êà∑Âêç",
    "passwordPlaceholder": "ËæìÂÖ•ÂØÜÁ†Å",
    "codePlaceholder": "ËæìÂÖ•È™åËØÅÁ†Å",
    "wizardQuestion": "‚ú® ÂãáËÄÖÔºåËØ∑Áïô‰∏ãÊÇ®ÁöÑÂßìÂêç",
    "spellQuestion": "üîÆ ËØ∑ÊñΩÂ±ïÊÇ®ÁöÑÂÆàÊä§ÂííËØ≠ÔºåÂÆÉÂ∞Ü‰øùÊä§ÊÇ®ÁöÑÂ•áÂπªÊóÖÁ®ãÔºÅ",
    "codeQuestion": "‚ö° ËæìÂÖ•ÊòüËæ∞Â§ßÊµ∑ÈÄÅÊù•ÁöÑÁ•ûÁßòÁ¨¶ÊñáÔºåËØÅÊòéÊÇ®ÁöÑË∫´‰ªΩÔºÅ",
    "getCode": "Ëé∑ÂèñÈ™åËØÅÁ†Å",
    "openingMagicDoor": "Ê≠£Âú®ÂºÄÂêØÈ≠îÊ≥ï‰πãÈó®...",
    "magicSpell": "ÂØÜÁ†ÅÁôªÂΩï",
    "starCode": "È™åËØÅÁ†ÅÁôªÂΩï",
    "agreementText": "ÁªßÁª≠Âç≥Ë°®Á§∫ÊÇ®ÂêåÊÑè",
    "termsOfService": "ÊúçÂä°Êù°Ê¨æ",
    "privacyPolicy": "ÈöêÁßÅÊîøÁ≠ñ"
  },
  "storiesPage": {
    "title": "ÊàëÁöÑÊïÖ‰∫ã",
    "createNewStory": "ÂàõÂª∫Êñ∞ÊïÖ‰∫ã",
    "loading": "Ê≠£Âú®Âä†ËΩΩÊïÖ‰∫ã...",
    "noStories": "‰Ω†ËøòÊ≤°ÊúâÂàõÂª∫‰ªª‰ΩïÊïÖ‰∫ã",
    "createFirstStory": "ÂàõÂª∫Á¨¨‰∏Ä‰∏™ÊïÖ‰∫ã",
    "recentlyCreated": "ÊúÄËøëÂàõÂª∫",
    "fetchError": "Ëé∑ÂèñÊïÖ‰∫ãÂàóË°®Â§±Ë¥•",
    "edit": "ÁºñËæë",
    "delete": "Âà†Èô§",
    "deleteConfirm": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÊïÖ‰∫ãÂêóÔºü",
    "deleteSuccess": "ÊïÖ‰∫ãÂ∑≤Âà†Èô§",
    "deleteFailed": "Âà†Èô§ÊïÖ‰∫ãÂ§±Ë¥•",
    "play": "ÂºÄÂßãÊ∏∏Êàè"
  },
  "newStory": {
    "title": "ÂàõÂª∫Êñ∞ÊïÖ‰∫ã",
    "editTitle": "ÁºñËæëÊïÖ‰∫ã",
    "storyTitle": "ÊïÖ‰∫ãÊ†áÈ¢ò",
    "storyFramework": "ÊïÖ‰∫ãËÉåÊôØ",
    "characterInfo": "ËßíËâ≤‰ø°ÊÅØ",
    "questionTitle": "‚ú® ‰º†Â•áÂÜíÈô©ÁöÑ‰∏ªÈ¢ò",
    "questionFramework": "‚ú® ‰Ω†ÁöÑÂÜíÈô©Â∞ÜÂú®ÊÄéÊ†∑Á•ûÂ•áÁöÑ‰ΩçÈù¢Â±ïÂºÄÔºü",
    "questionCharacter": "‚ú® Âú®ËøôÊÆµ‰∏çÊúΩ‰º†Â•á‰∏≠Ôºå‰Ω†ÂåñË∫´‰∏∫‰ΩïÁ≠âÂ≠òÂú®Ôºü",
    "titlePlaceholder": "‰∏∫‰Ω†ÁöÑÂè≤ËØóÂëΩÂêç",
    "frameworkPlaceholder": "ÊèèÁªò‰Ω†ÁöÑÂ•áÂπª‰∏ñÁïå",
    "characterPlaceholder": "Êè≠Á§∫‰Ω†ÁöÑËã±ÈõÑË∫´‰ªΩ",
    "create": "ÂºÄÂêØ‰º†Â•á‰πãÊóÖ",
    "creating": "Ê≠£Âú®ÁºñÁªáÊÇ®ÁöÑ‰º†Â•áÊïÖ‰∫ã...",
    "update": "Êõ¥Êñ∞ÊïÖ‰∫ã",
    "updating": "Êõ¥Êñ∞‰∏≠...",
    "cancel": "ÂèñÊ∂à",
    "fillAllFields": "ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖÂ°´Â≠óÊÆµ",
    "createFailed": "ÂàõÂª∫ÊïÖ‰∫ãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "updateFailed": "Êõ¥Êñ∞ÊïÖ‰∫ãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "updateSuccess": "ÊïÖ‰∫ãÊõ¥Êñ∞ÊàêÂäü"
  },
  "notFound": {
    "title": "ÂâçÊñπÁöÑÈÅìË∑ØÂ∞öÊú™ÂºÄÊîæ",
    "subtitle": "ËøôÁâáÂ•áÂπªÈ¢ÜÂüü‰ªçÂú®Âª∫ËÆæ‰∏≠",
    "message": "Â∞äÊï¨ÁöÑÂÜ•ÊÉ≥ÂÆ∂ÔºåÊÇ®ÊâÄÂØªÊâæÁöÑÈ≠îÊ≥ïÂç∑ËΩ¥‰ºº‰πéÂ∑≤Ë¢´ÈÅóÂ§±ÊàñÂ∞öÊú™Ë¢´ÂàõÈÄ†„ÄÇ",
    "backToHome": "ËøîÂõû",
    "exploreMore": "Á®çÂêéÂÜçÊù•Êé¢Á¥¢"
  },
  "game": {
    "fetchStoryFailed": "Ëé∑ÂèñÊïÖ‰∫ãËØ¶ÊÉÖÂ§±Ë¥•",
    "fetchStoryFailedRetry": "Ëé∑ÂèñÊïÖ‰∫ãËØ¶ÊÉÖÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "loadSessionFailed": "Âä†ËΩΩÂéÜÂè≤‰ºöËØùÂ§±Ë¥•",
    "loadSessionFailedRetry": "Âä†ËΩΩÂéÜÂè≤‰ºöËØùÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "initializeFailed": "Ê∏∏ÊàèÂàùÂßãÂåñÂ§±Ë¥•",
    "setupFailed": "Ê∏∏ÊàèËÆæÁΩÆÂ§±Ë¥•",
    "cannotReadResponseStream": "Êó†Ê≥ïËØªÂèñÂìçÂ∫îÊµÅ",
    "generatingStory": "Ê≠£Âú®ÁîüÊàêÊïÖ‰∫ã...",
    "actionFailed": "Ê∏∏ÊàèÊìç‰ΩúÂ§±Ë¥•",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÊïÖ‰∫ãÂêóÔºüËøô‰∏™Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
    "deleteFailed": "Âà†Èô§ÊïÖ‰∫ãÂ§±Ë¥•",
    "deleteFailedRetry": "Âà†Èô§ÊïÖ‰∫ãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "storyNotExist": "ÂéÜÂè≤ËÆ∞ÂΩïÊâÄÂ±ûÁöÑÊïÖ‰∫ã‰∏çÂ≠òÂú®",
    "cannotFindStory": "Êó†Ê≥ïÊâæÂà∞ID‰∏∫ {id} ÁöÑÊïÖ‰∫ã",
    "backToStoryList": "ËøîÂõûÊïÖ‰∫ãÂàóË°®",
    "expandSidebar": "Â±ïÂºÄ‰æßËæπÊ†è",
    "collapseSidebar": "Êî∂Ëµ∑‰æßËæπÊ†è",
    "storySummary": "ÊïÖ‰∫ãÊ¶ÇË¶Å",
    "storyFramework": "ÊïÖ‰∫ãÊ°ÜÊû∂",
    "characterInfo": "ËßíËâ≤‰ø°ÊÅØ",
    "starting": "ÂêØÂä®‰∏≠...",
    "startAdventure": "ÂºÄÂßãÂÜíÈô©",
    "inputCustomAction": "ËæìÂÖ•Ëá™ÂÆö‰πâÊìç‰Ωú...",
    "execute": "ÊâßË°å",
    "deleting": "Âà†Èô§‰∏≠...",
    "deleteStory": "Âà†Èô§ÊïÖ‰∫ã",
    "gameInfo": "Ê∏∏Êàè‰ø°ÊÅØ",
    "memoryManagement": "ËÆ∞ÂøÜÁÆ°ÁêÜ",
    "navigation": "ÂØºËà™",
    "collapse": "Êî∂Ëµ∑",
    "expand": "Â±ïÂºÄ",
    "memoryPlaceholder": "ËøôÈáåÂ∞ÜÊòæÁ§∫Ê∏∏ÊàèËÆ∞ÂøÜ",
    "memoryDescription": "ËÆ∞ÂøÜÁÆ°ÁêÜÂÖÅËÆ∏ÊÇ®Êü•ÁúãÂíåÁºñËæëÊ∏∏Êàè‰∏≠ÁöÑËÆ∞ÂøÜÁâáÊÆµ",
    "memoryInstructions": "ÁÇπÂáªËäÇÁÇπÊü•ÁúãÂÆåÊï¥ÂÜÖÂÆπÔºåËøûÁ∫øÊòæÁ§∫ÊÇ®ÁöÑÊìç‰Ωú",
    "editMemory": "ÁºñËæëËÆ∞ÂøÜ",
    "memorySummary": "ËÆ∞ÂøÜÊ¶ÇË¶Å",
    "fullMemoryContent": "ÂÆåÊï¥ËÆ∞ÂøÜÂÜÖÂÆπ",
    "editMemoryPlaceholder": "ÁºñËæëÊÇ®ÁöÑÊ∏∏ÊàèËÆ∞ÂøÜ...",
    "noSessionFound": "Êú™ÊâæÂà∞‰ºöËØù",
    "startSessionFirst": "ËØ∑ÂÖàÂºÄÂßã‰∏Ä‰∏™Ê∏∏Êàè‰ºöËØùÊâçËÉΩÊü•ÁúãËÆ∞ÂøÜ",
    "loadingMemories": "Ê≠£Âú®Âä†ËΩΩËÆ∞ÂøÜ...",
    "jumpToNode": "Ë∑≥ËΩ¨Âà∞Ê≠§ËäÇÁÇπ",
    "expandMemory": "Â±ïÂºÄËÆ∞ÂøÜÂÜÖÂÆπ"
  },
  "characterCardsPage": {
    "title": "ËßíËâ≤Âç°",
    "importCharacter": "ÂØºÂÖ•ËßíËâ≤",
    "importFirstCharacter": "ÂØºÂÖ•‰Ω†ÁöÑÁ¨¨‰∏Ä‰∏™ËßíËâ≤",
    "noCharacters": "‰Ω†ËøòÊ≤°Êúâ‰ªª‰ΩïËßíËâ≤",
    "loading": "Âä†ËΩΩ‰∏≠...",
    "downloadingPresets": "Ê≠£Âú®‰∏ãËΩΩÈ¢ÑËÆæËßíËâ≤...",
    "fetchError": "Ëé∑ÂèñËßíËâ≤Â§±Ë¥•",
    "deleteFailed": "Âà†Èô§ËßíËâ≤Â§±Ë¥•",
    "delete": "Âà†Èô§",
    "edit": "ÁºñËæë",
    "chat": "ËÅäÂ§©",
    "recentlyCreated": "ÊúÄËøëÂàõÂª∫",
    "downloadCharacter": "Á§æÂå∫‰∏ãËΩΩËßíËâ≤"
  },
  "editCharacterModal": {
    "title": "ÁºñËæëËßíËâ≤",
    "name": "ÂêçÁß∞",
    "description": "ÊèèËø∞",
    "personality": "ÊÄßÊ†º",
    "scenario": "Âú∫ÊôØ",
    "firstMessage": "ÂºÄÂú∫ÁôΩ",
    "mesExample": "Ê∂àÊÅØÁ§∫‰æã",
    "creatorComment": "ÂàõÂª∫ËÄÖÂ§áÊ≥®",
    "save": "‰øùÂ≠ò",
    "cancel": "ÂèñÊ∂à"
  },
  "importCharacterModal": {
    "title": "ÂØºÂÖ•ËßíËâ≤",
    "description": "ÈÄâÊã©ÊàñÊãñÊîæ SillyTavern Ê†ºÂºèÁöÑ PNG ËßíËâ≤Âç°Êñá‰ª∂ËøõË°åÂØºÂÖ•",
    "dragOrClick": "ÊãñÊîæÊñá‰ª∂Âà∞Ê≠§Â§ÑÊàñÁÇπÂáªÈÄâÊã©",
    "pngFormat": "‰ªÖÊîØÊåÅ SillyTavern Ê†ºÂºèÁöÑ PNG ËßíËâ≤Âç°Êñá‰ª∂",
    "pngOnly": "ËØ∑ÈÄâÊã© SillyTavern Ê†ºÂºèÁöÑ PNG Êñá‰ª∂",
    "noFileSelected": "ËØ∑ÂÖàÈÄâÊã©Êñá‰ª∂",
    "uploadFailed": "‰∏ä‰º†Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "import": "ÂØºÂÖ•",
    "uploading": "Ê≠£Âú®‰∏ä‰º†..."
  },
  "characterMarketPage": {
    "description": "Êé¢Á¥¢ÂêÑÁßçÁ≤æÂΩ©ËßíËâ≤Ôºå‰∏∫ÊÇ®ÁöÑÊïÖ‰∫ãÂ¢ûÊ∑ªÁîüÊú∫",
    "searchPlaceholder": "ÊêúÁ¥¢ËßíËâ≤ÂêçÁß∞ÊàñÊèèËø∞",
    "allTags": "ÂÖ®ÈÉ®",
    "loading": "Ê≠£Âú®Âä†ËΩΩËßíËâ≤...",
    "noResults": "Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑËßíËâ≤",
    "clearFilters": "Ê∏ÖÈô§Á≠õÈÄâÊù°‰ª∂",
    "by": "‰ΩúËÄÖÔºö",
    "download": "‰∏ãËΩΩËßíËâ≤",
    "viewDetails": "Êü•ÁúãËØ¶ÊÉÖ"
  },
  "characterChat": {
    "navigation": "ÂØºËà™",
    "characterInfo": "ËßíËâ≤‰ø°ÊÅØ",
    "actions": "Êìç‰Ωú",
    "expandSidebar": "Â±ïÂºÄ‰æßËæπÊ†è",
    "collapseSidebar": "Êî∂Ëµ∑‰æßËæπÊ†è",
    "backToCharacters": "ËøîÂõûËßíËâ≤ÂàóË°®",
    "Conversation": "ÂâßÊÉÖÂàÜÊîØÁÆ°ÁêÜ",
    "noPersonality": "Êú™ÂÆö‰πâÊÄßÊ†º",
    "typeMessage": "ËæìÂÖ•Ê∂àÊÅØ...",
    "startConversation": "ÂºÄÂßãÂØπËØù...",
    "send": "ÂèëÈÄÅ",
    "isTyping": "Ê≠£Âú®ËæìÂÖ•...",
    "suggestedResponse1": "ÂëäËØâÊàëÊõ¥Â§ö",
    "suggestedResponse2": "Êé•‰∏ãÊù•ÂèëÁîü‰∫Ü‰ªÄ‰πàÔºü",
    "suggestedResponse3": "‰Ω†ÂØπÊ≠§Êúâ‰ªÄ‰πàÊÑüÊÉ≥Ôºü",
    "promptMode": "ÊèêÁ§∫ËØçÊ®°Âºè",
    "companionMode": "ÂâßÊÉÖÊé®ËøõÊ®°Âºè",
    "nsfwMode": "‰∫≤ÂØÜÈô™‰º¥Ê®°Âºè",
    "explicitMode": "NSFWÊ®°Âºè",
    "customMode": "Ëá™ÂÆö‰πâÊ®°Âºè",
    "innerThought": "ÂÜÖÂøÉÊÉ≥Ê≥ï",
    "speech": "ÂØπËØù",
    "screen": "Âú∫ÊôØ",
    "nextPrompt": "‰∏ã‰∏ÄÊ≠•",
    "storyProgress": "ÂâßÊÉÖÊé®Ëøõ",
    "storyProgressHint": "Ôºà‰∏ã‰∏ÄÊ≠•Ê†πÊçÆÂÖ®ÈÉ®ÊúâÊïà‰ø°ÊÅØÊé®ËøõÊïÖ‰∫ãÂèëÂ±ïÔºâ",
    "perspective": "ËßÜËßíËÆæËÆ°",
    "novelPerspective": "Â∞èËØ¥ËßÜËßí",
    "protagonistPerspective": "‰∏ªËßíËßÜËßí",
    "novelPerspectiveHint": "Ôºà‰∏ãÊ¨°‰ª•Â∞èËØ¥‰∏äÂ∏ùËßÜËßíÂõûÂ§çÔºåÂøÖÈ°ªÂåÖÂê´ÂâßÈÄèÂßìÂêçÔºâ",
    "protagonistPerspectiveHint": "Ôºà‰∏ãÊ¨°‰ª•‰∏ªËßíËßÜËßíÂõûÂ§çÔºåÂøÖÈ°ª‰ΩøÁî®ÊàëÊàñËÄÖ‰∏ªËßíÁöÑÂÆûÈôÖÂêçÁß∞Ôºâ",
    "sceneTransition": "Âú∫ÊôØËøáÊ∏°",
    "sceneTransitionHint": "Ôºà‰∏ã‰∏ÄÊ¨°ËøõË°åËá™ÁÑ∂ÁöÑÂú∫ÊôØËøáÊ∏°ÔºåÂÆûÁé∞Âú∫ÊôØÂàáÊç¢Ôºâ",
    "screenPlaceholder": "ÊèèËø∞Âú∫ÊôØÊàñÂä®‰Ωú...",
    "speechPlaceholder": "ËßíËâ≤ËØ¥ÁöÑËØù...",
    "innerThoughtPlaceholder": "ËßíËâ≤ÂøÉÈáåÊÉ≥‰∫Ü‰ªÄ‰πà...",
    "playerInput": "Áé©ÂÆ∂ËæìÂÖ•Êåá‰ª§",
    "characterStatus": "ËßíËâ≤Áä∂ÊÄÅ",
    "responseInstructions": "ÂõûÂ§çÊèêÁ§∫",
    "responseLength": "Ê®°ÂûãÂõûÂ§çÈïøÂ∫¶",
    "customPrompt": "Ëá™ÂÆö‰πâÊèêÁ§∫ËØç",
    "customPromptFor": "Ëá™ÂÆö‰πâÊèêÁ§∫ËØç",
    "presets": "È¢ÑËÆæ",
    "presetEditor": "È¢ÑËÆæÁºñËæëÂô®",
    "githubPresets": "ÊèêÁ§∫ËØçÈÄâÊã©",
    "noPresets": "Ê≤°ÊúâÂèØÁî®ÁöÑÈ¢ÑËÆæ",
    "prefixPrompt": "ÂâçÁºÄÊèêÁ§∫ËØç",
    "chainOfThoughtPrompt": "ÊÄùÁª¥ÈìæÊèêÁ§∫ËØç",
    "suffixPrompt": "ÂêéÁºÄÊèêÁ§∫ËØç",
    "prefixPromptDescription": "ÂâçÁºÄÊèêÁ§∫ËØçÂ∞ÜÊîæÁΩÆÂú®ÊèêÁ§∫ËØçÁöÑÂºÄÂ§¥ÔºåÁî®‰∫éËÆæÁΩÆËßíËâ≤ÁöÑÂü∫Êú¨Ë°å‰∏∫ÂíåËÉåÊôØ„ÄÇ",
    "chainOfThoughtPromptDescription": "ÊÄùÁª¥ÈìæÊèêÁ§∫ËØçÂ∞ÜÊîæÁΩÆÂú®ÊèêÁ§∫ËØçÁöÑ‰∏≠Èó¥ÔºåÁî®‰∫éÊåáÂØºËßíËâ≤ÁöÑÊÄùËÄÉËøáÁ®ã„ÄÇ",
    "suffixPromptDescription": "ÂêéÁºÄÊèêÁ§∫ËØçÂ∞ÜÊîæÁΩÆÂú®ÊèêÁ§∫ËØçÁöÑÁªìÂ∞æÔºåÁî®‰∫éË°•ÂÖÖÈ¢ùÂ§ñÁöÑÊåáÂØºÂíåÈôêÂà∂„ÄÇ",
    "prefixPromptPlaceholder": "ËæìÂÖ•ÂâçÁºÄÊèêÁ§∫ËØç...",
    "chainOfThoughtPromptPlaceholder": "ËæìÂÖ•ÊÄùÁª¥ÈìæÊèêÁ§∫ËØç...",
    "suffixPromptPlaceholder": "ËæìÂÖ•ÂêéÁºÄÊèêÁ§∫ËØç...",
    "autoSaveEnabled": "Ëá™Âä®‰øùÂ≠òÂ∑≤ÂêØÁî®",
    "initializing": "Ê≠£Âú®ÂàùÂßãÂåñËßíËâ≤...",
    "extractingTemplate": "ÊèêÂèñÁä∂ÊÄÅÊ®°Êùø‰∏≠ÔºåËØ∑Á®çÂÄô...",
    "loadingTimeHint": "È¶ñÊ¨°Âä†ËΩΩÊó∂Èó¥Âú® 5-40 Áßí‰πãÈó¥ÔºåËßíËâ≤Âç°ÂÜÖÂÆπË∂äÂ§ßÂä†ËΩΩÊó∂Èó¥Ë∂äÈïøÔºåÂ¶ÇÊûúÈïøÊó∂Èó¥Êú™Âä†ËΩΩÔºåËØ∑Ê£ÄÊü• API ÈÖçÁΩÆÊòØÂê¶Ê≠£Á°Æ",
    "error": "ÈîôËØØ",
    "characterNotFound": "Êú™ÊâæÂà∞ËßíËâ≤",
    "loading":"Âä†ËΩΩ‰∏≠‚Ä¶‚Ä¶Ê≠£Âú®Ëß£ÊûêÁä∂ÊÄÅÔºåËØ∑Á®çÁ≠â‚Ä¶‚Ä¶",
    "worldBook": "‰∏ñÁïå‰π¶",
    "regex": "Ê≠£ÂàôËÑöÊú¨",
    "preset": "È¢ÑËÆæ",
    "enabled": "ÂêØÁî®",
    "disabled": "Á¶ÅÁî®",
    "filtered": "Á≠õÈÄâ",
    "advancedSettings": "È´òÁ∫ßËÆæÁΩÆ",
    "tagColorEditor": "Ê†áÁ≠æÈ¢úËâ≤ÁºñËæëÂô®",
    "enterTagName": "ËæìÂÖ•Ê†áÁ≠æÂêçÁß∞...",
    "add": "Ê∑ªÂä†",
    "saveChanges": "‰øùÂ≠òÊõ¥Êîπ",
    "enterSymbol": "ÂΩìËæìÂÖ• tag Êó∂ÔºåÂ∞ÜÂØπ<tag>...</tag>ËøõË°åÂåπÈÖç",
    "enableStreaming": "ÂêØÁî®ÊµÅÂºèËæìÂá∫",
    "disableStreaming": "Á¶ÅÁî®ÊµÅÂºèËæìÂá∫",
    "jumpToMessage": "Ë∑≥ËΩ¨Âà∞Ê≠§Ê∂àÊÅØ",
    "regenerateMessage": "ÈáçÊñ∞ÁîüÊàêÊ∂àÊÅØ",
    "enableFastModel": "ÂºÄÂêØÂø´ÈÄüÊ®°Âºè",
    "disableFastModel": "ÂÖ≥Èó≠Âø´ÈÄüÊ®°Âºè"
  },
  "preset": {
    "title": "È¢ÑËÆæÁºñËæëÂô®",
    "createPreset": "ÂàõÂª∫È¢ÑËÆæ",
    "importPreset": "ÂØºÂÖ•È¢ÑËÆæ",
    "sortBy": "ÊéíÂ∫èÊñπÂºè",
    "sortOrder": "ÊéíÂ∫èÈ°∫Â∫è",
    "filterBy": "Á≠õÈÄâÊñπÂºè",
    "ascending": "ÂçáÂ∫è",
    "descending": "ÈôçÂ∫è",
    "asc": "ÂçáÂ∫è",
    "desc": "ÈôçÂ∫è",
    "all": "ÂÖ®ÈÉ®",
    "active": "ÊúâÊèêÁ§∫ËØç",
    "empty": "Á©∫ÁôΩ",
    "name": "ÂêçÁß∞",
    "promptCount": "ÊèêÁ§∫ËØçÊï∞Èáè",
    "lastUpdated": "ÊúÄÂêéÊõ¥Êñ∞",
    "status": "Áä∂ÊÄÅ",
    "prompts": "ÊèêÁ§∫ËØç",
    "updated": "Êõ¥Êñ∞Êó∂Èó¥",
    "actions": "Êìç‰Ωú",
    "active_status": "Ê¥ªË∑É",
    "empty_status": "Á©∫ÁôΩ",
    "total": "ÊÄªËÆ°",
    "enabled": "ÂêØÁî®",
    "disabled": "Á¶ÅÁî®",
    "filtered": "Á≠õÈÄâÁªìÊûú",
    "loading": "Âä†ËΩΩÈ¢ÑËÆæ‰∏≠...",
    "noPresetsFound": "Êú™ÊâæÂà∞È¢ÑËÆæ",
    "createFirstPreset": "ÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™È¢ÑËÆæÂºÄÂßã‰ΩøÁî®",
    "enterPresetName": "ËæìÂÖ•È¢ÑËÆæÂêçÁß∞Ôºö",
    "createSuccess": "È¢ÑËÆæÂàõÂª∫ÊàêÂäü",
    "createFailed": "ÂàõÂª∫È¢ÑËÆæÂ§±Ë¥•",
    "deleteConfirm": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™È¢ÑËÆæÂêóÔºü",
    "deleteSuccess": "È¢ÑËÆæÂà†Èô§ÊàêÂäü",
    "deleteFailed": "Âà†Èô§È¢ÑËÆæÂ§±Ë¥•",
    "loadFailed": "Âä†ËΩΩÈ¢ÑËÆæÂ§±Ë¥•",
    "loadDetailsFailed": "Âä†ËΩΩÈ¢ÑËÆæËØ¶ÊÉÖÂ§±Ë¥•",
    "expandDetails": "Â±ïÂºÄËØ¶ÊÉÖ",
    "collapseDetails": "Êî∂Ëµ∑ËØ¶ÊÉÖ",
    "promptsTitle": "ÊèêÁ§∫ËØç",
    "addPrompt": "Ê∑ªÂä†ÊèêÁ§∫ËØç",
    "enterPromptName": "ËæìÂÖ•ÊèêÁ§∫ËØçÂêçÁß∞Ôºö",
    "addPromptSuccess": "ÊèêÁ§∫ËØçÊ∑ªÂä†ÊàêÂäü",
    "addPromptFailed": "Ê∑ªÂä†ÊèêÁ§∫ËØçÂ§±Ë¥•",
    "deletePromptConfirm": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÊèêÁ§∫ËØçÂêóÔºü",
    "deletePromptSuccess": "ÊèêÁ§∫ËØçÂà†Èô§ÊàêÂäü",
    "deletePromptFailed": "Âà†Èô§ÊèêÁ§∫ËØçÂ§±Ë¥•",
    "noPromptsInPreset": "Ê≠§È¢ÑËÆæ‰∏≠Ê≤°ÊúâÊèêÁ§∫ËØç",
    "enabled_prompt": "Â∑≤ÂêØÁî®",
    "disabled_prompt": "Â∑≤Á¶ÅÁî®",
    "system": "Á≥ªÁªü",
    "deletePrompt": "Âà†Èô§ÊèêÁ§∫ËØç",
    "promptEnabledSuccess": "ÊèêÁ§∫ËØçÂ∑≤ÊàêÂäüÂêØÁî®",
    "promptDisabledSuccess": "ÊèêÁ§∫ËØçÂ∑≤ÊàêÂäüÁ¶ÅÁî®",
    "togglePromptFailed": "ÂàáÊç¢ÊèêÁ§∫ËØçÁä∂ÊÄÅÂ§±Ë¥•",
    "applyPresetSuccess": "È¢ÑËÆæÂ∫îÁî®ÊàêÂäü",
    "applyPresetFailed": "Â∫îÁî®È¢ÑËÆæÂ§±Ë¥•",
    "applyPreset": "Â∫îÁî®È¢ÑËÆæ",
    "presetApplied": "È¢ÑËÆæÂ∑≤ÊøÄÊ¥ª",
    "cannotApplyEmpty": "Êó†Ê≥ïÂ∫îÁî®Á©∫È¢ÑËÆæ",
    "enablePreset": "ÂêØÁî®È¢ÑËÆæ",
    "disablePreset": "Á¶ÅÁî®È¢ÑËÆæ",
    "presetEnabledSuccess": "È¢ÑËÆæÂ∑≤ÊàêÂäüÂêØÁî®",
    "presetEnabledExclusiveSuccess": "È¢ÑËÆæÂ∑≤ÊàêÂäüÂêØÁî®ÔºàÂÖ∂‰ªñÈ¢ÑËÆæÂ∑≤Ëá™Âä®Á¶ÅÁî®Ôºâ",
    "presetDisabledSuccess": "È¢ÑËÆæÂ∑≤ÊàêÂäüÁ¶ÅÁî®",
    "togglePresetFailed": "ÂàáÊç¢È¢ÑËÆæÁä∂ÊÄÅÂ§±Ë¥•",
    "presetDisabled": "È¢ÑËÆæÂ∑≤Á¶ÅÁî®",
    "cannotApplyDisabled": "Êó†Ê≥ïÂ∫îÁî®Â∑≤Á¶ÅÁî®ÁöÑÈ¢ÑËÆæ",
    "toggle": "ÂºÄÂÖ≥",
    "presetName": "È¢ÑËÆæÂêçÁß∞",
    "presetNamePlaceholder": "ËæìÂÖ•È¢ÑËÆæÂêçÁß∞",
    "presetNameRequired": "È¢ÑËÆæÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫",
    "creating": "ÂàõÂª∫‰∏≠...",
    "create": "ÂàõÂª∫",
    "cancel": "ÂèñÊ∂à",
    "editPrompt": "ÁºñËæëÊèêÁ§∫ËØç",
    "promptContent": "ÊèêÁ§∫ËØçÂÜÖÂÆπ",
    "saving": "‰øùÂ≠ò‰∏≠"
  },
  "importPreset": {
    "title": "ÂØºÂÖ•È¢ÑËÆæ",
    "dragDropFile": "ÂØºÂÖ•È¢ÑËÆæÊñá‰ª∂",
    "dropFileHere": "Â∞ÜÊñá‰ª∂ÊãñÊãΩÂà∞ËøôÈáå",
    "browseFiles": "ÊµèËßàÊñá‰ª∂",
    "dragAndDrop": "ÊãñÊãΩJSONÈ¢ÑËÆæÊñá‰ª∂Âà∞Ê≠§Â§ÑÔºåÊàñÁÇπÂáªÊµèËßà",
    "importing": "ÂØºÂÖ•‰∏≠...",
    "importSuccess": "ÂØºÂÖ•ÊàêÂäü",
    "importFailed": "ÂØºÂÖ•Â§±Ë¥•",
    "presetImported": "È¢ÑËÆæÂ∑≤ÊàêÂäüÂØºÂÖ•ÔºÅ",
    "importError": "ÂØºÂÖ•ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ",
    "customizePreset": "Ëá™ÂÆö‰πâÈ¢ÑËÆæ",
    "presetName": "È¢ÑËÆæÂêçÁß∞",
    "presetNameDesc": "ÁïôÁ©∫‰ª•‰ΩøÁî®Êñá‰ª∂ÂéüÂßãÂêçÁß∞",
    "confirmImport": "Á°ÆËÆ§ÂØºÂÖ•",
    "guidelines": "ÂØºÂÖ•ÊåáÂçó",
    "jsonFormat": "È¢ÑËÆæÊñá‰ª∂ÂøÖÈ°ª‰∏∫JSONÊ†ºÂºè",
    "validStructure": "Êñá‰ª∂Â∫îÂåÖÂê´ÊúâÊïàÁöÑÈ¢ÑËÆæÁªìÊûÑÂíåÊèêÁ§∫ËØç",
    "noOverwrite": "‰∏ç‰ºöË¶ÜÁõñÂêåÂêçÁöÑÁé∞ÊúâÈ¢ÑËÆæ",
    "maxFileSize": "ÊúÄÂ§ßÊñá‰ª∂Â§ßÂ∞èÔºö10MB",
    "selectJsonFile": "ËØ∑ÈÄâÊã©JSONÊñá‰ª∂",
    "failedToImport": "ÂØºÂÖ•Â§±Ë¥•",
    "cancel": "ÂèñÊ∂à",
    "save": "‰øùÂ≠ò"
  },
  "dialogue": {
    "treeVisualization": "ÂâßÊÉÖÂàÜÊîØÁÆ°ÁêÜ",
    "node": "ÂØπËØùËäÇÁÇπ",
    "systemMessage": "Á≥ªÁªüÊ∂àÊÅØ",
    "jumpToNode": "Ë∑≥ËΩ¨Âà∞ËäÇÁÇπ",
    "expandNode": "Â±ïÂºÄËäÇÁÇπ",
    "editNode": "ÁºñËæëËäÇÁÇπ",
    "userInput": "Áî®Êà∑ËæìÂÖ•",
    "assistantResponse": "Âä©ÊâãÂõûÂ§ç",
    "noCharacterSelected": "Êú™ÈÄâÊã©ËßíËâ≤",
    "selectCharacterFirst": "ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ËßíËâ≤",
    "loadingDialogue": "Ê≠£Âú®Âä†ËΩΩÂØπËØùÊï∞ÊçÆ...",
    "noDialogueNodes": "Ê≤°ÊúâÂØπËØùËäÇÁÇπ",
    "startConversation": "ÂºÄÂßãÂØπËØù‰ª•ÂàõÂª∫ÂØπËØùÊ†ë",
    "memorySummary": "ËÆ∞ÂøÜÊëòË¶Å",
    "nodeId": "ËäÇÁÇπID",
    "startingPoint": "ÂºÄÂ±Ä",
    "rootNodeCannotJump": "Ê†πËäÇÁÇπÊòØÂØπËØùÁöÑËµ∑ÁÇπÔºå‰∏çËÉΩË∑≥ËΩ¨",
    "response": "ÂõûÂ§çÂÜÖÂÆπ",
    "responsePlaceholder": "ÁºñËæëÂõûÂ§çÂÜÖÂÆπ...",
    "resetLayout": "ÈáçÁΩÆÂ∏ÉÂ±Ä",
    "manualPositions": "ÊâãÂä®‰ΩçÁΩÆ"
  },  
  "downloadModal": {
      "title": "‰ªéÁ§æÂå∫‰ªìÂ∫ì‰∏ãËΩΩËßíËâ≤",
      "loading": "Âä†ËΩΩ‰∏≠‚Ä¶",
      "fetchError": "Êó†Ê≥ïËé∑ÂèñËßíËâ≤ÂàóË°®",
      "downloadFailed": "‰∏ãËΩΩÂ§±Ë¥•",
      "importFailed": "ÂØºÂÖ•Â§±Ë¥•",
      "importing": "ÂØºÂÖ•‰∏≠‚Ä¶",
      "downloadAndImport": "‰∏ãËΩΩÂπ∂ÂØºÂÖ•",
      "by": "‰ΩúËÄÖÔºö",
      "unknownAuthor": "‰ΩöÂêç"
  },
  "creatorInput": {
    "title": "Creator Studio",
    "subtitle": "ÂºÄÂßãÂàõ‰ΩúÂè≤ËØóÁ∫ßÁöÑÊïÖ‰∫ã",
    "placeholder": "ËæìÂÖ•ÊÇ®ÁöÑÂàõ‰ΩúÊÉ≥Ê≥ï...",
    "sendMessage": "ÂèëÈÄÅÊ∂àÊÅØ",
    "enterToSend": "Êåâ Enter ÂèëÈÄÅÔºåShift + Enter Êç¢Ë°å",
    "characterCount": "{count}/1000",
    "exampleStories": "„ÄäËçíÈáéÊ±ÇÁîü„Äã„ÄÅ„ÄäÂìàÂà©Ê≥¢Áâπ„Äã„ÄÅ„ÄäÈ≠îÊàí„ÄãÔºå‰ªª‰ΩïÊïÖ‰∫ãÈöèÂøÉËÄåÂä®"
  },
  "worldBook": {
    "title": "‰∏ñÁïå‰π¶",
    "addEntry": "Ê∑ªÂä†Êù°ÁõÆ",
    "sortBy": "ÊéíÂ∫èÊñπÂºè",
    "sortOrder": "ÊéíÂ∫èÈ°∫Â∫è",
    "asc": "ÂçáÂ∫è",
    "desc": "ÈôçÂ∫è",
    "importing": "ÂØºÂÖ•‰∏≠",
    "imported": "ÂÖ®Â±Ä",
    "importedAt": "ÂØºÂÖ•Êó∂Èó¥:",
    "saveAsGlobalWorldBook": "‰øùÂ≠ò‰∏∫ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "globalName": "ÂÖ®Â±ÄÂêçÁß∞",
    "description": "ÊèèËø∞ÔºàÂèØÈÄâÔºâ",
    "enterGlobalWorldBookName": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÊñá‰ª∂ÂêçÁß∞",
    "enterDescriptionForThisGlobalWorldBook": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÁ©∫ÊèèËø∞",
    "importWorldBook": "ÂØºÂÖ•‰∏ñÁïå‰π¶",
    "dragDropJson": "ÊãñÊãΩJSONÊñá‰ª∂Âà∞Ê≠§Â§Ñ",
    "jsonFileOnly": "‰ªÖÊîØÊåÅJSONÊñá‰ª∂",
    "importResults": "ÂØºÂÖ•ÁªìÊûú",
    "importedEntries": "Â∑≤ÂØºÂÖ• {count} ‰∏™Êù°ÁõÆ",
    "skippedEntries": "Ë∑≥Ëøá {count} ‰∏™Êù°ÁõÆ",
    "importErrors": "ÂØºÂÖ•ÈîôËØØ",
    "loading": "Âä†ËΩΩ‰∏ñÁïå‰π¶Êï∞ÊçÆ...",
    "noEntries": "ÊöÇÊó†‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "noEntriesDescription": "ÁÇπÂáªÊñ∞Âª∫Êù°ÁõÆÂºÄÂßãÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "createEntry": "Êñ∞Âª∫Êù°ÁõÆ",
    "editEntry": "ÁºñËæë‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "newEntry": "Êñ∞Âª∫‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "deleteEntry": "Âà†Èô§Êù°ÁõÆ",
    "bulkOperations": "ÊâπÈáèÊìç‰Ωú",
    "enableAll": "ÂÖ®ÈÉ®ÂêØÁî®",
    "disableAll": "ÂÖ®ÈÉ®Á¶ÅÁî®",
    "enableDisabled": "ÂêØÁî®Á¶ÅÁî®ÁöÑ",
    "disableEnabled": "Á¶ÅÁî®ÂêØÁî®ÁöÑ",
    "enabledAll": "Â∑≤ÂêØÁî®ÂÖ®ÈÉ®",
    "disabledAll": "Â∑≤Á¶ÅÁî®ÂÖ®ÈÉ®",
    "noEntriesWithStatus": "Ê≤°ÊúâÊâæÂà∞Áä∂ÊÄÅ‰∏∫{status}ÁöÑÊù°ÁõÆ",
    "bulkEnable": "ÊâπÈáèÂêØÁî®",
    "bulkDisable": "ÊâπÈáèÁ¶ÅÁî®",
    "bulkDelete": "ÊâπÈáèÂà†Èô§",
    "selectAll": "ÂÖ®ÈÄâ",
    "selectEntriesFirst": "ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÊìç‰ΩúÁöÑÊù°ÁõÆ",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Êù°ÁõÆÂêóÔºü",
    "saveSuccess": "‰øùÂ≠òÊàêÂäü",
    "saveFailed": "‰øùÂ≠òÂ§±Ë¥•",
    "deleteSuccess": "Âà†Èô§ÊàêÂäü",
    "deleteFailed": "Âà†Èô§Â§±Ë¥•",
    "bulkOperationFailed": "ÊâπÈáèÊìç‰ΩúÂ§±Ë¥•",
    "toggleFailed": "ÂàáÊç¢Áä∂ÊÄÅÂ§±Ë¥•",
    "enableEntry": "ÂêØÁî®Êù°ÁõÆ",
    "disableEntry": "Á¶ÅÁî®Êù°ÁõÆ",
    "toggle": "ÂºÄÂÖ≥",
    "item": "Êù°",
    "confirmBulkDisable": "Ê≠§Êìç‰ΩúÂ∞ÜÁ¶ÅÁî®ÊâÄÊúâÊù°ÁõÆ",
    "keywordRequired": "Ëá≥Â∞ëÈúÄË¶Å‰∏Ä‰∏™ÂÖ≥ÈîÆËØç",
    "contentRequired": "ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫",
    "totalCount": "ÊÄªËÆ°:",
    "enabledCount": "ÂêØÁî®:",
    "disabledCount": "Á¶ÅÁî®:",
    "selectedItems": "Â∑≤ÈÄâÊã©",
    "items": "È°π",
    "contextWindow": "‰∏ä‰∏ãÊñáÁ™óÂè£:",
    "status": "Áä∂ÊÄÅ",
    "comment": "Ê≥®Èáä",
    "keywords": "ÂÖ≥ÈîÆËØç",
    "position": "‰ΩçÁΩÆ",
    "depth": "Ê∑±Â∫¶",
    "characterCount": "Â≠óÁ¨¶Êï∞",
    "priority": "‰ºòÂÖàÁ∫ß",
    "actions": "Êìç‰Ωú",
    "enabled": "ÂêØÁî®",
    "disabled": "Á¶ÅÁî®",
    "regex": "Ê≠£Âàô",
    "constant": "Â∏∏Èáè",
    "noComment": "Êó†Ê≥®Èáä",
    "edit": "ÁºñËæë",
    "delete": "Âà†Èô§",
    "contentPreview": "ÂÜÖÂÆπÈ¢ÑËßà",
    "noContent": "Êó†ÂÜÖÂÆπ",
    "secondaryKeywords": "Ê¨°Ë¶ÅÂÖ≥ÈîÆËØç",
    "selectiveMatching": "ÈÄâÊã©ÊÄßÂåπÈÖç:",
    "tokenCount": "‰ª§ÁâåÊï∞:",
    "lastUpdated": "ÊúÄÂêéÊõ¥Êñ∞:",
    "totalKeywords": "ÂÖ≥ÈîÆËØçÊÄªÊï∞:",
    "notCalculated": "Êú™ËÆ°ÁÆó",
    "yes": "ÊòØ",
    "no": "Âê¶",
    "commentTitle": "Ê≥®Èáä/Ê†áÈ¢ò",
    "commentPlaceholder": "ËæìÂÖ•Ê≥®ÈáäÊàñÊ†áÈ¢ò",
    "insertionOrder": "ÊèíÂÖ•È°∫Â∫è",
    "primaryKeywords": "‰∏ªË¶ÅÂÖ≥ÈîÆËØç",
    "keywordPlaceholder": "ËæìÂÖ•ÂÖ≥ÈîÆËØç",
    "addKeyword": "Ê∑ªÂä†ÂÖ≥ÈîÆËØç",
    "removeKeyword": "ÁßªÈô§ÂÖ≥ÈîÆËØç",
    "depthLabel": "Ê∑±Â∫¶",
    "enabledLabel": "ÂêØÁî®",
    "regexLabel": "Ê≠£ÂàôË°®ËææÂºè",
    "selectiveLabel": "ÈÄâÊã©ÊÄßÂåπÈÖç",
    "constantLabel": "Â∏∏ÈáèÊù°ÁõÆ",
    "contentLabel": "ÂÜÖÂÆπ",
    "contentPlaceholder": "ËæìÂÖ•‰∏ñÁïå‰π¶ÂÜÖÂÆπ...",
    "characters": "Â≠óÁ¨¶",
    "save": "‰øùÂ≠ò",
    "cancel": "ÂèñÊ∂à",
    "saving": "‰øùÂ≠ò‰∏≠...",
    "positionOptions": {
      "systemPromptStart": "Á≥ªÁªüÊèêÁ§∫ÂºÄÂ§¥",
      "afterSystemPrompt": "Á≥ªÁªüÊèêÁ§∫‰πãÂêé",
      "userMessageStart": "Áî®Êà∑Ê∂àÊÅØÂºÄÂ§¥",
      "afterResponseMode": "ÂìçÂ∫îÊ®°ÂºèÂ£∞Êòé‰πãÂêé",
      "basedOnDepth": "Âü∫‰∫éÊ∑±Â∫¶"
    },
    "importFromJson": "‰ªéJSONÂØºÂÖ•",
    "importValidationFailed": "ÂØºÂÖ•È™åËØÅÂ§±Ë¥•",
    "selectJsonFile": "ÈÄâÊã©JSONÊñá‰ª∂",
    "importFromGlobal": "‰ªéÂÖ®Â±Ä‰∏ñÁïå‰π¶ÂØºÂÖ•",
    "noGlobalWorldBooks": "ÊöÇÊó†ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "createGlobalWorldBookFirst": "ËØ∑ÂÖàÂàõÂª∫ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "selectGlobalWorldBook": "ÈÄâÊã©ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "entryCount": "Êù°ÁõÆÊï∞Èáè",
    "createdAt": "ÂàõÂª∫Êó∂Èó¥",
    "sourceCharacter": "Êù•Ê∫êËßíËâ≤",
    "filterBy": "Á≠õÈÄâÊñπÂºè",
    "filterAll": "ÂÖ®ÈÉ®",
    "filterEnabled": "Â∑≤ÂêØÁî®",
    "filterDisabled": "Â∑≤Á¶ÅÁî®",
    "filterImported": "ÂÖ®Â±Ä",
    "filteredCount": "Á≠õÈÄâÁªìÊûú",
    "ascending": "ÂçáÂ∫è",
    "descending": "ÈôçÂ∫è",
    "fullscreenContent": "Â§ßÁ™óÂè£ÁºñËæë",
    "exitFullscreen": "ÂÖ≥Èó≠ÁºñËæëÂô®"
  },
  "regexScriptEditor": {
    "title": "Ê≠£ÂàôËÑöÊú¨ÁºñËæëÂô®",
    "close": "ÂÖ≥Èó≠",
    "settings": "ËÆæÁΩÆ",
    "enableProcessing": "ÂêØÁî®Ê≠£ÂàôÂ§ÑÁêÜ",
    "applyToPrompts": "Â∫îÁî®Âà∞ÊèêÁ§∫ËØç",
    "applyToResponses": "Â∫îÁî®Âà∞ÂõûÂ§ç",
    "addNewScript": "Ê∑ªÂä†Êñ∞ËÑöÊú¨",
    "existingScripts": "Áé∞ÊúâËÑöÊú¨",
    "noScripts": "ÊöÇÊó†ËÑöÊú¨",
    "noScriptsDescription": "ÁÇπÂáªÊ∑ªÂä†Êñ∞ËÑöÊú¨ÂºÄÂßãÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™Ê≠£ÂàôËÑöÊú¨",
    "priority": "‰ºòÂÖàÁ∫ß",
    "edit": "ÁºñËæë",
    "enable": "ÂêØÁî®",
    "disable": "Á¶ÅÁî®",
    "delete": "Âà†Èô§",
    "replace": "ÊõøÊç¢",
    "findRegex": "Êü•ÊâæÊ≠£Âàô",
    "replaceString": "ÊõøÊç¢Â≠óÁ¨¶‰∏≤",
    "trimStrings": "‰øÆÂâ™Â≠óÁ¨¶‰∏≤",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ËÑöÊú¨ÂêóÔºü",
    "deleteError": "Âà†Èô§ËÑöÊú¨Â§±Ë¥•",
    "newScript": "Êñ∞Âª∫ËÑöÊú¨",
    "editScript": "ÁºñËæëËÑöÊú¨",
    "scriptName": "ËÑöÊú¨ÂêçÁß∞",
    "scriptNamePlaceholder": "ËæìÂÖ•ËÑöÊú¨ÂêçÁß∞",
    "findRegexPlaceholder": "/pattern/flags Êàñ pattern",
    "replaceStringPlaceholder": "ÊõøÊç¢ÊñáÊú¨ (‰ΩøÁî® $1, $2 Ë°®Á§∫ÂàÜÁªÑ)",
    "disabled": "Á¶ÅÁî®",
    "enabled": "ÂêØÁî®",
    "cancel": "ÂèñÊ∂à",
    "save": "‰øùÂ≠ò",
    "saving": "‰øùÂ≠ò‰∏≠...",
    "loading": "Âä†ËΩΩ‰∏≠...",
    "requiredFields": "ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖÂ°´Â≠óÊÆµ",
    "saveError": "‰øùÂ≠òËÑöÊú¨Â§±Ë¥•",
    "totalCount": "ÊÄªËÆ°",
    "enabledCount": "ÂêØÁî®",
    "disabledCount": "Á¶ÅÁî®",
    "filteredCount": "Á≠õÈÄâÁªìÊûú",
    "sortBy": "ÊéíÂ∫èÊñπÂºè",
    "sortOrder": "ÊéíÂ∫èÈ°∫Â∫è",
    "asc": "ÂçáÂ∫è",
    "desc": "ÈôçÂ∫è",
    "ascending": "ÂçáÂ∫è",
    "descending": "ÈôçÂ∫è",
    "filterBy": "Á≠õÈÄâÊñπÂºè",
    "filterAll": "ÂÖ®ÈÉ®",
    "filterEnabled": "Â∑≤ÂêØÁî®",
    "filterDisabled": "Â∑≤Á¶ÅÁî®",
    "filterImported": "ÂÖ®Â±Ä",
    "name": "ÂêçÁß∞",
    "status": "Áä∂ÊÄÅ",
    "globalEnabled": "ÂÖ®Â±ÄÂêØÁî®",
    "applyToPrompt": "Â∫îÁî®Âà∞ÊèêÁ§∫ËØç",
    "applyToResponse": "Â∫îÁî®Âà∞ÂõûÂ§ç",
    "yes": "ÊòØ",
    "no": "Âê¶",
    "importScript": "ÂØºÂÖ•ËÑöÊú¨",
    "importRegexScript": "ÂØºÂÖ•Ê≠£ÂàôËÑöÊú¨",
    "importFromJson": "‰ªéJSONÂØºÂÖ•",
    "importFromGlobal": "‰ªéÂÖ®Â±ÄÂØºÂÖ•",
    "dragDropJson": "ÊãñÊãΩJSONÊñá‰ª∂Âà∞Ê≠§Â§Ñ",
    "jsonFileOnly": "‰ªÖÊîØÊåÅJSONÊñá‰ª∂",
    "saveAsGlobalRegexScript": "‰øùÂ≠ò‰∏∫ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "globalName": "ÂÖ®Â±ÄÂêçÁß∞",
    "description": "ÊèèËø∞",
    "enterGlobalRegexScriptName": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÊñá‰ª∂ÂêçÁß∞",
    "enterDescriptionForThisGlobalRegexScript": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÁ©∫ÊèèËø∞",
    "importing": "ÂØºÂÖ•‰∏≠...",
    "importResults": "ÂØºÂÖ•ÁªìÊûú",
    "importedScripts": "Â∑≤ÂØºÂÖ• {count} ‰∏™ËÑöÊú¨",
    "skippedScripts": "Ë∑≥Ëøá {count} ‰∏™ËÑöÊú¨",
    "importErrors": "ÂØºÂÖ•ÈîôËØØ",
    "noGlobalRegexScripts": "ÊöÇÊó†ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "createGlobalRegexScriptFirst": "ËØ∑ÂÖàÂàõÂª∫ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "selectGlobalRegexScript": "ÈÄâÊã©ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "willUseEachFileName": "Â∞Ü‰ΩøÁî®ÊØè‰∏™Êñá‰ª∂ÁöÑÂêçÁß∞‰Ωú‰∏∫ËÑöÊú¨ÂêçÁß∞"
  },
  "tour": {
    "welcome": "Ê¨¢Ëøé‰ΩøÁî® Narratium",
    "welcomeDescription": "Narratium ÊòØ‰∏Ä‰∏™Êô∫ËÉΩËßíËâ≤ÂØπËØùÂπ≥Âè∞ÔºåÊÇ®ÂèØ‰ª•‰∏éÂêÑÁßçAIËßíËâ≤ËøõË°åÊ∑±Â∫¶ÂØπËØùÔºåÂàõÈÄ†Áã¨ÁâπÁöÑÊïÖ‰∫ã‰ΩìÈ™å„ÄÇËÆ©Êàë‰ª¨ÂÖà‰∫ÜËß£‰∏Ä‰∏ãÂü∫Êú¨ÂäüËÉΩ„ÄÇ",
    "loginTitle": "È¶ñÂÖàÁôªÂΩïË¥¶Êà∑",
    "loginDescription": "ÁÇπÂáªËøôÈáåÁôªÂΩï„ÄÇËØ∑Ê≥®ÊÑèÔºöÊÇ®ËæìÂÖ•ÁöÑÁî®Êà∑ÂêçÂèØËÉΩ‰ºöË¢´AIËßíËâ≤Áî®‰Ωú‰∏ªËßíÂêçÁß∞ÔºåÊâÄ‰ª•Âª∫ËÆÆ‰ΩøÁî®ÊÇ®Â∏åÊúõÂú®ÊïÖ‰∫ã‰∏≠‰ΩøÁî®ÁöÑÂêçÂ≠ó„ÄÇ",
    "settingsTitle": "ÈÖçÁΩÆAIÊ®°Âûã",
    "settingsDescription": "ÁôªÂΩïÂêéÔºåÁÇπÂáªÂè≥‰∏äËßíÁöÑËÆæÁΩÆÊåâÈíÆÊù•ÈÖçÁΩÆÊÇ®ÁöÑAIÊ®°Âûã„ÄÇÊÇ®ÂèØ‰ª•ÈÄâÊã©OpenAIÊàñOllamaÔºåÂπ∂ËÆæÁΩÆÁõ∏Â∫îÁöÑAPIÂØÜÈí•ÂíåÊ®°ÂûãÂèÇÊï∞„ÄÇ",
    "worldbookTitle": "‰∏ñÁïå‰π¶ÂäüËÉΩ",
    "worldbookDescription": "‰∏ñÁïå‰π¶Áî®‰∫éÂÆö‰πâËßíËâ≤ÁöÑËÉåÊôØ‰∏ñÁïå„ÄÅËÆæÂÆöÂíåÈáçË¶Å‰ø°ÊÅØ„ÄÇAI‰ºöÊ†πÊçÆ‰∏ñÁïå‰π¶‰∏≠ÁöÑÂÜÖÂÆπÊù•‰øùÊåÅËßíËâ≤ËÆæÂÆöÁöÑ‰∏ÄËá¥ÊÄßÔºåËÆ©ÂØπËØùÊõ¥Âä†Ê≤âÊµ∏„ÄÇ",
    "regexTitle": "Ê≠£ÂàôËÑöÊú¨",
    "regexDescription": "Ê≠£ÂàôËÑöÊú¨ÂÖÅËÆ∏ÊÇ®Ëá™ÂÆö‰πâAIÂõûÂ§çÁöÑÊ†ºÂºèÂíåÂ§ÑÁêÜÈÄªËæë„ÄÇÊÇ®ÂèØ‰ª•ËÆæÁΩÆÁâπÊÆäÁöÑÊñáÊú¨ÊõøÊç¢ËßÑÂàôÔºåËÆ©ËßíËâ≤ÁöÑË°®ËææÊñπÂºèÊõ¥Âä†Áã¨Áâπ„ÄÇ",
    "presetTitle": "È¢ÑËÆæÁÆ°ÁêÜ",
    "presetDescription": "È¢ÑËÆæÂäüËÉΩËÆ©ÊÇ®ÂèØ‰ª•‰øùÂ≠òÂíåÁÆ°ÁêÜ‰∏çÂêåÁöÑÂØπËØùËÆæÁΩÆÔºåÂåÖÊã¨ËßíËâ≤ÁöÑËØ≠Ê∞î„ÄÅÈ£éÊ†ºÂíåÁâπÊÆäÊåá‰ª§ÔºåÊñπ‰æøÂú®‰∏çÂêåÂú∫ÊôØ‰∏ãÂø´ÈÄüÂàáÊç¢„ÄÇ",
    "chatTitle": "ÂºÄÂßãÂØπËØù",
    "chatDescription": "Áé∞Âú®ÊÇ®ÂèØ‰ª•Âú®ËæìÂÖ•Ê°Ü‰∏≠ËæìÂÖ•Ê∂àÊÅØÔºåÂºÄÂßã‰∏éAIËßíËâ≤ÁöÑÁ≤æÂΩ©ÂØπËØù‰∫ÜÔºÅAI‰ºöÊ†πÊçÆÊÇ®ËÆæÁΩÆÁöÑ‰∏ñÁïå‰π¶„ÄÅÊ≠£ÂàôËÑöÊú¨ÂíåÈ¢ÑËÆæÊù•ÂõûÂ∫î„ÄÇ",
    "next": "‰∏ã‰∏ÄÊ≠•",
    "previous": "‰∏ä‰∏ÄÊ≠•",
    "skip": "Ë∑≥Ëøá",
    "finish": "ÂÆåÊàê",
    "resetTour": "ÈáçÁΩÆÂºïÂØº"
  }
}
</file>

<file path="app/i18n/fonts.ts">
import { Language } from "./index";
‚ãÆ----
export const getLanguageFont = (language: Language): string =>
export const getLanguageSerifFont = (language: Language): string =>
export const getLanguageTitleFont = (language: Language): string =>
</file>

<file path="app/i18n/FontWrapper.tsx">
import { ReactNode } from "react";
import { useLanguage } from "./index";
interface FontWrapperProps {
  children: ReactNode;
}
export function FontWrapper(
export function TitleFontWrapper(
</file>

<file path="app/i18n/index.ts">
import { createContext, useContext } from "react";
‚ãÆ----
export type Language = typeof LANGUAGES[number];
‚ãÆ----
type LanguageContextType = {
  language: Language;
  setLanguage: (language: Language) => void;
  t: (key: string) => string;
  fontClass: string;
  titleFontClass: string;
  serifFontClass: string;
};
‚ãÆ----
export const useLanguage = () =>
export const getTranslation = (language: Language, key: string): string =>
export const getClientLanguage = (): Language =>
</file>

<file path="app/i18n/LanguageProvider.tsx">
import { ReactNode, useEffect, useState } from "react";
import { DEFAULT_LANGUAGE, Language, LANGUAGES, LanguageContext, getTranslation, getClientLanguage } from "./index";
import { getLanguageFont, getLanguageTitleFont, getLanguageSerifFont } from "./fonts";
import LoadingTransition from "@/components/LoadingTransition";
interface LanguageProviderProps {
  children: ReactNode;
}
export function LanguageProvider(
‚ãÆ----
const setLanguage = (newLanguage: Language) =>
const t = (key: string) =>
</file>

<file path="app/styles/fantasy-ui.css">
.fantasy-bg {
.magic-border {
.magic-border::before {
.logo-magic-container {
.logo-magic-container::after {
.logo-magic-container:hover::after {
.menu-item {
.menu-item::before {
.menu-item:hover::before {
.menu-item.active::before {
.menu-item:hover svg,
.menu-divider {
.menu-divider::before,
.menu-divider::before {
.menu-divider::after {
.session-card {
.session-card::before {
.session-card:hover {
.session-card:hover::before {
.user-avatar {
.user-avatar::after {
.user-avatar:hover::after {
.fantasy-scrollbar::-webkit-scrollbar {
.fantasy-scrollbar::-webkit-scrollbar-track {
.fantasy-scrollbar::-webkit-scrollbar-thumb {
.fantasy-scrollbar::-webkit-scrollbar-thumb:hover {
.magical-text {
.magical-login-text {
.magical-login-text span {
.login-fantasy-bg {
.login-fantasy-bg::after {
.login-fantasy-bg::before {
‚ãÆ----
.magical-input {
.magical-input::after {
.magical-input:focus-within::after {
.portal-button {
.portal-button::before {
.portal-button:hover {
.portal-button:hover::before {
.toggle-button {
.toggle-button::after {
.toggle-button:hover::after {
.fade-truncate {
.fade-truncate::after {
‚ãÆ----
.animate-pulse-slow {
‚ãÆ----
.animate-ring-pulse {
‚ãÆ----
.breathing-bg {
</file>

<file path="app/styles/fonts.css">
.font-source-sans {
.font-source-serif {
.font-cinzel {
.font-noto-sans-sc {
.font-noto-serif-sc {
html[lang="zh"] .font-sans {
html[lang="en"] .font-sans {
html[lang="zh"] .font-serif {
html[lang="en"] .font-serif {
html[lang="zh"] .font-title {
html[lang="en"] .font-title {
html[lang="zh"] .text-adjust {
html[lang="en"] .text-adjust {
body {
.font-serif,
</file>

<file path="app/styles/local-fonts.css">
@font-face {
‚ãÆ----
:root {
</file>

<file path="app/globals.css">
:root {
body {
html, body {
h1,
a {
a:hover {
button,
input,
input:focus,
.story-text {
.user-input {
::-webkit-scrollbar {
::-webkit-scrollbar-track {
::-webkit-scrollbar-thumb {
::-webkit-scrollbar-thumb:hover {
‚ãÆ----
.animate-gradient-x {
‚ãÆ----
.h-safe-area-inset-bottom {
‚ãÆ----
.mobile-bottom-nav {
</file>

<file path="app/layout.tsx">
import type { Metadata, Viewport } from "next";
‚ãÆ----
import MainLayout from "@/components/MainLayout";
import { LanguageProvider } from "@/app/i18n/LanguageProvider";
import { SoundProvider } from "@/contexts/SoundContext";
import GoogleAnalytics from "@/components/GoogleAnalytics";
import { Analytics } from "@vercel/analytics/react";
‚ãÆ----
export default function RootLayout({
  children,
}:
</file>

<file path="app/metadata.ts">
import { Metadata } from "next";
</file>

<file path="app/not-found.tsx">
import Link from "next/link";
import { motion } from "framer-motion";
import { useLanguage } from "./i18n";
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="app/page.tsx">
import { homeMetadata } from "./metadata";
‚ãÆ----
import { Suspense } from "react";
import HomeContent from "@/components/HomeContent";
‚ãÆ----
function HomeLoading()
</file>

<file path="components/__tests__/ChatHtmlBubble.test.ts">
import { describe, it, expect } from "vitest";
function processText(str: string): string
</file>

<file path="components/AdvancedSettingsEditor.tsx">
import React, { useState, useRef, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { TagColorEditor } from "@/components/TagColorEditor";
‚ãÆ----
interface AdvancedSettingsEditorProps {
  isOpen: boolean;
  onClose: () => void;
  onViewSwitch?: () => void;
}
‚ãÆ----
const handleClickOutside = (event: MouseEvent) =>
</file>

<file path="components/CharacterAvatarBackground.tsx">
import { useEffect, useState } from "react";
import { getBlob } from "@/lib/data/local-storage";
export function CharacterAvatarBackground(
‚ãÆ----
async function loadImage()
</file>

<file path="components/CharacterCardCarousel.tsx">
import React from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
interface CharacterCardCarouselProps {
  characters: Character[];
  onEditClick: (character: Character, e: React.MouseEvent) => void;
  onDeleteClick: (characterId: string) => void;
}
‚ãÆ----
const handleRotateLeft = () =>
const handleRotateRight = () =>
‚ãÆ----
onClick=
‚ãÆ----
trackButtonClick("delete_character_btn", "Âà†Èô§ËßíËâ≤");
e.stopPropagation();
onDeleteClick(character.id);
‚ãÆ----
e.preventDefault();
‚ãÆ----
handleRotateLeft();
‚ãÆ----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
</file>

<file path="components/CharacterCardGrid.tsx">
import React from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import Tilt from "react-parallax-tilt";
import { useLanguage } from "@/app/i18n";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
interface CharacterCardGridProps {
  characters: Character[];
  onEditClick: (character: Character, e: React.MouseEvent) => void;
  onDeleteClick: (characterId: string) => void;
}
</file>

<file path="components/CharacterChatHeader.tsx">
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
import { useLanguage } from "@/app/i18n";
interface Props {
  character: {
    name: string;
    avatar_path?: string;
  };
  serifFontClass: string;
  sidebarCollapsed: boolean;
  activeView: "chat" | "worldbook" | "regex" | "preset";
  toggleSidebar: () => void;
  onSwitchToView: (view: "chat" | "worldbook" | "regex" | "preset") => void;
  onToggleView: () => void;
  onToggleRegexEditor: () => void;
}
</file>

<file path="components/CharacterChatPanel.tsx">
import { useEffect, useRef, useState } from "react";
import ChatHtmlBubble from "@/components/ChatHtmlBubble";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick, trackFormSubmit } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality?: string;
  avatar_path?: string;
}
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp?: string;
  isUser?: boolean;
}
interface Props {
  character: Character;
  messages: Message[];
  userInput: string;
  setUserInput: (val: string) => void;
  isSending: boolean;
  suggestedInputs: string[];
  onSubmit: (e: React.FormEvent) => void;
  onSuggestedInput: (input: string) => void;
  onTruncate: (id: string) => void;
  onRegenerate: (id: string) => void;
  fontClass: string;
  serifFontClass: string;
  t: (key: string) => string;
  activeModes: Record<string, any>;
  setActiveModes: React.Dispatch<React.SetStateAction<Record<string, any>>>;
}
‚ãÆ----
const scrollToBottom = () =>
const maybeScrollToBottom = (threshold = 120) =>
‚ãÆ----
const shouldShowRegenerateButton = (message: Message, index: number) =>
‚ãÆ----
trackFormSubmit("page", "Êèê‰∫§Ë°®Âçï");
onSubmit(event);
‚ãÆ----
onChange=
</file>

<file path="components/CharacterSidebar.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import Link from "next/link";
import DialogueTreeModal from "@/components/DialogueTreeModal";
import { trackButtonClick } from "@/utils/google-analytics";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { getAvailableGithubPresets, isPresetDownloaded, downloadPresetFromGithub, doesPresetExist, getPresetDisplayName, getPresetDescription } from "@/function/preset/download";
import AdvancedSettingsEditor from "@/components/AdvancedSettingsEditor";
interface CharacterSidebarProps {
  character: {
    id: string;
    name: string;
    personality?: string;
    avatar_path?: string;
    scenario?: string;
  };
  isCollapsed: boolean;
  toggleSidebar: () => void;
  responseLength?: number;
  onResponseLengthChange?: (length: number) => void;
  onDialogueEdit?: () => void;
  onViewSwitch?: () => void;
}
‚ãÆ----
const handleResponseLengthChange = (event: React.ChangeEvent<HTMLInputElement>) =>
const handleOpenPromptEditor = () =>
const handleDownloadAndEnablePreset = async (presetName: string) =>
‚ãÆ----
const loadGithubPresets = async () =>
‚ãÆ----
const handleResize = () =>
‚ãÆ----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 50 50">
‚ãÆ----
<span>
</file>

<file path="components/ChatHtmlBubble.tsx">
import { useEffect, useRef, memo, useState, useCallback, useMemo } from "react";
import { useSymbolColorStore } from "@/contexts/SymbolColorStore";
import { useLanguage } from "@/app/i18n";
class VirtualRenderQueue
‚ãÆ----
enqueue(task: () => void)
private scheduleProcessing()
private processQueue()
clear()
get length()
getNextTask()
‚ãÆ----
function convertMarkdown(str: string): string
function isCompleteHtmlDocument(str: string): boolean
function detectHtmlTags(str: string)
function generatePalette(uniqueTags: string[]): Record<string, string>
function replaceTags(html: string)
‚ãÆ----
function processHtml(htmlStr: string): string
function processSelfClosingTags(htmlStr: string): string
‚ãÆ----
interface Props {
  html: string;
  isLoading?: boolean;
  serifFontClass?: string;
  forceFullDocument?: boolean;
  enableStreaming?: boolean;
  onContentChange?: () => void;
}
‚ãÆ----
// Virtual queue integration for rendering optimization
‚ãÆ----
// Memoized HTML processing to prevent unnecessary recalculations
‚ãÆ----
// Batched update function using virtual queue
‚ãÆ----
// Queue the update if already processing
‚ãÆ----
// Clear any pending timeout
‚ãÆ----
// Batch the update with a small delay to collect multiple changes
‚ãÆ----
// Process any queued updates
‚ãÆ----
}, 16); // ~60fps
‚ãÆ----
// Optimized height adjustment using virtual queue
‚ãÆ----
// Silent error handling
‚ãÆ----
const handler = (e: MessageEvent) =>
‚ãÆ----
// Use virtual queue for height updates
‚ãÆ----
const resizeHandler = () =>
</file>

<file path="components/CreatePresetModal.tsx">
import { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { createPreset } from "@/function/preset/global";
import { toast } from "react-hot-toast";
interface CreatePresetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: () => void;
}
‚ãÆ----
const handleSubmit = async (e: React.FormEvent) =>
const handleClose = () =>
</file>

<file path="components/DialogueTreeModal.tsx">
import { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { useLanguage } from "@/app/i18n";
import ReactFlow, {
  MiniMap,
  Background,
  useNodesState,
  useEdgesState,
  Node,
  Edge,
  NodeTypes,
  ConnectionLineType,
  Panel,
  Handle,
  Position,
  NodeProps,
  ReactFlowInstance,
} from "reactflow";
‚ãÆ----
import ELK from "elkjs/lib/elk.bundled.js";
import { trackButtonClick } from "@/utils/google-analytics";
import { switchDialogueBranch } from "@/function/dialogue/truncate";
import { getCharacterDialogue } from "@/function/dialogue/info";
import { getIncrementalDialogue } from "@/function/dialogue/incremental-info";
import { editDialaogueNodeContent } from "@/function/dialogue/edit";
interface DialogueTreeModalProps {
  isOpen: boolean;
  onClose: () => void;
  characterId?: string;
  onDialogueEdit?: () => void;
}
interface ELKNode {
  id: string;
  width?: number;
  height?: number;
  x?: number;
  y?: number;
  children?: ELKNode[];
}
interface ELKEdge {
  id: string;
  sources: string[];
  targets: string[];
}
interface ELKGraph {
  id: string;
  children: ELKNode[];
  edges: ELKEdge[];
}
interface DialogueNode extends Node {
  data: {
    label: string;
    fullContent: string;
    userInput: string;
    assistantResponse: string;
    parsedContent: any;
    onEditClick: (id: string) => void;
    onJumpClick: (id: string) => void;
    isCurrentPath: boolean;
    characterId: string;
  };
}
‚ãÆ----
const handleNodeClick = () =>
const handleToggleExpand = (event: React.MouseEvent) =>
const handleJumpClick = async (event: React.MouseEvent) =>
‚ãÆ----
onClick=
‚ãÆ----
title=
‚ãÆ----
function handleClickOutside(event: MouseEvent)
‚ãÆ----
function handleEditModalClickOutside(event: MouseEvent)
‚ãÆ----
const fetchIncrementalDialogueData = async (characterId: string) =>
const fetchDialogueData = async (characterId: string) =>
‚ãÆ----
position: { x: 0, y: 0 }, // Temporary position
‚ãÆ----
// Create edges first (for ELK layout calculation)
‚ãÆ----
const processIncrementalNodes = async (incrementalResponse: any, characterId: string) =>
‚ãÆ----
position: { x: 0, y: 0 }, // Temporary position
‚ãÆ----
// Create edges for new nodes
‚ãÆ----
const saveEditContent = async () =>
‚ãÆ----
<li key=
‚ãÆ----
aria-label=
</file>

<file path="components/DownloadCharacterModal.tsx">
import React, { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { handleCharacterUpload } from "@/function/character/import";
import { useLanguage } from "@/app/i18n";
‚ãÆ----
interface DownloadCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
interface GithubFile {
  name: string;
  download_url: string;
}
interface CharacterInfo {
  displayName: string;
  author: string;
}
‚ãÆ----
const handleDownloadAndImport = async (file: GithubFile) =>
const extractCharacterInfo = (fileName: string): CharacterInfo =>
</file>

<file path="components/EditCharacterModal.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { motion, AnimatePresence } from "framer-motion";
import { trackButtonClick } from "@/utils/google-analytics";
import { updateCharacter } from "@/function/dialogue/update";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
interface EditCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  characterId: string;
  characterData: {
    name: string;
    personality?: string;
    scenario?: string;
    first_mes?: string;
    creatorcomment?: string;
    avatar_path?: string;
  };
  onSave: () => void;
}
‚ãÆ----
const handleSubmit = async (e: React.FormEvent) =>
‚ãÆ----
onClick=
‚ãÆ----
xmlns="http://www.w3.org/2000/svg"
</file>

<file path="components/EditPromptModal.tsx">
import React, { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { updatePromptInPreset } from "@/function/preset/edit";
interface PresetPromptData {
  identifier: string;
  name: string;
  system_prompt?: boolean;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  injection_position?: number;
  injection_depth?: number;
  forbid_overrides?: boolean;
  contentLength: number;
}
interface EditPromptModalProps {
  isOpen: boolean;
  onClose: () => void;
  presetId: string;
  prompt: PresetPromptData | null;
  onSave: () => void;
}
‚ãÆ----
const handleSave = async () =>
</file>

<file path="components/GoogleAnalytics.tsx">
import Script from "next/script";
import { useEffect, Suspense } from "react";
import { usePathname, useSearchParams } from "next/navigation";
import { GA_MEASUREMENT_ID, initGA, pageview } from "@/utils/google-analytics";
function GoogleAnalyticsContent()
‚ãÆ----
src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
‚ãÆ----
export default function GoogleAnalytics()
</file>

<file path="components/HomeContent.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import Link from "next/link";
import { useLanguage } from "../app/i18n";
import UserTour from "@/components/UserTour";
import { useTour } from "@/hooks/useTour";
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="components/ImportCharacterModal.tsx">
import { useState, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
import { handleCharacterUpload } from "@/function/character/import";
interface ImportCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
‚ãÆ----
const handleDragOver = (e: React.DragEvent<HTMLDivElement>) =>
const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) =>
const handleDrop = (e: React.DragEvent<HTMLDivElement>) =>
const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleUpload = async () =>
const resetForm = () =>
const handleClose = () =>
</file>

<file path="components/ImportPresetModal.tsx">
import React, { useState, useRef } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importPresetFromJson } from "@/function/preset/import";
interface ImportPresetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
‚ãÆ----
const handleFileSelect = async (file: File) =>
‚ãÆ----
// ‰∏çÁ´ãÂç≥ÂØºÂÖ•ÔºåÊòæÁ§∫È¢ÑËßàÂíåËá™ÂÆö‰πâË°®Âçï
‚ãÆ----
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleImport = async () =>
const handleClose = () =>
</file>

<file path="components/ImportRegexScriptModal.tsx">
import React, { useState, useRef, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importRegexScriptFromJson } from "@/function/regex/import";
import { listGlobalRegexScripts, importFromGlobalRegexScript, GlobalRegexScript, deleteGlobalRegexScript } from "@/function/regex/global";
interface ImportRegexScriptModalProps {
  isOpen: boolean;
  characterId: string;
  onClose: () => void;
  onImportSuccess: () => void;
}
‚ãÆ----
const loadGlobalRegexScripts = async () =>
const handleImportFromGlobal = async () =>
const handleFilesSelect = async (files: File[]) =>
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleClose = () =>
const handleDeleteGlobalScript = async (globalId: string, event: React.MouseEvent) =>
‚ãÆ----
onChange=
‚ãÆ----
onClick=
</file>

<file path="components/ImportWorldBookModal.tsx">
import React, { useState, useRef, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importWorldBookFromJson } from "@/function/worldbook/import";
import { listGlobalWorldBooks, importFromGlobalWorldBook, GlobalWorldBook, deleteGlobalWorldBook } from "@/function/worldbook/global";
interface ImportWorldBookModalProps {
  isOpen: boolean;
  characterId: string;
  onClose: () => void;
  onImportSuccess: () => void;
}
‚ãÆ----
const loadGlobalWorldBooks = async () =>
const handleImportFromGlobal = async () =>
const handleFileSelect = async (file: File) =>
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleClose = () =>
const handleDeleteGlobalWorldBook = async (globalId: string, event: React.MouseEvent) =>
‚ãÆ----
onChange=
‚ãÆ----
onClick=
</file>

<file path="components/LoadingTransition.tsx">
import { useEffect, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import gsap from "gsap";
import { useSoundContext } from "@/contexts/SoundContext";
interface LoadingTransitionProps {
  onAnimationComplete?: () => void;
  redirectUrl?: string;
  autoRedirect?: boolean;
  duration?: number;
}
‚ãÆ----
const startAnimation = () =>
const finishAnimation = () =>
const fadeOut = () =>
</file>

<file path="components/LoginModal.tsx">
import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useLanguage } from "@/app/i18n";
interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
}
‚ãÆ----
const handleClickOutside = (event: MouseEvent) =>
const handleEscape = (event: KeyboardEvent) =>
‚ãÆ----
const handleNext = () =>
const handlePrev = () =>
const handleKeyPress = (e: React.KeyboardEvent) =>
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleLogin = async (e: React.FormEvent) =>
const handleSendVerificationCode = () =>
‚ãÆ----
<a href="#" className="text-[#c0a480] hover:text-[#f9c86d] transition-colors text-xs">
</file>

<file path="components/MainLayout.tsx">
import { useState, useEffect } from "react";
import Sidebar from "@/components/Sidebar";
import ModelSidebar from "@/components/ModelSidebar";
import SettingsDropdown from "@/components/SettingsDropdown";
import LoginModal from "@/components/LoginModal";
import MobileBottomNav from "@/components/MobileBottomNav";
‚ãÆ----
const checkIfMobile = () =>
‚ãÆ----
const toggleSidebar = () =>
const toggleModelSidebar = () =>
</file>

<file path="components/MobileBottomNav.tsx">
import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter, usePathname } from "next/navigation";
import { useLanguage } from "@/app/i18n";
‚ãÆ----
interface MobileBottomNavProps {
  openLoginModal: () => void;
}
‚ãÆ----
const checkIfMobile = () =>
‚ãÆ----
const handleLogout = () =>
const isActive = (path: string) =>
</file>

<file path="components/ModelSidebar.tsx">
import { useState, useEffect } from "react";
‚ãÆ----
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
interface ModelSidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
}
type LLMType = "openai" | "ollama";
interface APIConfig {
  id: string;
  name: string;
  type: LLMType;
  baseUrl: string;
  model: string;
  apiKey?: string;
}
‚ãÆ----
/**
   * Loads saved configurations from localStorage and initializes the component state
   * Handles error cases and sets up initial active configuration
   */
‚ãÆ----
/**
   * Loads a configuration into the form fields
   * @param {APIConfig} config - The configuration to load
   */
const loadConfigToForm = (config: APIConfig) =>
/**
   * Generates a unique ID for new configurations
   * @returns {string} A unique identifier
   */
const generateId = () => `api_$
/**
   * Initiates the creation of a new configuration
   * Resets form fields and shows the new configuration form
   */
const handleCreateConfig = () =>
/**
   * Cancels the creation of a new configuration
   * Restores the previous state if available
   */
const handleCancelCreate = () =>
/**
   * Saves the current configuration
   * Handles both new configurations and updates to existing ones
   * Persists changes to localStorage
   */
const handleSave = () =>
const generateConfigName = (type: LLMType, model: string): string =>
const handleDeleteConfig = (id: string) =>
/**
   * Switches to a different configuration
   * @param {string} id - The ID of the configuration to switch to
   */
const handleSwitchConfig = (id: string) =>
const handleGetModelList = async (baseUrl: string, apiKey: string) =>
const handleStartEditName = (config: APIConfig, e: React.MouseEvent) =>
const handleSaveName = () =>
/**
   * Handles keyboard events during name editing
   * @param {React.KeyboardEvent} e - The keyboard event
   */
const handleKeyDown = (e: React.KeyboardEvent) =>
/**
   * Tests the current model configuration using LangChain
   * Sends a test request to verify the configuration works
   * Uses a minimal test prompt to check model connectivity and response
   */
const handleTestModel = async () =>
‚ãÆ----
// Initialize the appropriate LangChain client based on LLM type
‚ãÆ----
onChange=
‚ãÆ----
onClick=
</file>

<file path="components/PresetEditor.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { getAllPresets, getPreset, deletePreset, togglePresetEnabled, getPromptsForDisplay } from "@/function/preset/global";
import { deletePromptFromPreset, togglePromptEnabled } from "@/function/preset/edit";
import { useLanguage } from "@/app/i18n";
import ImportPresetModal from "@/components/ImportPresetModal";
import CreatePresetModal from "@/components/CreatePresetModal";
‚ãÆ----
import React from "react";
import EditPromptModal from "@/components/EditPromptModal";
interface PresetEditorProps {
  onClose: () => void;
  characterName?: string;
  characterId?: string;
}
interface PresetData {
  id: string;
  name: string;
  enabled?: boolean;
  prompts: PresetPromptData[];
  created_at?: string;
  updated_at?: string;
  totalPrompts: number;
  enabledPrompts: number;
  lastUpdated: number;
}
interface PresetPromptData {
  identifier: string;
  name: string;
  system_prompt?: boolean;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  injection_position?: number;
  injection_depth?: number;
  forbid_overrides?: boolean;
  contentLength: number;
}
‚ãÆ----
const loadSortPreferences = () =>
const loadFilterPreferences = () =>
const saveSortPreferences = (newSortBy: string, newSortOrder: "asc" | "desc") =>
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const saveFilterPreferences = (newFilterBy: string) =>
‚ãÆ----
const loadPresetData = async () =>
const filterPresets = (presets: PresetData[], filterBy: string) =>
const sortPresets = (presets: PresetData[], sortBy: string, sortOrder: "asc" | "desc") =>
‚ãÆ----
const handleCreatePreset = async () =>
const handleDeletePreset = async (presetId: string) =>
const handleSelectPreset = async (presetId: string) =>
const toggleRowExpansion = (presetId: string) =>
const handleDeletePrompt = async (presetId: string, promptIdentifier: string) =>
const handleEditPrompt = (prompt: PresetPromptData) =>
const handleCloseEditModal = () =>
const handleSaveEditPrompt = async () =>
const handleTogglePrompt = async (presetId: string, promptIdentifier: string, enableState: boolean) =>
const handleTogglePreset = async (presetId: string, enableState: boolean) =>
</file>

<file path="components/PromptEditor.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
interface PromptEditorProps {
  isOpen: boolean;
  onClose: () => void;
  characterId: string;
  characterName: string;
  onSave: (prompts: {
    prefixPrompt: string;
    chainOfThoughtPrompt: string;
    suffixPrompt: string;
  }) => void;
  initialPrompts?: {
    prefixPrompt: string;
    chainOfThoughtPrompt: string;
    suffixPrompt: string;
  };
}
‚ãÆ----
const handleResize = () =>
‚ãÆ----
const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) =>
const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) =>
const handleMouseUp = () =>
const handleSave = () =>
‚ãÆ----
onClick=
‚ãÆ----
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
</file>

<file path="components/RegexScriptEditor.tsx">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { RegexScript, RegexScriptSettings } from "@/lib/models/regex-script-model";
import { trackButtonClick } from "@/utils/google-analytics";
import RegexScriptEntryEditor from "@/components/RegexScriptEntryEditor";
import ImportRegexScriptModal from "@/components/ImportRegexScriptModal";
import { updateRegexScriptSettings } from "@/function/regex/update-setting";
import { getRegexScripts } from "@/function/regex/get";
import { getRegexScriptSettings } from "@/function/regex/get-setting";
import { addRegexScript } from "@/function/regex/add";
import { updateRegexScript } from "@/function/regex/update";
import { deleteRegexScript } from "@/function/regex/delete";
interface Props {
  onClose: () => void;
  characterName: string;
  characterId: string;
}
‚ãÆ----
const loadScriptsAndSettings = async () =>
const handleSaveScript = async (script: Partial<RegexScript &
const handleDeleteScript = async (scriptId: string) =>
const handleToggleScript = async (scriptId: string) =>
const handleUpdateSettings = async (updates: Partial<RegexScriptSettings>) =>
const toggleScriptExpansion = (scriptId: string) =>
const filterScripts = (scripts: Record<string, RegexScript>, filterBy: string) =>
const sortScripts = (scriptEntries: [string, RegexScript][], sortBy: string, sortOrder: "asc" | "desc") =>
‚ãÆ----
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const truncateText = (text: string, maxLength: number = 50) =>
</file>

<file path="components/RegexScriptEntryEditor.tsx">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { RegexScript } from "@/lib/models/regex-script-model";
import { toast } from "react-hot-toast";
interface RegexScriptEntryEditorProps {
  isOpen: boolean;
  editingScript: Partial<RegexScript> | null;
  isSaving: boolean;
  onClose: () => void;
  onSave: (script: Partial<RegexScript>) => Promise<void>;
  onScriptChange: (script: Partial<RegexScript>) => void;
}
‚ãÆ----
const updateScript = (updates: Partial<RegexScript>) =>
const handleSave = async () =>
‚ãÆ----
onChange=
‚ãÆ----
</file>

<file path="components/SettingsDropdown.tsx">
import { useState, useRef, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { useSoundContext } from "@/contexts/SoundContext";
import { useTour } from "@/hooks/useTour";
import { exportDataToFile, importDataFromFile, generateExportFilename, downloadFile } from "@/function/data/export-import";
import { backupToGoogle, getFolderList, getGoogleCodeByUrl, getGoogleLoginUrl, getBackUpFile } from "@/function/data/google-control";
interface SettingsDropdownProps {
  toggleModelSidebar: () => void;
}
‚ãÆ----
function handleClickOutside(event: MouseEvent)
‚ãÆ----
const toggleLanguage = () =>
const openModelSettings = () =>
const handleExportData = async () =>
const handleImportData = async () =>
async function handleImportDataFromGoogle()
async function handleExportDataToGoogle()
</file>

<file path="components/Sidebar.tsx">
import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useLanguage } from "@/app/i18n";
import { isUpdateAvailable, fetchLatestRelease } from "@/utils/version-compare";
‚ãÆ----
interface SidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
  openLoginModal: () => void;
}
‚ãÆ----
const checkIfMobile = () =>
‚ãÆ----
const checkForUpdates = async () =>
‚ãÆ----
const handleLogout = () =>
</file>

<file path="components/TagColorEditor.tsx">
import React, { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { SketchPicker } from "react-color";
import { useSymbolColorStore } from "@/contexts/SymbolColorStore";
import { toast } from "react-hot-toast";
interface SymbolColor {
  symbol: string;
  color: string;
}
interface TagColorEditorProps {
  onSave: (colors: SymbolColor[]) => void;
  onViewSwitch?: () => void;
}
‚ãÆ----
const handleAddSymbol = () =>
const handleColorChange = (symbol: string, color: string) =>
const handleSave = async () =>
const handleDeleteSymbol = (symbolToDelete: string) =>
const handlePredefinedColorSelect = (symbol: string, color: string) =>
‚ãÆ----
onChange=
placeholder=
</file>

<file path="components/UserTour.tsx">
import { useState, useEffect, useRef } from "react";
import { useLanguage } from "@/app/i18n";
interface TourStep {
  target: string;
  title: string;
  content: string;
  position: "top" | "bottom" | "left" | "right";
  allowSkip?: boolean;
  isLanguageSelection?: boolean;
}
interface UserTourProps {
  steps: TourStep[];
  isVisible: boolean;
  onComplete: () => void;
  onSkip: () => void;
}
‚ãÆ----
const updateTargetPosition = () =>
‚ãÆ----
const nextStep = () =>
const prevStep = () =>
const skipTour = () =>
‚ãÆ----
const getTooltipPosition = () =>
</file>

<file path="components/WorldBookEditor.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { getWorldBookEntries } from "@/function/worldbook/info";
import { deleteWorldBookEntry } from "@/function/worldbook/delete";
import { saveAdvancedWorldBookEntry } from "@/function/worldbook/edit";
import { bulkToggleWorldBookEntries } from "@/function/worldbook/bulk-operations";
import { getWorldBookSettings } from "@/function/worldbook/settings";
import { useLanguage } from "@/app/i18n";
import WorldBookEntryEditor from "@/components/WorldBookEntryEditor";
import ImportWorldBookModal from "@/components/ImportWorldBookModal";
‚ãÆ----
import React from "react";
import { v4 as uuidv4 } from "uuid";
interface WorldBookEditorProps {
  onClose: () => void;
  characterName: string;
  characterId: string;
}
interface WorldBookEntryData {
  entry_id: string;
  id?: number;
  content: string;
  keys: string[];
  secondary_keys: string[];
  selective: boolean;
  constant: boolean;
  position: string | number;
  insertion_order: number;
  enabled: boolean;
  use_regex: boolean;
  depth: number;
  comment: string;
  tokens?: number;
  extensions?: any;
  primaryKey: string;
  keyCount: number;
  secondaryKeyCount: number;
  contentLength: number;
  isActive: boolean;
  lastUpdated: number;
  isImported: boolean;
  importedAt: number | null;
}
interface EditingEntry {
  entry_id: string;
  id?: number;
  comment: string;
  keys: string[];
  secondary_keys: string[];
  content: string;
  position: number;
  depth: number;
  enabled: boolean;
  use_regex: boolean;
  selective: boolean;
  constant: boolean;
  insertion_order: number;
}
‚ãÆ----
const loadSortPreferences = () =>
const loadFilterPreferences = () =>
const saveSortPreferences = (newSortBy: string, newSortOrder: "asc" | "desc") =>
const cleanupOldSortPreferences = () =>
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const saveFilterPreferences = (newFilterBy: string) =>
‚ãÆ----
const loadWorldBookData = async () =>
const loadSettings = async () =>
const filterEntries = (entries: WorldBookEntryData[], filterBy: string) =>
const sortEntries = (entries: WorldBookEntryData[], sortBy: string, sortOrder: "asc" | "desc") =>
‚ãÆ----
const handleEditEntry = (entry?: WorldBookEntryData) =>
const handleSaveEntry = async () =>
const toggleRowExpansion = (entryId: string) =>
const getPositionText = (position: string | number) =>
const handleBulkToggleAll = async (enabled: boolean) =>
const handleDeleteEntry = async (entryId: string) =>
const handleToggleEntry = async (entryId: string, newEnabled: boolean) =>
‚ãÆ----
<span className="block truncate text-[10px] sm:text-sm" title=
‚ãÆ----
onClick=
</file>

<file path="components/WorldBookEntryEditor.tsx">
import { useLanguage } from "@/app/i18n";
import { useState } from "react";
interface EditingEntry {
  entry_id: string;
  id?: number;
  comment: string;
  keys: string[];
  secondary_keys: string[];
  content: string;
  position: number;
  depth: number;
  enabled: boolean;
  use_regex: boolean;
  selective: boolean;
  constant: boolean;
  insertion_order: number;
}
interface WorldBookEntryEditorProps {
  isOpen: boolean;
  editingEntry: EditingEntry | null;
  isSaving: boolean;
  onClose: () => void;
  onSave: () => void;
  onEntryChange: (entry: EditingEntry) => void;
}
‚ãÆ----
const handleKeywordChange = (index: number, value: string) =>
const handleRemoveKeyword = (index: number) =>
const handleAddKeyword = () =>
const handleSecondaryKeywordChange = (index: number, value: string) =>
const handleRemoveSecondaryKeyword = (index: number) =>
const handleAddSecondaryKeyword = () =>
‚ãÆ----
onChange=
‚ãÆ----
placeholder=
‚ãÆ----
<span className="text-sm text-[#eae6db] group-hover:text-amber-200 transition-colors duration-300">
‚ãÆ----
<span className="text-sm text-[#eae6db] group-hover:text-green-200 transition-colors duration-300">
</file>

<file path="contexts/SoundContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
interface SoundContextType {
  soundEnabled: boolean;
  toggleSound: () => void;
}
‚ãÆ----
export function useSoundContext()
interface SoundProviderProps {
  children: ReactNode;
}
export function SoundProvider(
‚ãÆ----
const toggleSound = () =>
</file>

<file path="contexts/SymbolColorStore.ts">
import { create } from "zustand";
import { persist } from "zustand/middleware";
export interface SymbolColor {
  symbol: string;
  color: string;
}
‚ãÆ----
interface SymbolColorStore {
  symbolColors: SymbolColor[];
  updateSymbolColors: (colors: SymbolColor[]) => void;
  getColorForSymbol: (symbol: string) => string | undefined;
  getColorForHtmlTag: (tagName: string, className?: string) => string | undefined;
  getPredefinedColors: (symbol: string) => string[];
  addCustomTag: (tagName: string, color?: string) => void;
}
</file>

<file path="docs/GETTING_STARTED.md">
# Getting Started with Narratium.ai

This guide will help you get Narratium.ai up and running on your system.

## Prerequisites

- Node.js (v16 or higher)
- pnpm (recommended) or npm
- Git

## Installation Steps

### 1. Clone the project

```bash
git clone https://github.com/Narratium/Narratium.ai.git
cd Narratium
```

### 2. Install dependencies

```bash
pnpm install
```

### 3. Run the project

```bash
pnpm run dev
```

Once the development server starts, visit: [http://localhost:3000](http://localhost:3000)

## Self-packaging

If you want to create a standalone application:

1. First, install the pake-cli globally:
```bash
npm install -g pake-cli
```

2. Then, depending on your operating system, run one of the following commands:

For Docker:
```bash
docker-compose up --build
```

For macOS:
```bash
pnpm pake-mac
```

For Linux:
```bash
pnpm pake-linux
```

For Windows:
```bash
pnpm pake-win
```

### Troubleshooting

#### macOS Installation Fix

If you encounter a "damaged" display after installation on macOS, run this command in terminal:

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```

## Next Steps

- Check out our [documentation](https://deepwiki.com/Narratium/Narratium.ai/) for detailed guides
- Join our community for support and updates
- Star the repository to stay updated with new releases
</file>

<file path="docs/PROBLEM.md">
mac ÂÆâË£ÖÂêéÊòæÁ§∫ÊçüÂùèËß£ÂÜ≥ÊñπÊ°àÔºöÊâìÂºÄÂëΩ‰ª§Ë°åÔºåËæìÂÖ•Ôºö

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```

Solution for "damaged" display after macOS installation: Open the terminal and enter:

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```
</file>

<file path="docs/VERCEL_DEPLOYMENT.md">
# Vercel Deployment Guide / Vercel ÈÉ®ÁΩ≤ÊåáÂçó

## English

### Quick Deploy
Click the button below to deploy Narratium.ai to Vercel with one click:

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/Narratium.ai)

### Manual Deployment Steps

1. **Fork the Repository**
   - Fork this repository to your GitHub account

2. **Import to Vercel**
   - Go to [vercel.com](https://vercel.com)
   - Click "New Project"
   - Import your forked repository

3. **Configure Build Settings**
   - Framework Preset: `Next.js`
   - Build Command: `pnpm build` (or leave default)
   - Output Directory: `.next` (default)

4. **Environment Variables** (if needed)
   - Add any required environment variables in Vercel dashboard
   - Common variables: API keys, database URLs, etc.

5. **Deploy**
   - Click "Deploy"
   - Your app will be available at `your-project.vercel.app`

### Auto-Deploy
Once connected, Vercel will automatically deploy when you push to your main branch.

**Please make sure to review the LICENSE file for fork permissions and restrictions, especially regarding brand elements and generated content.**

### Support

For deployment issues, check [Vercel Documentation](https://vercel.com/docs)

---

## ‰∏≠Êñá

### Âø´ÈÄüÈÉ®ÁΩ≤
ÁÇπÂáª‰∏ãÊñπÊåâÈíÆ‰∏ÄÈîÆÈÉ®ÁΩ≤ Narratium.ai Âà∞ VercelÔºö

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/Narratium.ai)

### ÊâãÂä®ÈÉ®ÁΩ≤Ê≠•È™§

1. **Fork ‰ªìÂ∫ì**
   - Â∞ÜÊ≠§‰ªìÂ∫ì Fork Âà∞ÊÇ®ÁöÑ GitHub Ë¥¶Êà∑

2. **ÂØºÂÖ•Âà∞ Vercel**
   - ËÆøÈóÆ [vercel.com](https://vercel.com)
   - ÁÇπÂáª "New Project"
   - ÂØºÂÖ•ÊÇ® Fork ÁöÑ‰ªìÂ∫ì

3. **ÈÖçÁΩÆÊûÑÂª∫ËÆæÁΩÆ**
   - Ê°ÜÊû∂È¢ÑËÆæÔºö`Next.js`
   - ÊûÑÂª∫ÂëΩ‰ª§Ôºö`pnpm build`ÔºàÊàñ‰øùÊåÅÈªòËÆ§Ôºâ
   - ËæìÂá∫ÁõÆÂΩïÔºö`.next`ÔºàÈªòËÆ§Ôºâ

4. **ÁéØÂ¢ÉÂèòÈáè**ÔºàÂ¶ÇÈúÄË¶ÅÔºâ
   - Âú® Vercel ÊéßÂà∂Âè∞Ê∑ªÂä†ÊâÄÈúÄÁöÑÁéØÂ¢ÉÂèòÈáè
   - Â∏∏ËßÅÂèòÈáèÔºöAPI ÂØÜÈí•„ÄÅÊï∞ÊçÆÂ∫ì URL Á≠â

5. **ÈÉ®ÁΩ≤**
   - ÁÇπÂáª "Deploy"
   - ÊÇ®ÁöÑÂ∫îÁî®Â∞ÜÂú® `your-project.vercel.app` ÂèØÁî®

### Ëá™Âä®ÈÉ®ÁΩ≤
ËøûÊé•ÂêéÔºåÊØèÂΩìÊÇ®Êé®ÈÄÅÂà∞‰∏ªÂàÜÊîØÊó∂ÔºåVercel Â∞ÜËá™Âä®ÈÉ®ÁΩ≤„ÄÇ

**ËØ∑Âä°ÂøÖÊü•ÈòÖ LICENSE Êñá‰ª∂Ôºå‰∫ÜËß£ fork ÊùÉÈôêÂíåÈôêÂà∂ÔºåÁâπÂà´ÊòØÂÖ≥‰∫éÂìÅÁâåÂÖÉÁ¥†ÂíåÁîüÊàêÂÜÖÂÆπÁöÑÁõ∏ÂÖ≥ËßÑÂÆö„ÄÇ**

### ÊîØÊåÅ

ÈÉ®ÁΩ≤ÈóÆÈ¢òËØ∑Êü•Áúã [Vercel ÊñáÊ°£](https://vercel.com/docs)
</file>

<file path="function/character/delete.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { deleteBlob } from "@/lib/data/local-storage";
export async function deleteCharacter(character_id: string): Promise<
</file>

<file path="function/character/import.ts">
import { parseCharacterCard } from "@/utils/character-parser";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { setBlob } from "@/lib/data/local-storage";
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
import { v4 as uuidv4 } from "uuid";
export async function handleCharacterUpload(file: File)
</file>

<file path="function/character/list.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { adaptCharacterData } from "@/lib/adapter/tagReplacer";
export async function getAllCharacters(language: "en" | "zh", username?: string)
</file>

<file path="function/data/export-import.ts">
import { exportAllData, importAllData } from "@/lib/data/local-storage";
export async function exportDataToFile(): Promise<Blob>
export async function importDataFromFile(file: File): Promise<void>
export function generateExportFilename(): string
export function downloadFile(blob: Blob, filename: string): void
</file>

<file path="function/data/google-control.ts">
import { createRequest } from "@/function/data/google-request";
‚ãÆ----
export function getGoogleLoginUrl()
export function getGoogleToken(code: string)
export function refreshGoogleToken()
export async function getGoogleCodeByUrl(url: Location)
export async function backupToGoogle(info:
export async function getFolderList()
async function createDefaultFolder()
export async function getBackUpFile(folderId:string)
</file>

<file path="function/data/google-request.ts">
import { refreshGoogleToken } from "./google-control";
export async function createRequest<T = any>(url: string, info: Partial<RequestInit &
</file>

<file path="function/dialogue/chat.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { PromptType } from "@/lib/models/character-prompts-model";
import { ParsedResponse } from "@/lib/models/parsed-response";
import { DialogueWorkflow, DialogueWorkflowParams } from "@/lib/workflow/examples/DialogueWorkflow";
export async function handleCharacterChatRequest(payload: {
  username?: string;
  characterId: string;
  message: string;
  modelName: string;
  baseUrl: string;
  apiKey: string;
  llmType?: string;
  streaming?: boolean;
  language?: "zh" | "en";
  promptType?: PromptType;
  number?: number;
  nodeId: string;
  fastModel: boolean;
}): Promise<Response>
async function processPostResponseAsync({
  characterId,
  message,
  fullResponse,
  screenContent,
  event,
  nextPrompts,
  nodeId,
}: {
  characterId: string;
  message: string;
  fullResponse: string;
  screenContent: string;
  event: string;
  nextPrompts: string[];
  nodeId: string;
})
</file>

<file path="function/dialogue/delete.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
interface DeleteDialogueNodeOptions {
  characterId: string;
  nodeId: string;
}
export async function deleteDialogueNode(
</file>

<file path="function/dialogue/edit.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { CharacterDialogue } from "@/lib/core/character-dialogue";
import { parseEvent } from "@/utils/response-parser";
import { DialogueNode } from "@/lib/models/node-model";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
interface EditDialogueNodeRequest {
  characterId: string;
  nodeId: string;
  assistantResponse: string;
  model_name: string;
  api_key: string;
  base_url: string;
  llm_type: string;
  language: string;
}
export async function editDialaogueNodeContent(input: EditDialogueNodeRequest)
</file>

<file path="function/dialogue/incremental-info.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
interface IncrementalDialogueParams {
  characterId: string;
  lastKnownNodeIds?: string[];
  lastUpdateTime?: string;
  language?: "en" | "zh";
}
interface IncrementalDialogueResponse {
  success: boolean;
  hasNewData: boolean;
  newNodes: any[];
  updatedNodes: any[];
  deletedNodeIds: string[];
  currentNodeId: string;
  totalNodeCount: number;
  lastUpdateTime: string;
}
export async function getIncrementalDialogue(params: IncrementalDialogueParams): Promise<IncrementalDialogueResponse>
export async function hasNewDialogueNodes(characterId: string, lastKnownNodeCount: number): Promise<boolean>
</file>

<file path="function/dialogue/info.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
export async function getCharacterDialogue(characterId: string, language: "en" | "zh" = "zh", username?: string)
</file>

<file path="function/dialogue/init.ts">
import { Character } from "@/lib/core/character";
import { CharacterDialogue } from "@/lib/core/character-dialogue";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { PromptType } from "@/lib/models/character-prompts-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
import { RegexProcessor } from "@/lib/core/regex-processor";
interface InitCharacterDialogueOptions {
  username?: string;
  characterId: string;
  language?: "zh" | "en";
  modelName: string;
  baseUrl: string;
  apiKey: string;
  llmType: "openai" | "ollama";
}
export async function initCharacterDialogue(options: InitCharacterDialogueOptions)
</file>

<file path="function/dialogue/save-prompts.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
interface SaveCharacterPromptsOptions {
  characterId: string;
  prompts: any;
}
export async function saveCharacterPrompts(
</file>

<file path="function/dialogue/truncate.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
interface SwitchDialogueBranchOptions {
  characterId: string;
  nodeId: string;
}
export async function switchDialogueBranch(
</file>

<file path="function/dialogue/update.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
export async function updateCharacter(
  character_id: string,
  character_data: any,
): Promise<
</file>

<file path="function/preset/download.ts">
import { importPresetFromJson } from "@/function/preset/import";
import { PresetOperations } from "@/lib/data/preset-operation";
interface GithubPreset {
  name: string;
  displayName: {
    zh: string;
    en: string;
  };
  description: {
    zh: string;
    en: string;
  };
  filename: string;
}
‚ãÆ----
export function getAvailableGithubPresets(): GithubPreset[]
export function getPresetDisplayName(presetName: string, language: "zh" | "en" = "zh"): string
export function getPresetDescription(presetName: string, language: "zh" | "en" = "zh"): string
export async function isPresetDownloaded(presetName: string): Promise<boolean>
export async function doesPresetExist(presetName: string): Promise<boolean>
export async function downloadPresetFromGithub(presetName: string, language: "zh" | "en" = "zh"): Promise<
function markPresetAsDownloaded(presetName: string): void
</file>

<file path="function/preset/edit.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
export async function deletePromptFromPreset(
  presetId: string,
  promptIdentifier: string,
)
export async function togglePromptEnabled(
  presetId: string,
  promptIdentifier: string,
  enabled: boolean,
)
export async function updatePromptInPreset(
  presetId: string,
  promptIdentifier: string,
  updates: { content?: string; enabled?: boolean; position?: number },
)
</file>

<file path="function/preset/global.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
import { Preset } from "@/lib/models/preset-model";
export async function getAllPresets()
export async function getPreset(presetId: string)
export async function createPreset(preset: Preset)
export async function deletePreset(presetId: string)
export async function togglePresetEnabled(presetId: string, enabled: boolean)
export async function getPromptsForDisplay(presetId: string)
</file>

<file path="function/preset/import.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
export async function importPresetFromJson(jsonContent: string, customName?: string): Promise<
</file>

<file path="function/regex/add.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function addRegexScript(characterId: string, script: RegexScript): Promise<string | null>
</file>

<file path="function/regex/delete.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function deleteRegexScript(characterId: string, scriptId: string): Promise<boolean>
</file>

<file path="function/regex/get-setting.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function getRegexScriptSettings(characterId: string): Promise<RegexScriptSettings>
</file>

<file path="function/regex/get.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function getRegexScripts(characterId: string): Promise<Record<string, RegexScript> | null>
</file>

<file path="function/regex/global.ts">
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
export interface GlobalRegexScript {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  scriptCount: number;
  sourceCharacterId?: string;
  sourceCharacterName?: string;
}
export interface GlobalRegexScriptResult {
  success: boolean;
  message: string;
  globalId?: string;
  regexScript?: GlobalRegexScript;
}
export interface ListGlobalRegexScriptsResult {
  success: boolean;
  globalRegexScripts: GlobalRegexScript[];
  message?: string;
}
export async function getNextGlobalId(): Promise<string>
export async function listGlobalRegexScripts(): Promise<ListGlobalRegexScriptsResult>
export async function getGlobalRegexScript(globalId: string): Promise<
export async function importFromGlobalRegexScript(
  characterId: string,
  globalId: string,
): Promise<
export async function deleteGlobalRegexScript(globalId: string): Promise<
</file>

<file path="function/regex/import.ts">
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
import { v4 as uuidv4 } from "uuid";
export interface ImportRegexScriptResult {
  success: boolean;
  message: string;
  importedCount: number;
  skippedCount: number;
  errors: string[];
  globalId?: string;
  successfulFiles?: string[];
  failedFiles?: string[];
}
export async function importRegexScriptFromJson(
  characterId: string,
  jsonData: any,
  options?: {
    saveAsGlobal?: boolean;
    globalName?: string;
    globalDescription?: string;
    sourceCharacterName?: string;
  },
): Promise<ImportRegexScriptResult>
export function validateRegexScriptJson(jsonData: any):
</file>

<file path="function/regex/update-setting.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function updateRegexScriptSettings(
  characterId: string,
  updates: Partial<RegexScriptSettings>,
): Promise<RegexScriptSettings>
</file>

<file path="function/regex/update.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function updateRegexScript(
  characterId: string,
  scriptId: string,
  updates: Partial<RegexScript>,
): Promise<boolean>
</file>

<file path="function/worldbook/bulk-operations.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function bulkToggleWorldBookEntries(
  characterId: string,
  entryIds: string[],
  enabled: boolean,
)
</file>

<file path="function/worldbook/delete.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function deleteWorldBookEntry(characterId: string, entryId: string)
</file>

<file path="function/worldbook/edit.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export async function saveAdvancedWorldBookEntry(
  characterId: string,
  entry: Partial<WorldBookEntry> & {
    entry_id: string;
    keys: string[];
    content: string;
  },
)
</file>

<file path="function/worldbook/global.ts">
import { WorldBookOperations, WorldBookSettings } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface GlobalWorldBook {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  entryCount: number;
  sourceCharacterId?: string;
  sourceCharacterName?: string;
}
export interface GlobalWorldBookResult {
  success: boolean;
  message: string;
  globalId?: string;
  worldBook?: GlobalWorldBook;
}
export interface ListGlobalWorldBooksResult {
  success: boolean;
  globalWorldBooks: GlobalWorldBook[];
  message?: string;
}
export async function getNextGlobalId(): Promise<string>
export async function saveAsGlobalWorldBook(
  characterId: string,
  name: string,
  description?: string,
  sourceCharacterName?: string,
): Promise<GlobalWorldBookResult>
export async function listGlobalWorldBooks(): Promise<ListGlobalWorldBooksResult>
export async function getGlobalWorldBook(globalId: string): Promise<
export async function importFromGlobalWorldBook(
  characterId: string,
  globalId: string,
): Promise<
export async function deleteGlobalWorldBook(globalId: string): Promise<
</file>

<file path="function/worldbook/import.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { v4 as uuidv4 } from "uuid";
import { saveAsGlobalWorldBook } from "./global";
export interface ImportWorldBookResult {
  success: boolean;
  message: string;
  importedCount: number;
  skippedCount: number;
  errors: string[];
  globalId?: string;
}
export async function importWorldBookFromJson(
  characterId: string,
  jsonData: any,
  options?: {
    saveAsGlobal?: boolean;
    globalName?: string;
    globalDescription?: string;
    sourceCharacterName?: string;
  },
): Promise<ImportWorldBookResult>
export function validateWorldBookJson(jsonData: any):
</file>

<file path="function/worldbook/info.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function getWorldBookEntries(characterId: string)
</file>

<file path="function/worldbook/settings.ts">
import { WorldBookOperations, WorldBookSettings } from "@/lib/data/world-book-operation";
export async function getWorldBookSettings(characterId: string)
export async function updateWorldBookSettings(
  characterId: string,
  updates: Partial<WorldBookSettings>,
)
</file>

<file path="hooks/useTour.ts">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
export interface TourStep {
  target: string;
  title: string;
  content: string;
  position: "top" | "bottom" | "left" | "right";
  allowSkip?: boolean;
  isLanguageSelection?: boolean;
}
‚ãÆ----
export function useTour()
‚ãÆ----
const startHomeTour = () =>
const startCharacterTour = () =>
const completeTour = () =>
const skipTour = () =>
const resetTour = () =>
</file>

<file path="lib/adapter/tagReplacer.ts">
export function adaptText(text: string, language: "en" | "zh", username?: string, charName?: string): string
export function adaptCharacterData(
  characterData: any,
  language: "en" | "zh",
  username?: string,
): any
</file>

<file path="lib/core/agent-engine.ts">
import {
  AgentConversation,
  AgentStep,
  AgentMessage,
  AgentTaskStatus,
  AgentCapability,
  AgentExecutionContext,
  AgentTool,
} from "@/lib/models/agent-model";
import {
  AgentConversationOperations,
  AgentToolOperations,
} from "@/lib/data/agent-operation";
import {
  AgentToolRegistry,
  registerAllTools,
} from "@/lib/core/agent-tools";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { v4 as uuidv4 } from "uuid";
interface AgentDecision {
  action: "use_tool" | "ask_user" | "complete_task" | "request_clarification";
  toolId?: string;
  toolInput?: any;
  message?: string;
  reasoning?: string;
  isComplete?: boolean;
  result?: any;
}
export class AgentEngine
‚ãÆ----
constructor(conversationId: string, llmConfig: {
    modelName: string;
    apiKey: string;
    baseUrl?: string;
    llmType: "openai" | "ollama";
    temperature?: number;
})
async initialize(): Promise<void>
async executeWorkflow(userInput: string): Promise<
async continueWorkflow(userResponse: string): Promise<
private async getNextDecision(): Promise<AgentDecision>
private async executeDecision(decision: AgentDecision, stepsExecuted: AgentStep[]): Promise<
private async executeStep(capability: AgentCapability, input: any, reasoning?: string): Promise<AgentStep>
private async getLLM()
private getCurrentStatus(): string
private updateWorkingMemoryFromTool(toolId: string, output: any): void
private finalizeOutput(): void
private formatStepMessage(capability: AgentCapability, output: any): string
getContext(): AgentExecutionContext
getWorkingMemory(): Record<string, any>
</file>

<file path="lib/core/agent-service.ts">
import { AgentEngine } from "./agent-engine";
import { AgentConversationOperations } from "@/lib/data/agent-operation";
import { AgentConversation, AgentTaskStatus } from "@/lib/models/agent-model";
export class AgentService
‚ãÆ----
async startGeneration(
    title: string,
    userInput: string,
    llmConfig: {
      modelName: string;
      apiKey: string;
      baseUrl?: string;
      llmType: "openai" | "ollama";
      temperature?: number;
    },
): Promise<
async continueGeneration(
    conversationId: string,
    userResponse: string,
): Promise<
async getConversationStatus(conversationId: string): Promise<
async listConversations(): Promise<AgentConversation[]>
async deleteConversation(conversationId: string): Promise<boolean>
async exportConversation(conversationId: string): Promise<
async getGenerationStats(): Promise<
async cleanup(conversationId: string): Promise<void>
getEngine(conversationId: string): AgentEngine | undefined
</file>

<file path="lib/core/agent-tools.ts">
import { AgentTool, AgentCapability, AgentExecutionContext } from "@/lib/models/agent-model";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
export class AgentToolRegistry
‚ãÆ----
static register(tool: AgentTool): void
static get(toolId: string): AgentTool | undefined
static getAll(): AgentTool[]
static getByCapability(capability: AgentCapability): AgentTool[]
static clear(): void
‚ãÆ----
export abstract class BaseTool implements AgentTool
‚ãÆ----
abstract execute(input: any, context: AgentExecutionContext): Promise<any>;
protected async getLLM(context: AgentExecutionContext)
protected async callLLM(
    systemPrompt: string,
    userPrompt: string,
    context: AgentExecutionContext,
): Promise<string>
‚ãÆ----
export class AnalyzeTool extends BaseTool
‚ãÆ----
async execute(input: any, context: AgentExecutionContext): Promise<any>
‚ãÆ----
export class AskTool extends BaseTool
‚ãÆ----
private formatQuestions(questions: string[], context?: string): string
‚ãÆ----
export class SearchTool extends BaseTool
/**
 * PLAN Tool - Creates generation plan and structure
 */
export class PlanTool extends BaseTool
export class OutputTool extends BaseTool
‚ãÆ----
private async generateCharacter(input: any, context: AgentExecutionContext): Promise<any>
private async generateWorldbook(input: any, context: AgentExecutionContext): Promise<any>
‚ãÆ----
// Fallback if JSON parsing fails
‚ãÆ----
private async generateIntegrationNotes(result: any, context: AgentExecutionContext): Promise<string>
‚ãÆ----
/**
 * VALIDATE Tool - Validates content quality and consistency
 */
export class ValidateTool extends BaseTool
‚ãÆ----
private async validateCharacter(characterData: any, requirements: any, context: AgentExecutionContext): Promise<any>
private async validateWorldbook(worldbookData: any[], requirements: any, context: AgentExecutionContext): Promise<any>
private async validateIntegration(characterData: any, worldbookData: any[], context: AgentExecutionContext): Promise<any>
‚ãÆ----
export class RefineTool extends BaseTool
‚ãÆ----
private async refineCharacter(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private async refineWorldbook(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private async refineIntegration(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private extractRemainingIssues(validationResults: any): string[]
private extractAddressedIssues(validationResults: any): string[]
‚ãÆ----
export function registerAllTools(): void
</file>

<file path="lib/core/character-dialogue.ts">
import { Character } from "@/lib/core/character";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { PromptAssembler } from "@/lib/core/prompt-assembler";
import { RunnablePassthrough } from "@langchain/core/runnables";
import { PromptType } from "@/lib/models/character-prompts-model";
import { getCharacterCompressorPromptZh, getCharacterCompressorPromptEn } from "@/lib/prompts/character-prompts";
import { CharacterHistory } from "@/lib/core/character-history";
import { DialogueOptions } from "@/lib/models/character-dialogue-model";
export class CharacterDialogue
‚ãÆ----
constructor(character: Character)
async initialize(options?: DialogueOptions): Promise<void>
async getFirstMessage(): Promise<string[]>
setupLLM(options?: DialogueOptions): void
‚ãÆ----
type LLMSettings = {
      temperature: number;
      maxTokens?: number;
      timeout?: number;
      maxRetries: number;
      topP?: number;
      frequencyPenalty?: number;
      presencePenalty?: number;
      topK?: number;
      repeatPenalty?: number;
    };
‚ãÆ----
setupDialogueChain(): void
async compressStory(userInput: string, story: string): Promise<string>
</file>

<file path="lib/core/character-history.ts">
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
class DialogueStory
‚ãÆ----
constructor(language: string, userInput: string[] | null = null, responses: string[] | null = null)
getStory(startIndex: number | null = null, endIndex: number | null = null): string
‚ãÆ----
export class CharacterHistory
‚ãÆ----
constructor(language: string, systemMessage: string = "", memLen: number = 10)
getRecentHistory(): string
getCompressedHistory(): string
getSystemMessage(): string
getMessages(): DialogueMessage[]
</file>

<file path="lib/core/character.ts">
import { CharacterRecord } from "@/lib/data/character-record-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { CharacterData } from "@/lib/models/character-model";
import { adaptCharacterData } from "@/lib/adapter/tagReplacer";
export class Character
‚ãÆ----
constructor(characterRecord: CharacterRecord)
private processCharacterBook(characterBook: any): WorldBookEntry[] | Record<string, WorldBookEntry>
async getFirstMessage(): Promise<string[]>
getData(language: "en" | "zh" = "zh", username?: string): CharacterData
getSystemPrompt(language: "en" | "zh" = "zh", username?: string): string
</file>

<file path="lib/core/preset-assembler.ts">
import { PresetPrompt } from "@/lib/models/preset-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
import { MULTI_MODE_PROMPT, MULTI_MODE_CHAIN_OF_THOUGHT, OUTPUT_STRUCTURE_SOFT_GUIDE } from "@/lib/prompts/preset-prompts";
export class PresetAssembler
‚ãÆ----
static assemblePrompts(
    prompts: PresetPrompt[],
    language: "zh" | "en" = "zh",
    fastModel:boolean,
    contextData: { username?: string; charName?: string; number?: number } = {},
):
private static _getDefaultFramework(language: "zh" | "en" = "zh", contextData:
private static _formatPromptContent(
    prompt: PresetPrompt,
    language: "zh" | "en",
    contextData: { username?: string; charName?: string; number?: number },
): string
</file>

<file path="lib/core/prompt-assembler.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { WorldBookManager } from "@/lib/core/world-book";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
export interface PromptAssemblerOptions {
  language: "zh" | "en";
  contextWindow?: number;
}
export class PromptAssembler
‚ãÆ----
constructor(options: PromptAssemblerOptions)
assemblePrompt(
    worldBook: WorldBookEntry[] | Record<string, WorldBookEntry> | undefined,
    baseSystemMessage: string,
    userMessage: string,
    chatHistory: DialogueMessage[],
    currentUserInput: string,
    username?: string,
    charName?: string,
):
private formatWorldBookEntries(
    entries: WorldBookEntry[],
    username?: string,
    charName?: string,
): string
private adjustChatHistoryByTurns(chatHistory: DialogueMessage[]): DialogueMessage[]
</file>

<file path="lib/core/regex-processor.ts">
import { RegexReplacementResult } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export interface RegexProcessorOptions {
  ownerId: string;
}
export class RegexProcessor
‚ãÆ----
private static handleEscapeSequences(pattern: string): string
static async processFullContext(
    fullContext: string,
    options: RegexProcessorOptions,
): Promise<RegexReplacementResult>
</file>

<file path="lib/core/world-book.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
export interface WorldBookJson {
  entries: Record<string, WorldBookEntry> | WorldBookEntry[];
}
export class WorldBookManager
‚ãÆ----
static getMatchingEntries(
    worldBook: WorldBookEntry[] | Record<string, WorldBookEntry> | undefined,
    message: string,
    chatHistory: DialogueMessage[],
    options: {
      contextWindow?: number;
    } = {},
): WorldBookEntry[]
static normalizeWorldBookEntries(worldBook: any): WorldBookEntry[]
static organizeEntriesByPosition(
    entries: WorldBookEntry[],
): Record<number, WorldBookEntry[]>
</file>

<file path="lib/data/agent-operation.ts">
import {
  readData,
  writeData,
  AGENT_CONVERSATIONS_FILE,
} from "@/lib/data/local-storage";
import {
  AgentConversation,
  AgentStep,
  AgentMessage,
  AgentTaskStatus,
  AgentCapability,
} from "@/lib/models/agent-model";
import { v4 as uuidv4 } from "uuid";
export class AgentConversationOperations
‚ãÆ----
static async createConversation(title: string): Promise<AgentConversation>
static async getConversationById(id: string): Promise<AgentConversation | null>
static async getAllConversations(): Promise<AgentConversation[]>
static async addMessage(
    conversationId: string,
    message: Omit<AgentMessage, "id" | "timestamp">,
): Promise<AgentMessage>
static async addStep(
    conversationId: string,
    step: Omit<AgentStep, "id" | "timestamp">,
): Promise<AgentStep>
static async updateStatus(conversationId: string, status: AgentTaskStatus): Promise<AgentConversation | null>
static async updateOutput(
    conversationId: string,
    output: { characterData?: any; worldbookData?: any; combinedData?: any },
): Promise<AgentConversation | null>
static async updateMetadata(
    conversationId: string,
    metadata: Partial<AgentConversation["metadata"]>,
): Promise<AgentConversation | null>
static async updateContext(
    conversationId: string,
    context: Partial<AgentConversation["context"]>,
): Promise<AgentConversation | null>
static async updateConversation(conversation: AgentConversation): Promise<AgentConversation>
static async clearCurrentSteps(conversationId: string): Promise<AgentConversation | null>
static async getConversationHistory(conversationId: string, limit?: number): Promise<AgentMessage[]>
static async getCurrentSteps(conversationId: string): Promise<AgentStep[]>
static async getStepByCapability(conversationId: string, capability: AgentCapability): Promise<AgentStep | null>
static async deleteConversation(id: string): Promise<boolean>
static async cleanupOldConversations(daysOld: number = 30): Promise<number>
static async getConversationStats(): Promise<
‚ãÆ----
export class AgentToolOperations
‚ãÆ----
static async recordToolUsage(
    conversationId: string,
    toolId: string,
    input: any,
    output: any,
    stepId: string,
    executionTime?: number,
): Promise<void>
static async getToolUsageStats(conversationId: string): Promise<
static async getAvailableTools(conversationId: string): Promise<string[]>
static async setAvailableTools(conversationId: string, toolIds: string[]): Promise<void>
static async clearToolHistory(conversationId: string): Promise<void>
static async getGlobalToolMetrics(): Promise<
</file>

<file path="lib/data/character-dialogue-operation.ts">
import { readData, writeData, CHARACTER_DIALOGUES_FILE } from "@/lib/data/local-storage";
import { DialogueNode, DialogueTree } from "@/lib/models/node-model";
import { v4 as uuidv4 } from "uuid";
import { ParsedResponse } from "@/lib/models/parsed-response";
export class LocalCharacterDialogueOperations
‚ãÆ----
static async createDialogueTree(characterId: string): Promise<DialogueTree>
static async getDialogueTreeById(dialogueId: string): Promise<DialogueTree | null>
static async addNodeToDialogueTree(
    dialogueId: string,
    parentNodeId: string,
    userInput: string,
    assistantResponse: string,
    fullResponse: string,
    parsedContent?: ParsedResponse,
    nodeId?: string,
): Promise<string>
static async updateDialogueTree(dialogueId: string, updatedDialogue: DialogueTree): Promise<boolean>
static async updateNodeInDialogueTree(
    dialogueId: string,
    nodeId: string,
    updates: Partial<DialogueNode>,
): Promise<DialogueTree | null>
static async switchBranch(dialogueId: string, nodeId: string): Promise<DialogueTree | null>
static async clearDialogueHistory(dialogueId: string): Promise<DialogueTree | null>
static async deleteDialogueTree(dialogueId: string): Promise<boolean>
static async deleteNode(dialogueId: string, nodeId: string): Promise<DialogueTree | null>
‚ãÆ----
const collectNodesToDelete = (currentNodeId: string) =>
‚ãÆ----
static async getDialoguePathToNode(dialogueId: string, nodeId: string): Promise<DialogueNode[]>
static async getChildNodes(dialogueId: string, parentNodeId: string): Promise<DialogueNode[]>
static async getAllDialoguesForCharacter(characterId: string): Promise<DialogueTree[]>
private static convertToDialogueTree(data: any): DialogueTree
static async getSystemMessage(characterId: string): Promise<string>
static async getLastNodeId(characterId: string): Promise<string>
static async nodeExists(characterId: string, nodeId: string): Promise<boolean>
</file>

<file path="lib/data/character-record-operation.ts">
import { readData, writeData, CHARACTERS_RECORD_FILE } from "@/lib/data/local-storage";
import { RawCharacterData } from "@/lib/models/rawdata-model";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
export interface CharacterRecord {
  id: string;
  data: RawCharacterData;
  imagePath: string;
  created_at: string;
  updated_at: string;
}
export class LocalCharacterRecordOperations
‚ãÆ----
static async createCharacter(characterId: string, rawCharacterData: RawCharacterData, imagePath: string): Promise<CharacterRecord>
static async getAllCharacters(): Promise<CharacterRecord[]>
static async getCharacterById(characterId: string): Promise<CharacterRecord>
static async updateCharacter(characterId: string, characterData: Partial<RawCharacterData>): Promise<CharacterRecord | null>
static async deleteCharacter(characterId: string): Promise<boolean>
</file>

<file path="lib/data/local-storage.ts">
function openDB(): Promise<IDBDatabase>
export async function readData(storeName: string): Promise<any[]>
export async function writeData(storeName: string, data: any[]): Promise<void>
export async function initializeDataFiles(): Promise<void>
export async function setBlob(key: string, blob: Blob): Promise<void>
export async function getBlob(key: string): Promise<Blob | null>
export async function deleteBlob(key: string): Promise<void>
export async function exportAllData(): Promise<Record<string, any>>
export async function importAllData(data: Record<string, any>): Promise<void>
async function blobToBase64(blob: Blob): Promise<string>
async function base64ToBlob(base64: string): Promise<Blob>
</file>

<file path="lib/data/preset-operation.ts">
import { readData, writeData, PRESET_FILE } from "@/lib/data/local-storage";
import { Preset, PresetPrompt } from "@/lib/models/preset-model";
export class PresetOperations
‚ãÆ----
static async getPresets(): Promise<Record<string, any>>
private static async savePresets(presets: Record<string, any>): Promise<void>
static async getAllPresets(): Promise<Preset[]>
static async getPreset(presetId: string): Promise<Preset | null>
static async createPreset(preset: Preset): Promise<string | null>
static async updatePreset(presetId: string, updates: Partial<Preset>): Promise<boolean>
static async deletePreset(presetId: string): Promise<boolean>
static async importPreset(jsonData: string | object, customName?: string): Promise<string | null>
static async getOrderedPrompts(presetId: string): Promise<PresetPrompt[]>
static async getPromptsOrderedForDisplay(presetId: string): Promise<PresetPrompt[]>
static async updateCharacterPrompt(
    presetId: string,
    characterId: string | number,
    promptData: {
      identifier: string;
      name: string;
      content?: string;
      enabled?: boolean;
      position?: number;
      [key: string]: any;
    },
): Promise<boolean>
</file>

<file path="lib/data/regex-script-operation.ts">
import { readData, writeData, REGEX_SCRIPTS_FILE } from "@/lib/data/local-storage";
import { RegexScript } from "@/lib/models/regex-script-model";
export interface RegexScriptSettings {
  enabled: boolean;
  applyToPrompt: boolean;
  applyToResponse: boolean;
  metadata?: any;
}
‚ãÆ----
export class RegexScriptOperations
‚ãÆ----
private static async getRegexScriptStore(): Promise<Record<string, any>>
private static async saveRegexScriptStore(store: Record<string, any>): Promise<boolean>
static async getRegexScripts(ownerId: string): Promise<Record<string, RegexScript> | null>
static async updateRegexScript(
    ownerId: string,
    scriptId: string,
    updates: Partial<RegexScript>,
): Promise<boolean>
static async addRegexScript(
    ownerId: string,
    script: RegexScript,
): Promise<string | null>
static async deleteRegexScript(ownerId: string, scriptId: string): Promise<boolean>
private static async updateOwnerScripts(ownerId: string, scripts: Record<string, RegexScript>): Promise<boolean>
static async updateRegexScripts(
    ownerId: string,
    regexScripts: Record<string, RegexScript> | RegexScript[],
): Promise<boolean>
‚ãÆ----
const processScript = (script: RegexScript): RegexScript =>
‚ãÆ----
static async getRegexScriptSettings(ownerId: string): Promise<RegexScriptSettings>
static async updateRegexScriptSettings(
    ownerId: string,
    updates: Partial<RegexScriptSettings>,
): Promise<RegexScriptSettings>
static async getAllScriptsForProcessing(
    ownerId: string,
): Promise<RegexScript[]>
</file>

<file path="lib/data/world-book-operation.ts">
import { readData, writeData, WORLD_BOOK_FILE } from "@/lib/data/local-storage";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface WorldBookSettings {
  enabled: boolean;
  maxEntries: number;
  contextWindow: number;
  metadata?: any;
}
‚ãÆ----
export class WorldBookOperations
‚ãÆ----
static async getWorldBooks(): Promise<Record<string, any>>
private static async saveWorldBooks(worldBooks: Record<string, any>): Promise<void>
static async getWorldBook(characterId: string): Promise<Record<string, WorldBookEntry> | null>
static async updateWorldBook(
    characterId: string,
    worldBook: Record<string, WorldBookEntry> | WorldBookEntry[],
): Promise<boolean>
‚ãÆ----
const processEntry = (entry: WorldBookEntry): WorldBookEntry =>
‚ãÆ----
static async addWorldBookEntry(
    characterId: string,
    entry: WorldBookEntry,
): Promise<string | null>
static async updateWorldBookEntry(
    characterId: string,
    entryId: string,
    updates: Partial<WorldBookEntry>,
): Promise<boolean>
static async deleteWorldBookEntry(characterId: string, entryId: string): Promise<boolean>
static async getWorldBookSettings(characterId: string): Promise<WorldBookSettings>
static async updateWorldBookSettings(
    characterId: string,
    updates: Partial<WorldBookSettings>,
): Promise<WorldBookSettings>
</file>

<file path="lib/models/agent-model.ts">
export enum AgentCapability {
  SEARCH = "search",
  PLAN = "plan",
  OUTPUT = "output",
  ASK = "ask",
  VALIDATE = "validate",
  REFINE = "refine",
  ANALYZE = "analyze"
}
export enum AgentTaskStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed",
  FAILED = "failed",
  WAITING_FOR_USER = "waiting_for_user"
}
export interface AgentStep {
  id: string;
  capability: AgentCapability;
  input: any;
  output: any;
  reasoning?: string;
  status: AgentTaskStatus;
  executionOrder: number;
  timestamp: string;
  userQuestion?: string;
  userResponse?: any;
  isWaitingForUser?: boolean;
}
export interface AgentMessage {
  id: string;
  role: "user" | "agent" | "system";
  content: string;
  messageType: "text" | "task_request" | "task_result" | "step_update" | "user_question" | "user_response";
  metadata?: {
    capability?: AgentCapability;
    reasoning?: string;
    attachments?: any[];
    questionId?: string;
    stepId?: string;
  };
  timestamp: string;
}
export interface AgentTool {
  id: string;
  name: string;
  description: string;
  capabilities: AgentCapability[];
  inputSchema: any;
  outputSchema: any;
  execute: (input: any, context: AgentExecutionContext) => Promise<any>;
}
export interface AgentConversation {
  id: string;
  title: string;
  status: AgentTaskStatus;
  messages: AgentMessage[];
  currentSteps: AgentStep[];
  availableTools: string[];
  output?: {
    characterData?: any;
    worldbookData?: any;
    combinedData?: any;
  };
  metadata: {
    iterations: number;
    totalTokens?: number;
    executionTime?: number;
    modelUsed?: string;
    temperature?: number;
    toolsUsed?: string[];
  };
  context: {
    userPreferences?: any;
    referenceData?: any;
    constraints?: any;
    pendingQuestions?: Array<{
      id: string;
      question: string;
      stepId: string;
      timestamp: string;
    }>;
    toolUsageHistory?: Array<{
      toolId: string;
      stepId: string;
      input: any;
      output: any;
      timestamp: string;
      executionTime: number;
    }>;
  };
  created_at: string;
  updated_at: string;
}
export interface AgentExecutionContext {
  conversationId: string;
  currentStepIndex: number;
  workingMemory: Record<string, any>;
  availableTools: AgentTool[];
  constraints: {
    maxTokens?: number;
    timeoutMs?: number;
    maxSteps?: number;
  };
  llmConfig?: {
    modelName: string;
    apiKey: string;
    baseUrl?: string;
    llmType: "openai" | "ollama";
    temperature?: number;
  };
}
</file>

<file path="lib/models/character-dialogue-model.ts">
import { ParsedResponse } from "@/lib/models/parsed-response";
import { PromptType } from "@/lib/models/character-prompts-model";
export interface DialogueMessage {
  role: "user" | "assistant" | "system" | "sample";
  content: string;
  parsedContent?: ParsedResponse;
  id: number;
}
export interface DialogueOptions {
  modelName: string;
  apiKey: string;
  baseUrl: string;
  llmType: "openai" | "ollama";
  temperature?: number;
  maxTokens?: number;
  streaming?: boolean;
  language?: "zh" | "en";
  promptType?: PromptType;
  contextWindow?: number;
}
</file>

<file path="lib/models/character-model.ts">
export interface CharacterData {
  name: string;
  description: string;
  personality: string;
  first_mes: string;
  scenario: string;
  mes_example: string;
  creatorcomment: string;
  avatar: string;
  creator_notes?: string;
  imagePath?: string;
  alternate_greetings:string[];
}
</file>

<file path="lib/models/character-prompts-model.ts">
export interface CharacterPromptParams {
  username?: string;
  name: string;
  number: number;
  prefixPrompt?: string;
  chainOfThoughtPrompt?: string;
  suffixPrompt?: string;
  language?: "zh" | "en";
  systemPrompt?: string;
  storyHistory?: string;
  conversationHistory?: string;
  userInput?: string;
  sampleStatus?: string;
}
export enum PromptType {
  COMPANION = "companion",
  NSFW = "nsfw",
  EXPLICIT = "explicit",
  CUSTOM = "custom"
}
</file>

<file path="lib/models/node-model.ts">
import { ParsedResponse } from "@/lib/models/parsed-response";
export class DialogueNode
‚ãÆ----
constructor(
    node_id: string,
    parent_node_id: string,
    user_input: string,
    assistant_response: string,
    full_response: string,
    parsed_content?: ParsedResponse,
    created_at: string = new Date().toISOString(),
)
‚ãÆ----
export class DialogueTree
‚ãÆ----
constructor(
    id: string,
    character_id: string,
    nodes: DialogueNode[] = [],
    current_node_id: string = "root",
    created_at: string = new Date().toISOString(),
    updated_at: string = new Date().toISOString(),
)
</file>

<file path="lib/models/parsed-response.ts">
export interface ParsedResponse {
    regexResult?: string;
    nextPrompts?: string[];
    compressedContent?: string;
  }
</file>

<file path="lib/models/preset-model.ts">
export interface PresetPrompt {
  identifier: string;
  name: string;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  forbid_overrides?: boolean;
  group_id?: string | number;
  position?: number;
}
export interface Preset {
  id?: string;
  name: string;
  enabled?: boolean;
  prompts: PresetPrompt[];
  created_at?: string;
  updated_at?: string;
}
</file>

<file path="lib/models/rawdata-model.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface RawCharacterData {
  id: any;
  name: string;
  description: string;
  personality: string;
  first_mes: string;
  scenario: string;
  mes_example: string;
  creatorcomment: string;
  avatar: string;
  sample_status: string;
  data:{
    name: string;
    description: string;
    personality: string;
    first_mes: string;
    scenario: string;
    mes_example: string;
    creator_notes: string;
    system_prompt: string;
    post_history_instructions: string;
    tags: string[];
    creator: string;
    character_version: string;
    alternate_greetings: string[];
    character_book:{
      entries: {
        comment: string;
        content: string;
        disable?: boolean;
        position?: number;
        constant?: boolean;
        key?: string[];
        order?: number;
        depth?: number;
      }[] | Record<string, WorldBookEntry>;
    }
  },
}
</file>

<file path="lib/models/regex-script-model.ts">
export interface RegexScript {
  scriptKey: string;
  id?: string;
  scriptName: string;
  findRegex: string;
  replaceString?: string | null;
  trimStrings: string[];
  placement: number[];
  disabled?: boolean;
  extensions?: {
    imported?: boolean;
    importedAt?: number;
    globalSource?: boolean;
    globalSourceId?: string;
    globalSourceName?: string;
  };
}
export enum RegexScriptOwnerType {
  CHARACTER = "character",
  GLOBAL = "global",
  CONVERSATION = "conversation"
}
export interface RegexReplacementResult {
  originalText: string;
  replacedText: string;
  appliedScripts: string[];
  success: boolean;
}
export interface RegexScriptSettings {
  enabled: boolean;
  applyToPrompt: boolean;
  applyToResponse: boolean;
  metadata?: any;
}
</file>

<file path="lib/models/world-book-model.ts">
interface WorldBookEntryExtensions {
  position?: number;
  [key: string]: any;
}
export interface WorldBookEntry {
  entry_id?: string;
  id?: number;
  content: string;
  keys: string[];
  secondary_keys?: string[];
  selective: boolean;
  constant: boolean;
  position: string | number;
  insertion_order?: number;
  enabled?: boolean;
  use_regex?: boolean;
  depth?: number;
  comment?: string;
  tokens?: number;
  extensions?: WorldBookEntryExtensions;
}
</file>

<file path="lib/nodeflow/ContextNode/ContextNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { ContextNodeTools } from "./ContextNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class ContextNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/ContextNode/ContextNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
export class DialogueStory
‚ãÆ----
constructor(language: string, userInput: string[] | null = null, responses: string[] | null = null)
getStory(startIndex: number | null = null, endIndex: number | null = null): string
‚ãÆ----
export class ContextNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async assembleChatHistory(
    userMessage: string,
    characterId: string,
    memoryLength: number = 10,
): Promise<
static async loadCharacterHistory(
    characterId: string,
): Promise<
static formatChatHistory(
    historyData: {
      systemMessage: string;
      recentDialogue: DialogueStory;
      historyDialogue: DialogueStory;
    },
    memoryLength: number,
): string
static getRecentHistory(dialogue: DialogueStory, memLen: number): string
static getCompressedHistory(dialogue: DialogueStory, memLen: number): string
</file>

<file path="lib/nodeflow/LLMNode/LLMNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { LLMNodeTools } from "./LLMNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class LLMNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/LLMNode/LLMNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { RunnablePassthrough } from "@langchain/core/runnables";
export interface LLMConfig {
  modelName: string;
  apiKey: string;
  baseUrl?: string;
  llmType: "openai" | "ollama";
  temperature?: number;
  maxTokens?:number;
  maxRetries?: number,
  topP?: number,
  frequencyPenalty?: number,
  presencePenalty?: number,
  topK?: number,
  repeatPenalty?: number,
  streaming?: boolean;
  streamUsage?: boolean;
  language?: "zh" | "en";
}
export class LLMNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async invokeLLM(
    systemMessage: string,
    userMessage: string,
    config: LLMConfig,
): Promise<string>
private static createLLM(config: LLMConfig): ChatOpenAI | ChatOllama
private static createDialogueChain(llm: ChatOpenAI | ChatOllama): any
</file>

<file path="lib/nodeflow/OutputNode/OutputNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
export class OutputNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/PresetNode/PresetNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { PresetNodeTools } from "./PresetNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class PresetNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/PresetNode/PresetNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { PresetOperations } from "@/lib/data/preset-operation";
import { PresetAssembler } from "@/lib/core/preset-assembler";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
export class PresetNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async buildPromptFramework(
    characterId: string,
    language: "zh" | "en" = "zh",
    username?: string,
    charName?: string,
    number?: number,
    fastModel: boolean = false,
): Promise<
private static enrichPromptsWithCharacterInfo(
    prompts: any[],
    character: Character,
): any[]
</file>

<file path="lib/nodeflow/RegexNode/RegexNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { RegexNodeTools } from "./RegexNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class RegexNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/RegexNode/RegexNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { RegexProcessor } from "@/lib/core/regex-processor";
export class RegexNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async processRegex(
    response: string,
    characterId: string,
): Promise<
</file>

<file path="lib/nodeflow/UserInputNode/UserInputNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
export class UserInputNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async beforeExecute(input: NodeInput): Promise<void>
protected async afterExecute(output: NodeOutput): Promise<void>
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/WorldBookNode/WorldBookNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { WorldBookNodeTools } from "./WorldBookNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class WorldBookNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/WorldBookNode/WorldBookNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { Character } from "@/lib/core/character";
import { PromptAssembler } from "@/lib/core/prompt-assembler";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
export class WorldBookNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async assemblePromptWithWorldBook(
    characterId: string,
    baseSystemMessage: string,
    userMessage: string,
    currentUserInput: string,
    language: "zh" | "en" = "zh",
    contextWindow: number = 5,
    username?: string,
    charName?: string,
): Promise<
private static async getChatHistory(characterId: string, contextWindow: number = 5): Promise<DialogueMessage[]>
</file>

<file path="lib/nodeflow/NodeBase.ts">
import { NodeConfig, NodeInput, NodeOutput, NodeExecutionStatus, NodeExecutionResult, NodeCategory } from "@/lib/nodeflow/types";
import { NodeContext } from "@/lib/nodeflow/NodeContext";
import { NodeTool, NodeToolRegistry } from "@/lib/nodeflow/NodeTool";
export abstract class NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getInitParams(): string[]
protected getInputFields(): string[]
protected getOutputFields(): string[]
protected getConfigValue<T>(key: string, defaultValue?: T): T | undefined
protected getState<T>(key: string, defaultValue?: T): T | undefined
protected setState<T>(key: string, value: T): void
protected abstract getDefaultCategory(): NodeCategory;
getCategory(): NodeCategory
isEntryNode(): boolean
isExitNode(): boolean
isMiddleNode(): boolean
protected initializeTools(): void
protected async executeTool(methodName: string, ...params: any[]): Promise<any>
getId(): string
getName(): string
getNext(): string[]
protected async resolveInput(context: NodeContext): Promise<NodeInput>
protected async publishOutput(output: NodeOutput, context: NodeContext): Promise<void>
‚ãÆ----
const storeData = (key: string, value: any) =>
‚ãÆ----
async execute(context: NodeContext): Promise<NodeExecutionResult>
protected async beforeExecute(input: NodeInput): Promise<void>
protected async afterExecute(output: NodeOutput): Promise<void>
protected async _call(input: NodeInput): Promise<NodeOutput>
getStatus(): Record<string, any>
toJSON(): NodeConfig
</file>

<file path="lib/nodeflow/NodeContext.ts">
export class NodeContext
‚ãÆ----
constructor(inputData?: Record<string, any>, cacheData?: Record<string, any>, outputData?: Record<string, any>)
setCache(key: string, value: any): void
getCache(key: string): any
hasCache(key: string): boolean
setInput(key: string, value: any): void
getInput(key: string): any
hasInput(key: string): boolean
setOutput(key: string, value: any): void
getOutput(key: string): any
hasOutput(key: string): boolean
clearOutput(): void
clearInput(): void
clearCache(): void
clear(): void
toJSON(): Record<string, any>
static fromJSON(json: Record<string, any>): NodeContext
</file>

<file path="lib/nodeflow/NodeTool.ts">
export abstract class NodeTool
‚ãÆ----
static getToolType(): string
static getVersion(): string
protected static logExecution(methodName: string, params?: any): void
protected static handleError(error: Error, methodName: string): never
static getAvailableMethods(): string[]
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
‚ãÆ----
export interface ToolMetadata {
  type: string;
  version: string;
  methods: string[];
}
export interface ToolMethodDescriptor {
  name: string;
  description: string;
  parameters: ToolParameterDescriptor[];
  returnType: string;
}
export interface ToolParameterDescriptor {
  name: string;
  type: string;
  required: boolean;
  description?: string;
  defaultValue?: any;
}
export function ToolMethod(description: string, parameters: ToolParameterDescriptor[] = [])
export class NodeToolRegistry
‚ãÆ----
static register(toolClass: typeof NodeTool): void
static get(toolType: string): typeof NodeTool | undefined
static isRegistered(toolClass: typeof NodeTool): boolean
static getRegisteredTypes(): string[]
</file>

<file path="lib/nodeflow/types.ts">
export enum NodeCategory {
  ENTRY = "entry",
  MIDDLE = "middle",
  EXIT = "exit"
}
export interface NodeConfig {
  id: string;
  name: string;
  category: NodeCategory;
  next?: string[];
  initParams?: string[];
  inputFields?: string[];
  outputFields?: string[];
  inputMapping?: Record<string, string>;
}
export type NodeInput = Record<string, any>;
export type NodeOutput = Record<string, any>;
export enum NodeExecutionStatus {
  PENDING = "pending",
  RUNNING = "running",
  COMPLETED = "completed",
  FAILED = "failed",
  SKIPPED = "skipped"
}
export interface NodeExecutionResult {
  nodeId: string;
  status: NodeExecutionStatus;
  input: NodeInput;
  output?: NodeOutput;
  error?: Error;
  startTime: Date;
  endTime?: Date;
}
export interface WorkflowConfig {
  id: string;
  name: string;
  nodes: NodeConfig[];
}
export interface WorkflowExecutionResult {
  workflowId: string;
  status: NodeExecutionStatus;
  results: NodeExecutionResult[];
  outputData?: Record<string, any>;
  startTime: Date;
  endTime?: Date;
}
export interface NodeRegistryEntry {
  nodeClass: any;
}
export type NodeRegistry = Record<string, NodeRegistryEntry>;
</file>

<file path="lib/nodeflow/WorkflowEngine.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeContext } from "@/lib/nodeflow/NodeContext";
import {
  NodeInput,
  NodeOutput,
  NodeRegistry,
  WorkflowConfig,
  NodeExecutionStatus,
  WorkflowExecutionResult,
} from "@/lib/nodeflow/types";
export class WorkflowEngine
‚ãÆ----
constructor(
    config: WorkflowConfig,
    registry: NodeRegistry,
    context: NodeContext,
)
private initializeNodes(context: NodeContext): void
private getEntryNodes(): NodeBase[]
private getNextNodes(nodeId: string): NodeBase[]
private async executeNode(
    node: NodeBase,
    context: NodeContext,
): Promise<NodeOutput>
private async executeParallel(
    nodes: NodeBase[],
    context: NodeContext,
): Promise<NodeOutput[]>
async execute(
    initialWorkflowInput: NodeInput,
    context?: NodeContext,
): Promise<WorkflowExecutionResult>
async *executeAsync(
    initialWorkflowInput: NodeInput,
    context?: NodeContext,
): AsyncGenerator<NodeOutput[], WorkflowExecutionResult, undefined>
validate(): boolean
private detectCycles(): void
‚ãÆ----
const dfs = (nodeId: string): void =>
</file>

<file path="lib/prompts/character-prompts.ts">
export function getCharacterCompressorPromptZh(userInput: string, story: string): string
export function getCharacterCompressorPromptEn(userInput: string, story: string): string
export function getStatusPromptZh(info: string)
export function getStatusPromptEn(info: string)
</file>

<file path="lib/prompts/preset-prompts.ts">

</file>

<file path="lib/workflow/examples/DialogueWorkflow.ts">
import { BaseWorkflow, WorkflowConfig } from "@/lib/workflow/BaseWorkflow";
import { NodeCategory } from "@/lib/nodeflow/types";
import { UserInputNode } from "@/lib/nodeflow/UserInputNode/UserInputNode";
import { ContextNode } from "@/lib/nodeflow/ContextNode/ContextNode";
import { WorldBookNode } from "@/lib/nodeflow/WorldBookNode/WorldBookNode";
import { PresetNode } from "@/lib/nodeflow/PresetNode/PresetNode";
import { LLMNode } from "@/lib/nodeflow/LLMNode/LLMNode";
import { RegexNode } from "@/lib/nodeflow/RegexNode/RegexNode";
import { OutputNode } from "@/lib/nodeflow/OutputNode/OutputNode";
import { PromptType } from "@/lib/models/character-prompts-model";
export interface DialogueWorkflowParams {
  characterId: string;
  userInput: string;
  number?: number;
  promptType?: PromptType;
  language?: "zh" | "en";
  username?: string;
  modelName: string;
  apiKey: string;
  baseUrl?: string;
  llmType?: "openai" | "ollama";
  temperature?: number;
  maxTokens?: number;
  maxRetries?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  topK?: number;
  repeatPenalty?: number;
  streaming?: boolean;
  streamUsage?: boolean;
  fastModel?: boolean;
}
export class DialogueWorkflow extends BaseWorkflow
‚ãÆ----
protected getNodeRegistry()
protected getWorkflowConfig(): WorkflowConfig
</file>

<file path="lib/workflow/BaseWorkflow.ts">
import { NodeContext } from "../nodeflow/NodeContext";
import { WorkflowEngine } from "../nodeflow/WorkflowEngine";
import { NodeCategory } from "../nodeflow/types";
export interface WorkflowConfig {
  id: string;
  name: string;
  nodes: WorkflowNode[];
}
export interface WorkflowNode {
  id: string;
  name: string;
  category: NodeCategory;
  next: string[];
  initParams: string[];
  inputFields: string[];
  outputFields: string[];
  inputMapping?: Record<string, string>;
}
export interface WorkflowParams {
  [key: string]: any;
}
export class ValidationError extends Error
‚ãÆ----
constructor(message: string)
‚ãÆ----
export abstract class BaseWorkflow
‚ãÆ----
constructor()
protected abstract getNodeRegistry():
protected abstract getWorkflowConfig(): WorkflowConfig;
protected validateWorkflowConfig(): void
private validateEntryNode(node: WorkflowNode): void
private validateInputFields(node: WorkflowNode, availableOutputs: Set<string>): void
private validateNodeConnections(node: WorkflowNode, index: number, nodes: WorkflowNode[]): void
private validateNodeCategories(nodes: WorkflowNode[]): void
public async execute(params: WorkflowParams): Promise<any>
public getContext(): NodeContext
public resetContext(): void
</file>

<file path="utils/character-parser.ts">
import extract from "png-chunks-extract";
import encode from "png-chunks-encode";
import PNGtext from "png-chunk-text";
const encodeBase64 = (str: string): string =>
const decodeBase64 = (b64: string): string =>
export const writeCharacterToPng = async (file: File, data: string): Promise<Blob> =>
export const readCharacterFromPng = async (file: File): Promise<string> =>
export const parseCharacterCard = async (file: File): Promise<string> =>
</file>

<file path="utils/google-analytics.ts">
interface Window {
    gtag: (...args: any[]) => void;
    dataLayer: any[];
  }
‚ãÆ----
export const initGA = () =>
export const pageview = (url: string) =>
export const gtagEvent = (eventName: string, params: Record<string, any>) =>
export const trackButtonClick = (buttonId: string, buttonName: string) =>
export const trackFormSubmit = (formId: string, formName: string) =>
</file>

<file path="utils/response-parser.ts">
export function parseEvent(story: string): string
</file>

<file path="utils/version-compare.ts">
export function isUpdateAvailable(current: string, latest: string): boolean
‚ãÆ----
// Ensure both arrays have the same length by padding with zeros
‚ãÆ----
// Compare each part
‚ãÆ----
/**
 * Fetch the latest release information from GitHub API
 * @returns Promise<{version: string, url: string} | null>
 */
export async function fetchLatestRelease(): Promise<
</file>

<file path=".env.example">
# Google OAuth Configuration
# Copy this file to .env.local and fill in your actual values
GOOGLE_OAUTH_CLIENT_ID=your_google_oauth_client_id_here
GOOGLE_OAUTH_CLIENT_SECRET=your_google_oauth_client_secret_here
GOOGLE_OAUTH_REDIRECT_URI=https://www.narratium.org/oauth2callback
NEXT_PUBLIC_API_KEY=your_api_key
NEXT_PUBLIC_API_URL=your_base_url
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions
# testing
/coverage
show.html

# next.js
/.next/
/out/
/public/characters

# production
/build
!/data
/data/*
# misc
.DS_Store
*.pem
action.txt

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# resources
/resources

Narratium.dmg
Narratium.msi
narratium.deb
</file>

<file path="docker-compose.yml">
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_BASE_URL=http://localhost:3000
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
</file>

<file path="Dockerfile">
FROM node:20.12-alpine AS builder

RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

COPY . .
RUN pnpm build

FROM node:20.12-alpine AS runner

RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app

COPY --from=builder /app/out ./out

RUN pnpm add serve

EXPOSE 3000

CMD ["npx", "serve", "-s", "out", "-l", "3000"]
</file>

<file path="eslint.config.mjs">

</file>

<file path="LICENSE">
# Project License

This project is composed of two distinct parts: source code and user-contributed content.

## 1. Code License (MIT)

All source code in this repository is licensed under the MIT License:

---

MIT License

Copyright (c) [2025] [Narratium/Narratium.ai]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights  
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  
copies of the Software, and to permit persons to whom the Software is  
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  
SOFTWARE.

---

## 2. Community-Contributed Content License (CC BY-NC-SA 4.0)

All community-contributed content ‚Äî including but not limited to character cards, story elements, names, descriptions, and visual assets ‚Äî is licensed under the **Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)** license.

You are free to:

- Share ‚Äî copy and redistribute the material in any medium or format  
- Adapt ‚Äî remix, transform, and build upon the material  

**Under the following terms:**

- **Attribution** ‚Äî You must give appropriate credit to the original creators.  
- **NonCommercial** ‚Äî You may not use the material for commercial purposes.  
- **ShareAlike** ‚Äî If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.

For full details of the CC BY-NC-SA 4.0 license, see:  
[https://creativecommons.org/licenses/by-nc-sa/4.0/](https://creativecommons.org/licenses/by-nc-sa/4.0/)

---

## 3. Additional Restrictions on Generated Content and Brand Elements

**IMPORTANT NOTICE:** While the source code is licensed under MIT, the following restrictions apply:

### Generated Content Ownership and Restrictions
All content generated by this software ‚Äî including but not limited to:
- Generated text, stories, dialogues
- Generated images, artwork, visual content
- Generated character cards and character data
- Any other AI-generated or software-generated content

**Ownership**: Generated content is jointly owned by **Narratium** and the **actual creator/user who performed the creative work**. Fork developers or redistributors of the code do NOT acquire ownership rights to content created by others using their fork.

**Commercial Use**: Generated content **IS STRICTLY PROHIBITED FROM COMMERCIAL USE** without explicit written permission from both Narratium and the original content creator.

### Brand Protection
The following Narratium brand elements are proprietary and **NOT COVERED BY THE MIT LICENSE**:
- The "Narratium" name and trademark
- Project logos, branding, and visual identity
- UI design elements, styles, and layouts specific to Narratium
- Any fork or derivative work that incorporates these elements

**Commercial use of the above brand elements and generated content is strictly forbidden without explicit written permission from Narratium.**

### Permitted Use
You may:
- Use the code for personal, educational, or non-commercial purposes
- Create derivative works for non-commercial use (with proper attribution)
- Study and learn from the codebase

You may NOT:
- Use any generated content for commercial purposes (unless you are the original creator AND have Narratium's permission)
- Use Narratium branding in commercial projects
- Create commercial services using this codebase without removing all Narratium branding
- Claim ownership of content created by other users of your fork

---

## Summary

- ‚úÖ **Code**: MIT License ‚Äî open for commercial and non-commercial use with attribution
- üîí **Community Content**: CC BY-NC-SA 4.0 ‚Äî non-commercial use only, with attribution and same-license sharing required
- üö´ **Generated Content**: No commercial use permitted, belongs to Narratium
- üö´ **Brand Elements**: Proprietary to Narratium, commercial use prohibited

Please review all license terms carefully before using, contributing to, or distributing this project.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";
</file>

<file path="package.json">
{
  "name": "Narratium",
  "version": "0.1.0",
  "private": true,
  "main": "electron/main.js",
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "lint": "next lint",
    "preview": "serve -s out",
    "test": "vitest",
    "pake-mac": "pake out/index.html --name Narratium --use-local-file --icon ./public/icon.icns --multi-arch",
    "pake-win": "pake out/index.html --name Narratium --use-local-file --icon ./public/icon.ico",
    "pake-linux": "pake out/index.html --name narratium --use-local-file --icon ./public/icon.png"
  },
  "dependencies": {
    "@langchain/core": "^0.3.44",
    "@langchain/ollama": "^0.2.0",
    "@langchain/openai": "^0.5.5",
    "@supabase/supabase-js": "^2.50.0",
    "@types/react-color": "^3.0.13",
    "@vercel/analytics": "^1.5.0",
    "better-sqlite3": "^11.9.1",
    "dotenv": "^16.5.0",
    "elkjs": "^0.10.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "framer-motion": "^12.6.3",
    "gsap": "^3.12.7",
    "langchain": "^0.3.24",
    "lucide-react": "^0.514.0",
    "marked": "^15.0.12",
    "next": "15.2.4",
    "png-chunk-text": "^1.0.0",
    "png-chunks-encode": "^1.0.0",
    "png-chunks-extract": "^1.0.0",
    "react": "^19.0.0",
    "react-color": "^2.19.3",
    "react-dom": "^19.0.0",
    "react-hot-toast": "^2.5.2",
    "react-markdown": "^10.1.0",
    "react-parallax-tilt": "^1.7.297",
    "reactflow": "^11.11.4",
    "uuid": "^11.1.0",
    "zod": "^3.25.67",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@next/eslint-plugin-next": "^15.3.1",
    "@tailwindcss/postcss": "^4",
    "@types/better-sqlite3": "^7.6.13",
    "@types/node": "^20",
    "@types/png-chunk-text": "^1.0.3",
    "@types/png-chunks-encode": "^1.0.2",
    "@types/png-chunks-extract": "^1.0.2",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@typescript-eslint/eslint-plugin": "^8.31.0",
    "@typescript-eslint/parser": "^8.31.0",
    "@vitest/expect": "^3.2.2",
    "concurrently": "^9.1.2",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^4",
    "typescript": "^5",
    "vitest": "^3.2.2"
  }
}
</file>

<file path="postcss.config.mjs">

</file>

<file path="README_ZH.md">
<h1 style="border-bottom: none" align="center">
  <a href="https://narratium.org/">Narratium.ai</a>
  <br />
  <p>ÂàõÂª∫„ÄÅÊ∏∏Áé©Âíå‰∏éAIËßíËâ≤ÊâÆÊºî</p>
</h1>

<div align="center">
  <blockquote>
    <em><strong>‰∏ñÁïåÂπøÈòîÊó†Âû†ÔºåËÆ©ÊÉ≥Ë±°ÂäõÂºïÈ¢ÜÂâçË°åÔºå‰ΩÜ‰∫∫ÂøÉÊ∞∏Ëøú‰∏çÂèØÁõ¥ËßÜ</strong></em><br>
    <em><strong>The world is vast, let imagination lead, but human hearts remain forever inscrutable</strong></em>
  </blockquote>
</div>

<br>

![Narratium.ai](/public/banner.png)

<p align="center">
  <em>‰∏Ä‰∏™ÂºÄÊ∫êÁöÑAIËßíËâ≤Âπ≥Âè∞ÔºåÁî®‰∫éÊûÑÂª∫„ÄÅÂÆöÂà∂Âíå‰∏éËôöÊãüËßíËâ≤ËÅäÂ§©</em>
  <br>
  <em>‰∏∫ÊûÑÂª∫‰∫íÂä®‰∏ñÁïåÁöÑ‰ΩúÂÆ∂„ÄÅÂºÄÂèëËÄÖÂíåÊïÖ‰∫ãËÆ≤Ëø∞ËÄÖËÄåËÆæËÆ°</em>
</p>

<div align="center">
  <a href="https://narratium.org">üîó Live Demo</a> &nbsp;|&nbsp;
  <a href="https://deepwiki.com/Narratium/Narratium.ai/">üìñ DeepWiki Docs</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/stargazers">‚≠ê Star Us</a> &nbsp;|&nbsp;
  <a href="https://discord.gg/PP7EpSzDfU">üí¨ Discord Community</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/releases">üíæ Download</a> &nbsp;|&nbsp;
  <a href="./README_ZH.md">üá®üá≥ ‰∏≠ÊñáÊñáÊ°£</a>
</div>

<br>

<div align="center">

![GitHub stars](https://img.shields.io/github/stars/Narratium/Narratium.ai?style=social)
![GitHub forks](https://img.shields.io/github/forks/Narratium/Narratium.ai?style=social)
![GitHub commits](https://img.shields.io/github/commit-activity/m/Narratium/Narratium.ai)
![GitHub Downloads](https://img.shields.io/github/downloads/Narratium/Narratium.ai/total)

</div>

<div align="center">
  <em><strong>ËßíËâ≤„ÄÅ‰∏ñÁïåÂíåÂØπËØù ‚Äî Âú®Narratium‰∏≠ÂÆåÁæéÁªü‰∏Ä</strong></em>
</div>

<br>

<img src="./assets/demo_show.gif" style="width: 100%"/>

## ÂºÄÂßã‰ΩøÁî®Âπ∂ÂÖ≥Ê≥®Êàë‰ª¨

<div align="center">
  <strong>ÁªôÊàë‰ª¨ÊòüÊ†áÔºåÊÇ®Â∞ÜÂèäÊó∂Êî∂Âà∞GitHubÁöÑÊâÄÊúâÂèëÂ∏ÉÈÄöÁü•ÔºÅ</strong>
</div>

<br>

<img src="./assets/welcome_star.gif" style="width: 100%"/>

| ‰ªÄ‰πàÊòØNarratium |
| :---------------- |

[Narratium.ai](https://narratium.org/) ÊòØ‰∏Ä‰∏™Áî®‰∫éÂàõÂª∫AIËßíËâ≤„ÄÅÊ≤âÊµ∏Âºè‰∏ñÁïåÂíåÂä®ÊÄÅÂØπËØùÁöÑÂºÄÊ∫êÂπ≥Âè∞„ÄÇÂÆÉÊòØÊÇ®ÊûÑÂª∫‰∏™ÊÄßÂåñËßíËâ≤ÊâÆÊºîÂÜíÈô©ÁöÑÂàõÊÑèÂ∑•‰ΩúÂÆ§ ‚Äî ‰ªéÊÉÖÊÑüÊóÖÁ®ãÂà∞Âè≤ËØó‰º†Â•á„ÄÇ

| Âø´ÈÄüÂºÄÂßã |
| :---------- |

Â¶ÇÈúÄËØ¶ÁªÜÁöÑÂÆâË£ÖÂíåËÆæÁΩÆËØ¥ÊòéÔºåËØ∑ÂèÇÈòÖÊàë‰ª¨ÁöÑ[Âø´ÈÄüÂºÄÂßãÊåáÂçó](./docs/GETTING_STARTED.md)

Â¶ÇÈúÄËØ¶ÁªÜÁöÑ Vercel ÈÉ®ÁΩ≤ËØ¥ÊòéÔºåËØ∑ÂèÇÈòÖ [Vercel ÈÉ®ÁΩ≤ÊåáÂçó](./docs/VERCEL_DEPLOYMENT.md)„ÄÇ

Â¶ÇÈúÄÂÆ¢Êà∑Á´Ø‰∏ãËΩΩÁâàÊú¨ÔºåËØ∑ËÆøÈóÆ [Mac„ÄÅWindows„ÄÅLinux ‰∏ãËΩΩÈ°µÈù¢](https://github.com/Narratium/Narratium.ai/releases)

| ÂäüËÉΩÁâπÊÄß |
| :------- |

- **Ê≤âÊµ∏ÂºèÂÜíÈô©Ê®°Âºè**: ÂàõÂª∫‰∏™ÊÄßÂåñ‰∏ñÁïåÂπ∂ÂÅöÂá∫ÈáçË¶ÅÁöÑÂÜ≥Á≠ñ„ÄÇ
- **ÂèØËßÜÂåñËÆ∞ÂøÜÁÆ°ÁêÜ**: Âü∫‰∫éReact FlowÁöÑ‰ºöËØùËøΩË∏™ÂíåÂàÜÊîØ„ÄÇ
- **ËßíËâ≤Âç°Áâá‰∏éËÉåÊôØ**: ÂÖºÂÆπSillyTavernÂç°ÁâáÔºåÂú®‰∏ÄÂ§ÑÁÆ°ÁêÜÊâÄÊúâÂÜÖÂÆπ„ÄÇ

| Narratium‰∏éÂÖ∂‰ªñAIËßíËâ≤ÊâÆÊºîÂπ≥Âè∞ÂØπÊØî |
| :---------------------------------------- |

<table style="width: 100%;">
  <tr>
    <th align="center">ÂäüËÉΩ</th>
    <th align="center">Narratium.ai</th>
    <th align="center">SillyTavern</th>
    <th align="center">AI Dungeon</th>
  </tr>
  <tr>
    <td><strong>ÂºÄÊ∫ê</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Êñ∞ÊâãÂèãÂ•Ω</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (Â§çÊùÇËÆæÁΩÆ)</td>
    <td align="center">‚úÖ (‰ΩÜÊµÅÁ®ãÊúâÈôê)</td>
  </tr>
  <tr>
    <td><strong>ËßíËâ≤ËÆ∞ÂøÜ‰∏éËøΩË∏™</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (Âü∫‰∫éÊèí‰ª∂)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>‰∏ñÁïå‰π¶ÊîØÊåÅ</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (ÈÄöËøáÊâ©Â±ï)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>ÈïøÊúüÂØπËØùÊîØÊåÅ</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (‰∏ä‰∏ãÊñáÊúâÈôê)</td>
  </tr>
  <tr>
    <td><strong>Á¶ªÁ∫ø/Êú¨Âú∞ÈÉ®ÁΩ≤</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>ÂèØËßÜÂåñÁïåÈù¢/UIÁ≤æÁæé</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (ÊûÅÁÆÄ)</td>
    <td align="center">‚úÖ</td>
  </tr>
  <tr>
    <td><strong>Êó†ÈôêÂàÜÊîØÊïÖ‰∫ãÊÉÖËäÇ</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (ÈúÄË¶ÅÊâãÂä®Âä™Âäõ)</td>
    <td align="center">‚úÖ (‰ΩÜ‰∏çÁ®≥ÂÆö)</td>
  </tr>
</table>

| ËÆ∏ÂèØËØÅÊ¶ÇËßà |
| :--------------- |

Êú¨È°πÁõÆÁî±‰∏§‰∏™ÂÖ∑ÊúâÁã¨Á´ãËÆ∏ÂèØËØÅÁöÑ‰∏çÂêåÈÉ®ÂàÜÁªÑÊàêÔºö

- ‚úÖ ‰ª£Á†Å: MITËÆ∏ÂèØËØÅ ‚Äî ÂºÄÊîæÁî®‰∫éÂïÜ‰∏öÂíåÈùûÂïÜ‰∏öÁî®ÈÄîÔºåÈúÄË¶ÅÁΩ≤Âêç„ÄÇ
- üîí ÂÜÖÂÆπ: CC BY-NC-SA 4.0 ‚Äî ‰ªÖÈôêÈùûÂïÜ‰∏öÁî®ÈÄîÔºåÈúÄË¶ÅÁΩ≤ÂêçÂíåÁõ∏ÂêåËÆ∏ÂèØËØÅÂÖ±‰∫´„ÄÇ

> ÊúâÂÖ≥ÂÆåÊï¥ËÆ∏ÂèØËØÅËØ¶ÊÉÖÔºåËØ∑ÂèÇÈòÖ [LICENSE](./LICENSE)„ÄÇ

| ËÅîÁ≥ª‰∏éÊîØÊåÅ |
| :---------------- |

* Â¶ÇÊûú‰Ω†ÂñúÊ¨¢Ëøô‰∏™È°πÁõÆÔºåÊàë‰ª¨ÈùûÂ∏∏Ê¨¢Ëøé‰Ω†Âä†ÂÖ•
* If you like this project, we warmly welcome you to join us
[DiscordÁ§æÂå∫](https://discord.gg/PP7EpSzDfU)

| ‰ª£Á†ÅË¥°ÁåÆËÄÖ |
| :--------------- |

[![Contributors](https://contrib.rocks/image?repo=Narratium/Narratium.ai)](https://github.com/Narratium/Narratium.ai/graphs/contributors)

| ÂÖ∂‰ªñ |
| :----- |

ÊÑüË∞¢ÊâÄÊúâÂÆòÊñπÁΩëÁ´ôÊµãËØïAPIËµûÂä©ÂïÜ

| ÊòüÊ†áÂ¢ûÈïø |
| :---------- |

[![Stargazers over time](https://starchart.cc/Narratium/Narratium.ai.svg?variant=adaptive)](https://starchart.cc/Narratium/Narratium.ai)
</file>

<file path="README.md">
<h1 style="border-bottom: none" align="center">
  <a href=https://narratium.org/">Narratium.ai</a>
  <br />
  <p>Create, Play, and Roleplay with AI</p>
</h1>

<div align="center">
  <blockquote>
    <em><strong>The world is vast, let imagination lead, but human hearts remain forever inscrutable</strong></em><br>
    <em><strong>‰∏ñÁïåÂπøÈòîÊó†Âû†ÔºåËÆ©ÊÉ≥Ë±°ÂäõÂºïÈ¢ÜÂâçË°åÔºå‰ΩÜ‰∫∫ÂøÉÊ∞∏Ëøú‰∏çÂèØÁõ¥ËßÜ</strong></em>
  </blockquote>
</div>

<br>

![Narratium.ai](/public/banner.png)

<p align="center">
  <em>An open-source AI character platform to build, customize, and chat with virtual personas</em>
  <br>
  <em>For writers, developers, and storytellers building interactive worlds</em>
</p>

<div align="center">
  <a href="https://narratium.org">üîó Live Demo</a> &nbsp;|&nbsp;
  <a href="https://deepwiki.com/Narratium/Narratium.ai/">üìñ DeepWiki Docs</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/stargazers">‚≠ê Star Us</a> &nbsp;|&nbsp;
  <a href="https://discord.gg/PP7EpSzDfU">üí¨ Discord Community</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/releases">üíæ Download</a> &nbsp;|&nbsp;
  <a href="./README_ZH.md">üá®üá≥ ‰∏≠ÊñáÊñáÊ°£</a>
</div>

<br>

<div align="center">

![GitHub stars](https://img.shields.io/github/stars/Narratium/Narratium.ai?style=social)
![GitHub forks](https://img.shields.io/github/forks/Narratium/Narratium.ai?style=social)
![GitHub commits](https://img.shields.io/github/commit-activity/m/Narratium/Narratium.ai)
![GitHub Downloads](https://img.shields.io/github/downloads/Narratium/Narratium.ai/total)

</div>

<div align="center">
  <em><strong>Characters, worlds, and conversations ‚Äî beautifully unified in Narratium</strong></em>
</div>

<br>

<img src="./assets/demo_show.gif" style="width: 100%"/>

## Getting started & staying tuned with us

<div align="center">
  <strong>Star us, and you will receive all release notifications from GitHub without any delay!</strong>
</div>

<br>

<img src="./assets/welcome_star.gif" style="width: 100%"/>

| What is Narratium |
| :---------------- |

[Narratium.ai](https://narratium.org/) is an open-source platform for creating AI characters, immersive worlds, and dynamic conversations.It's your creative studio for building personalized roleplay adventures ‚Äî from emotional journeys to epic sagas.

| Quickly Start |
| :---------- |

For detailed installation and setup instructions, please refer to our [Getting Started Guide](./docs/GETTING_STARTED.md)

For detailed Vercel deployment instructions, please refer to the [Vercel Deployment Guide](./docs/VERCEL_DEPLOYMENT.md).

For Download Version: please refer to the [Download for Mac, Windows, Linux](https://github.com/Narratium/Narratium.ai/releases)

| Features |
| :------- |

- **Immersive Adventure Mode**: Create personalized worlds and make decisions that matter.
- **Visual Memory Management**: React Flow-powered session tracing and branching.
- **Character Cards & Lore**: Compatible with SillyTavern cards, manage everything in one place.

| Narratium vs. Other AI Roleplay Platforms |
| :---------------------------------------- |

<table style="width: 100%;">
  <tr>
    <th align="center">Feature</th>
    <th align="center">Narratium.ai</th>
    <th align="center">SillyTavern</th>
    <th align="center">AI Dungeon</th>
  </tr>
  <tr>
    <td><strong>Open Source</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Beginner Friendly</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (complex setup)</td>
    <td align="center">‚úÖ (but limited flow)</td>
  </tr>
  <tr>
    <td><strong>Character Memory &amp; Tracking</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (plugin-based)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Worldbook Support</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (via extensions)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Long-term Conversation Support</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (limited context)</td>
  </tr>
  <tr>
    <td><strong>Offline / Local Deployment</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Visual Interface / UI Polish</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (minimal)</td>
    <td align="center">‚úÖ</td>
  </tr>
  <tr>
    <td><strong>Infinite Branching Storylines</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (manual effort)</td>
    <td align="center">‚úÖ (but unstable)</td>
  </tr>
</table>

| License Overview |
| :--------------- |

This project consists of two distinct parts with independent licenses:

- ‚úÖ Code: MIT License ‚Äî open for commercial and non-commercial use with attribution.
- üîí Content: CC BY-NC-SA 4.0 ‚Äî non-commercial use only, with attribution and same-license sharing required.

> For full license details, please refer to the [LICENSE](./LICENSE).

| Contact & Support |
| :---------------- |

* Â¶ÇÊûú‰Ω†ÂñúÊ¨¢Ëøô‰∏™È°πÁõÆÔºåÊàë‰ª¨ÈùûÂ∏∏Ê¨¢Ëøé‰Ω†Âä†ÂÖ•
* If you like this project, we warmly welcome you to join us
[Discord community](https://discord.gg/PP7EpSzDfU)

| Code Contributer |
| :--------------- |

[![Contributors](https://contrib.rocks/image?repo=Narratium/Narratium.ai)](https://github.com/Narratium/Narratium.ai/graphs/contributors)

| Others |
| :----- |

Thanks all Official Website Test API Sponsor

| Star Growth |
| :---------- |

[![Stargazers over time](https://starchart.cc/Narratium/Narratium.ai.svg?variant=adaptive)](https://starchart.cc/Narratium/Narratium.ai)
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "out/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

</files>
