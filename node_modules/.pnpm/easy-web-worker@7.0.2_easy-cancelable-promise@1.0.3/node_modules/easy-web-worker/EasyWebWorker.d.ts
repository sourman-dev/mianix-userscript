import { CancelablePromise } from 'easy-cancelable-promise/CancelablePromise';
import { EasyWebWorkerBody, IWorkerConfig, TOverrideConfig } from './types';
import { EasyWebWorkerMessage } from './EasyWebWorkerMessage';
/**
 * This is a class to create an EasyWebWorker
 * @template TPayload - Indicates if your WORKERS messages requires a parameter to be provided, NULL indicates they doesn't
 * @template TResult - Indicates if your WORKERS messages has a result... NULL indicates all you messages are Promise<void>
 * @param {EasyWebWorkerBody<TPayload, TResult> | EasyWebWorkerBody<TPayload, TResult>[]} workerBody -
 * this parameter should be a function or set of functions that will become the body of your Web-Worker
 * IMPORTANT!! all WORKERS content is gonna be transpiled on run time, so you can not use any variable, method of resource that weren't included into the WORKER.
 * the above the reason of why we are injecting all worker context into the MessageBody Callbacks, so,
 * you could easily identify what is on the context of your Worker.
 * @param {Partial<IWorkerConfig>} WorkerConfig - You could add extra configuration to your worker,
 * consult IWorkerConfig description to have more information
 * */
export declare class EasyWebWorker<TPayload = null, TResult = void, TPrimitiveParameters extends any[] = unknown[]> {
    /**
     * this parameter should be a function or set of functions that will become the body of your Web-Worker
     * IMPORTANT!! all WORKERS content is gonna be transpiled on run time, so you can not use any variable, method of resource that weren't included into the WORKER.
     * the above the reason of why we are injecting all worker context into the MessageBody Callbacks, so,
     * you could easily identify what is on the context of your Worker.
     */
    protected source: EasyWebWorkerBody<TPayload, TResult> | EasyWebWorkerBody<TPayload, TResult>[] | string | URL | Worker | Worker[];
    /**
     * This is the URL of the worker file
     */
    workerUrl?: string | URL | null;
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    name: string;
    /**
     * Worker configuration
     */
    config: Partial<IWorkerConfig<TPrimitiveParameters>>;
    /**
     * @deprecated Directly modifying the worker may lead to unexpected behavior. Use it only if you know what you are doing.
     * this property will be removed in the next major version
     */
    get worker(): Worker;
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    maxWorkers: number;
    /**
     * @deprecated avoid direct access to the workers unless you know what you are doing
     */
    workers: Worker[];
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    keepAlive: boolean;
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    warmUpWorkers: boolean;
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    terminationDelay: number;
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    primitiveParameters: TPrimitiveParameters;
    /**
     * @deprecated this will be removed in the next major version and keep it just inside the config object
     */
    workerOptions?: WorkerOptions;
    /**
     * These where send to the worker but not yet resolved
     */
    private messagesQueue;
    /**
     * @deprecated this will be removed in the next major version to be grouped as a worker option object
     * This is the list of scripts that will be imported into the worker
     */
    scripts: string[];
    /**
     * @deprecated this will be removed in the next major version to be grouped as a worker option object
     * This is the callback that will be executed when the worker throws an error
     */
    onWorkerError: (error: ErrorEvent) => void;
    protected get isExternalWorkerFile(): boolean;
    constructor(
    /**
     * this parameter should be a function or set of functions that will become the body of your Web-Worker
     * IMPORTANT!! all WORKERS content is gonna be transpiled on run time, so you can not use any variable, method of resource that weren't included into the WORKER.
     * the above the reason of why we are injecting all worker context into the MessageBody Callbacks, so,
     * you could easily identify what is on the context of your Worker.
     */
    source: EasyWebWorkerBody<TPayload, TResult> | EasyWebWorkerBody<TPayload, TResult>[] | string | URL | Worker | Worker[], 
    /**
     * You could import scripts into your worker, this is useful if you want to use external libraries
     */
    config?: Partial<IWorkerConfig<TPrimitiveParameters>>);
    private warmUp;
    private fillWorkerMethods;
    private createNewWorker;
    private getWorkerFromPool;
    protected computeWorkerBaseSource: () => {
        isArrayOfWebWorkers: boolean;
    };
    private RemoveMessageFromQueue;
    /**
     * Categorizes the worker response and executes the corresponding callback
     */
    private executeMessageCallback;
    protected getWorkerUrl(): string;
    /**
     * Execute the cancel callback of each message in the queue if provided
     * @param {unknown} reason - reason messages where canceled
     * @param {boolean} force - if true, the messages will be cancelled immediately without waiting for the worker to respond
     * This action will reboot the worker
     */
    cancelAll(reason?: unknown, { force }?: {
        force?: boolean;
    }): CancelablePromise<unknown[]>;
    protected addMessageToQueue(message: EasyWebWorkerMessage<unknown, unknown>): void;
    /**
     * Send a message to the worker queue to an specific method
     * @template TResult_ - result type of the message (if any)
     * @template TPayload_ - payload type of the message  (if any)
     * @param {string} method - method name
     * @param {TPayload} payload - whatever json data you want to send to the worker
     * @returns {IMessagePromise<TResult>} generated defer that will be resolved when the message completed
     */
    sendToMethod<TResult_ = void, TPayload_ = null>(method: string, payload?: TPayload_, transfer?: Transferable[]): CancelablePromise<TResult_>;
    /**
     * Send a message to the worker queue
     * @param {TPayload} payload - whatever json data you want to send to the worker
     * @returns {IMessagePromise<TResult>} generated defer that will be resolved when the message completed
     */
    send: [TPayload] extends [null] ? () => CancelablePromise<TResult> : (payload: TPayload, transfer?: Transferable[]) => CancelablePromise<TResult>;
    private sendToWorker;
    /**
     * This method terminate all current messages and send a new one to the worker queue
     * @param {TPayload} payload - whatever json data you want to send to the worker, should be serializable
     * @param {unknown} reason - reason why the worker was terminated
     * @returns {IMessagePromise<TResult>} generated defer that will be resolved when the message completed
     */
    override: [TPayload] extends [null] ? (reason?: unknown, config?: TOverrideConfig) => CancelablePromise<TResult> : (payload: TPayload, reason?: unknown, config?: TOverrideConfig) => CancelablePromise<TResult>;
    /**
     * This method will alow the current message to be completed and send a new one to the worker queue after it, all the messages after the current one will be canceled
     * @param {TPayload} payload - whatever json data you want to send to the worker should be serializable
     * @param {unknown} reason - reason why the worker was terminated
     * @returns {IMessagePromise<TResult>} generated defer that will be resolved when the message completed
     */
    overrideAfterCurrent: [TPayload] extends [null] ? (reason?: unknown, TOverrideConfig?: any) => CancelablePromise<TResult> : (payload: TPayload, reason?: unknown, config?: TOverrideConfig) => CancelablePromise<TResult>;
    /**
     * This method will reboot the worker and cancel all the messages in the queue
     * @param {unknown} reason - reason why the worker will be restarted
     */
    reboot(reason?: unknown): CancelablePromise<unknown[]>;
    /**
     * This method will remove the WebWorker and the BlobUrl
     */
    dispose(): Promise<void>;
}
