type AutoIncrementDefault = {
    type: "autoincrement";
};
type NowDefault = {
    type: "now";
};
type StaticDefault<T> = {
    type: "static";
    value: T;
};
type FunctionDefault<T> = {
    type: "function";
    fn: () => T;
};
type FieldType = "string" | "number" | "boolean" | "date";
type FieldDefinition<T extends FieldType> = {
    type: T;
    primaryKey?: boolean;
    unique?: boolean;
    default?: DefaultValueForType<T>;
};
declare const fieldSymbol: unique symbol;
type FieldDefinitionWithMeta<T extends FieldType, HasDefault extends boolean, IsPrimaryKey extends boolean, IsUnique extends boolean> = FieldDefinition<T> & {
    [fieldSymbol]: true;
    hasDefault: HasDefault;
    isPrimaryKey: IsPrimaryKey;
    isUnique: IsUnique;
};
type ObjectStoreSchema = {
    fields: {
        [fieldName: string]: FieldDefinitionWithMeta<FieldType, boolean, boolean, boolean>;
    };
};
export type Schema = {
    [storeName: string]: ObjectStoreSchema;
};
type InferFieldType<T extends FieldType> = T extends "string" ? string : T extends "number" ? number : T extends "boolean" ? boolean : T extends "date" ? Date : never;
type DefaultValueForType<T extends FieldType> = T extends "number" ? AutoIncrementDefault | StaticDefault<number> | FunctionDefault<number> : T extends "date" ? NowDefault | StaticDefault<Date> | FunctionDefault<Date> : T extends "string" ? StaticDefault<string> | FunctionDefault<string> : T extends "boolean" ? StaticDefault<boolean> | FunctionDefault<boolean> : never;
type InferModelShape<S extends ObjectStoreSchema> = {
    [K in keyof S["fields"]]: InferFieldType<S["fields"][K]["type"]>;
};
type PrimaryKey<T extends ObjectStoreSchema> = {
    [K in keyof T["fields"] as T["fields"][K]["isPrimaryKey"] extends true ? K : never]: InferFieldType<T["fields"][K]["type"]>;
};
type RequiredFields<T extends ObjectStoreSchema> = {
    [K in keyof T["fields"] as T["fields"][K]["hasDefault"] extends false ? K : never]: InferFieldType<T["fields"][K]["type"]>;
};
type OptionalFields<T extends ObjectStoreSchema> = {
    [K in keyof T["fields"] as T["fields"][K]["hasDefault"] extends true ? K : never]?: InferFieldType<T["fields"][K]["type"]>;
};
type CreateInput<T extends ObjectStoreSchema> = RequiredFields<T> & OptionalFields<T>;
type UpdateInput<T extends ObjectStoreSchema> = Partial<Omit<InferModelShape<T>, keyof PrimaryKey<T>>>;
type IdType<T extends ObjectStoreSchema> = PrimaryKey<T>[keyof PrimaryKey<T>];
type UniqueFields<T extends ObjectStoreSchema> = {
    [K in keyof T["fields"] as T["fields"][K]["isUnique"] extends true ? K : T["fields"][K]["isPrimaryKey"] extends true ? K : never]: InferFieldType<T["fields"][K]["type"]>;
};
/**
 * Type helper to ensure at least one field is provided.
 *
 * @example
 * type Example = AtLeastOne<{ id: string; name: string }>
 * // Example is now: { id: string } | { name: string } | { id: string; name: string }
 */
export type AtLeastOne<T> = {
    [K in keyof T]: {
        [P in K]: T[P];
    } & Partial<Omit<T, K>>;
}[keyof T];
export type ModelMethods<T extends ObjectStoreSchema> = {
    create: (data: CreateInput<T>) => Promise<InferModelShape<T>>;
    findAll: () => Promise<InferModelShape<T>[]>;
    findById: (id: IdType<T>) => Promise<InferModelShape<T> | undefined>;
    update: (id: IdType<T>, data: UpdateInput<T>) => Promise<InferModelShape<T>>;
    delete: (id: IdType<T>) => Promise<void>;
    upsert: (params: {
        where: AtLeastOne<UniqueFields<T>>;
        create: CreateInput<T>;
        update: UpdateInput<T>;
    }) => Promise<InferModelShape<T>>;
};
type SeedInput<S extends Schema> = {
    [K in keyof S]?: CreateInput<S[K]>[];
};
type Versioning = {
    type: "auto";
} | {
    type: "manual";
    version: number;
};
type WhereOperator = "equals" | "startsWith" | "endsWith";
type OrderByOperator = "asc" | "desc";
declare class QueryBuilder<T> {
    private db;
    private storeName;
    private filters;
    private sortField?;
    private sortOrder;
    private limitCount?;
    private offsetCount?;
    constructor(db: IDBDatabase, storeName: string);
    where(field: keyof T, operator: WhereOperator, value: any): this;
    orderBy(field: keyof T, order?: OrderByOperator): this;
    limit(count: number): this;
    offset(count: number): this;
    run(): Promise<T[]>;
    private applyFilters;
    private applySorting;
}
export type EventCallback<S extends Schema> = (storeName: keyof S, record: any) => void;
export type InitOptions<S extends Schema> = {
    schema: S;
    dbName?: string;
    versioning?: Versioning;
    migrations?: (oldVersion: number, newVersion: number, db: IDBDatabase) => void;
    debug?: boolean;
};
export declare class ORM<S extends Schema> {
    #private;
    private db;
    private schema;
    private dbName;
    private versioning;
    private migrations?;
    private debug;
    private currentVersion;
    private eventHandlers;
    private constructor();
    /**
     * Initializes a new `ORM` instance.
     *
    //  * @param {InitOptions<S>} options - Configuration options for initializing the ORM, including the schema, database name, versioning strategy, migrations, and debug flag.
     * @param {S} options.schema - The schema of the database.
     * @param {string} [options.dbName] - The name of the database.
     * @param {Versioning} [options.versioning] - The versioning strategy for the database.
     * @param {(oldVersion: number, newVersion: number, db: IDBDatabase) => void} [options.migrations] - The callback for the manual version migration.
     * @param {boolean} [options.debug] - Wether to enable debug logs
     * @returns {Promise<ORM<S>>} A promise that resolves to the initialized ORM instance.
     */
    static init<S extends Schema>(options: InitOptions<S>): Promise<ORM<S>>;
    migrate(targetVersion: number): Promise<void>;
    transaction(callback: (trx: {
        [K in keyof S]: ModelMethods<S[K]>;
    }) => Promise<void>): Promise<void>;
    query<K extends keyof S>(storeName: K): QueryBuilder<S[K]["fields"]>;
    /**
     * Seed the database with mock data. This is useful for debugging purposes or creating
     * placeholder records.
     *
     * @param data
     */
    seed(data: SeedInput<S>): Promise<void>;
    /**
     * Returns metadata about your database, including size, records and indexes.
     */
    meta(): Promise<{
        version: number;
        stores: {
            [K in keyof S]: {
                recordCount: number;
                size: string;
                indexes: string[];
                keyRange: {
                    lower: any;
                    upper: any;
                } | null;
                lastUpdated: Date | null;
            };
        };
    }>;
    raw(): IDBDatabase;
    get events(): {
        on: (eventName: "create" | "update" | "delete", callback: EventCallback<S>) => () => void;
        trigger: (eventName: "create" | "update" | "delete", storeName: keyof Schema, record: any) => void;
        off(eventName: "create" | "update" | "delete", callback: EventCallback<S>): void;
        once: (eventName: "create" | "update" | "delete", callback: EventCallback<S>) => void;
    };
    get models(): {
        [K in keyof S]: ModelMethods<S[K]>;
    };
    private estimateSize;
    private initializeDatabase;
    private checkAndApplyMigrations;
    private getTargetVersion;
    private calculateSchemaVersion;
    private isAutoVersioning;
    private migrateDatabase;
    private applySchema;
    private createModelMethods;
    private applyDefaults;
}
/**
 * Defines a field with metadata based on the provided field definition.
 * @param definition The field definition including type, primary key, unique, and default value.
 * @returns The field definition with metadata inserted.
 * @throws Error if the primary key type is not "number", "string", or "date", or if an invalid default type is provided.
 */
export declare function field<T extends FieldType, U extends DefaultValueForType<T> | undefined = undefined, V extends boolean | undefined = undefined, W extends boolean | undefined = undefined>(definition: FieldDefinition<T> & (U extends undefined ? unknown : {
    default: U;
}) & (V extends undefined ? unknown : {
    primaryKey: V;
}) & (W extends undefined ? unknown : {
    unique: W;
})): FieldDefinitionWithMeta<T, U extends undefined ? false : true, V extends undefined ? false : true, W extends undefined ? false : true>;
/**
 * Utility to define a valid schema for the database.
 *
 * @param schema The schema to be validated and converted into a valid schema.
 * @returns The validated schema.
 */
export declare function defineSchema<T extends Schema>(schema: T): T;
export {};
