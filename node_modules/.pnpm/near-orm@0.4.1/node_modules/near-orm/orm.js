const fieldSymbol=Symbol("__isField");class QueryBuilder{db;storeName;filters=[];sortField;sortOrder="asc";limitCount;offsetCount;constructor(e,t){this.db=e,this.storeName=t}where(e,t,r){return this.filters.push({field:e,operator:t,value:r}),this}orderBy(e,t="asc"){return this.sortField=e,this.sortOrder=t,this}limit(e){return this.limitCount=e,this}offset(e){return this.offsetCount=e,this}async run(){return new Promise(((e,t)=>{const r=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).openCursor(),s=[];let n=0;r.onsuccess=t=>{const r=t.target.result;if(r){const t=r.value;if(this.applyFilters(t))if(this.offsetCount&&n<this.offsetCount)n++;else if(s.push(t),this.limitCount&&s.length>=this.limitCount)return void e(this.applySorting(s));r.continue()}else e(this.applySorting(s))},r.onerror=()=>t(r.error)}))}applyFilters(e){return this.filters.every((({field:t,operator:r,value:s})=>{const n=e[t];switch(r){case"equals":return n===s;case"startsWith":return"string"==typeof n&&n.startsWith(s);case"endsWith":return"string"==typeof n&&n.endsWith(s);default:return!0}}))}applySorting(e){return this.sortField?e.sort(((e,t)=>{const r=e[this.sortField],s=t[this.sortField];return r===s?0:"asc"===this.sortOrder?r>s?1:-1:r<s?1:-1})):e}}export class ORM{db;schema;dbName;versioning;migrations;debug;currentVersion=0;eventHandlers={create:[],update:[],delete:[]};#e=0;constructor(e){this.schema=e.schema,this.dbName=e.dbName||"defaultDB",this.versioning=e.versioning||{type:"auto"},this.migrations=e.migrations,this.debug=e.debug?$debug:()=>{}}static async init(e){const t=new ORM({debug:!0,...e});return await t.initializeDatabase(),t}async migrate(e){if(this.isAutoVersioning())throw new Error("Cannot manually migrate when using auto versioning");await this.migrateDatabase(e)}async transaction(e){const t=Object.keys(this.schema),r=this.db.transaction(t,"readwrite"),s=t.reduce(((e,t)=>(e[t]=this.createModelMethods(t,r),e)),{});return new Promise(((t,n)=>{r.oncomplete=()=>{this.debug("Transaction committed successfully"),t()},r.onerror=()=>{this.debug("Transaction failed, rolling back"),n(r.error)},e(s).catch((e=>{this.debug("Error in transaction callback:",e),r.abort(),n(e)}))}))}query(e){return new QueryBuilder(this.db,e)}async seed(e){const t=this.db.transaction(Object.keys(e),"readwrite");return new Promise(((r,s)=>{for(const r of Object.keys(e)){const n=e[r],o=t.objectStore(r);for(const e of n){const t=this.applyDefaults(r,e),n=o.add(t);n.onerror=()=>s(n.error),n.onsuccess=()=>{this.events.trigger("create",r,t)}}}t.oncomplete=()=>{this.debug("Seed data applied successfully"),r()},t.onerror=e=>{this.debug("Transaction failed during seeding",e),s(t.error)}}))}async meta(){const e=this.db.transaction(Object.keys(this.schema),"readonly"),t={version:this.db.version,stores:{}},r=Object.keys(this.schema).map((r=>new Promise(((s,n)=>{const o=e.objectStore(r),i=o.count(),a=Array.from(o.indexNames);let c=0,d=null,l=null,u=null;i.onsuccess=()=>{const e=i.result,h=o.openCursor();h.onsuccess=n=>{const o=n.target.result;if(o){const e=o.value;c+=this.estimateSize(e),(null===d||o.key<d)&&(d=o.key),(null===l||o.key>l)&&(l=o.key),"lastUpdated"in e&&e.lastUpdated instanceof Date&&(!u||e.lastUpdated>u)&&(u=e.lastUpdated),o.continue()}else t.stores[r]={recordCount:e,size:formatBytes(c),indexes:a,keyRange:null!==d&&null!==l?{lower:d,upper:l}:null,lastUpdated:u},s()},h.onerror=()=>n(h.error)},i.onerror=()=>n(i.error)}))));return await Promise.all(r),t}raw(){return this.db}get events(){const e=this;return{on:(t,r)=>{e.eventHandlers[t]||(e.eventHandlers[t]=[]);const s=e.eventHandlers[t].length;return e.eventHandlers[t].push(r),()=>{e.eventHandlers[t].splice(s,1)}},trigger:(t,r,s)=>{if(e.eventHandlers[t])for(const n of e.eventHandlers[t])n(r,s)},off(t,r){e.eventHandlers[t]&&(e.eventHandlers[t]=e.eventHandlers[t].filter((e=>e!==r)))},once:(t,r)=>{const s=(n,o)=>{r(n,o),e.events.off(t,s)};e.events.on(t,s)}}}get models(){return new Proxy({},{get:(e,t)=>{if(t in this.schema)return this.createModelMethods(t);throw new Error(`Model '${t}' not found in schema`)}})}estimateSize(e){const t=JSON.stringify(e);return new Blob([t]).size}async initializeDatabase(){return new Promise(((e,t)=>{const r=indexedDB.open(this.dbName);r.onupgradeneeded=e=>{const t=e.target.result,r=e.oldVersion,s=e.newVersion;this.currentVersion=r,this.debug(`Database upgrade from version ${r} to ${s}`),this.applySchema(t)},r.onsuccess=()=>{this.db=r.result,this.currentVersion=this.db.version,this.debug(`Database "${this.dbName}" opened successfully`),this.checkAndApplyMigrations().then((()=>e(this)))},r.onerror=()=>t(r.error)}))}async checkAndApplyMigrations(){const e=this.getTargetVersion();e>this.currentVersion&&await this.migrateDatabase(e)}getTargetVersion(){return this.versioning&&"auto"===this.versioning.type?this.calculateSchemaVersion():this.versioning?.version||0}calculateSchemaVersion(){let e=0;for(const t in this.schema)e+=Object.keys(this.schema[t].fields).length;const t=this.#e,r=this.currentVersion;return this.#e=e,t!==e?(this.debug("Detected schema change, applying schema..."),this.currentVersion=r+1,this.currentVersion):(this.debug("No schema change detected"),r)}isAutoVersioning(){return(this.versioning&&"auto"===this.versioning.type)??!1}async migrateDatabase(e){return new Promise(((t,r)=>{const s=indexedDB.open(this.dbName,e);s.onupgradeneeded=e=>{const t=e.target.result,r=e.oldVersion,s=e.newVersion;this.debug(`Migrating database from version ${r} to ${s}`),this.applySchema(t),this.migrations&&this.migrations(r,s,t)},s.onsuccess=()=>{this.db=s.result,this.currentVersion=this.db.version,this.debug(`Database migrated to version ${this.currentVersion}`),t()},s.onerror=()=>r(s.error)}))}applySchema(e){for(const t of Object.keys(this.schema)){const r=this.schema[t];if(!e.objectStoreNames.contains(t)){let s;for(const e of Object.keys(r.fields))if(r.fields[e].primaryKey){s=e;break}if(!s)throw new Error(`No primary key defined for object store "${t}"`);const n=e.createObjectStore(t,{keyPath:s,autoIncrement:"autoincrement"===r.fields[s].default?.type||!1});for(const e of Object.keys(r.fields))r.fields[e].unique&&n.createIndex(e,e,{unique:!0})}}this.debug("Schema applied")}createModelMethods(e,t=void 0){return{create:async r=>new Promise(((s,n)=>{let o;o=t||this.db.transaction([e],"readwrite");const i=o.objectStore(e),a=this.applyDefaults(e,r),c=Object.keys(this.schema[e].fields).find((t=>this.schema[e].fields[t].primaryKey));if(!c)throw new Error(`No primary key defined for object store "${e}"`);const d=i.add(a);d.onerror=()=>n(d.error),d.onsuccess=()=>{const t=d.result,r={...a,[c]:t};this.events.trigger("create",e,r),s(r)}})),findAll:async()=>new Promise(((r,s)=>{let n;n=t||this.db.transaction([e],"readonly");const o=n.objectStore(e).getAll();o.onerror=()=>s(o.error),o.onsuccess=()=>r(o.result)})),findById:async r=>new Promise(((s,n)=>{let o;o=t||this.db.transaction([e],"readonly");const i=o.objectStore(e);if("boolean"==typeof r)return void n(new Error("Invalid ID type: boolean is not a valid IDBValidKey"));const a=i.get(r);a.onerror=()=>n(a.error),a.onsuccess=()=>s(a.result||void 0)})),update:async(r,s)=>new Promise(((n,o)=>{let i;i=t||this.db.transaction([e],"readwrite");const a=i.objectStore(e);if("boolean"==typeof r)return void o(new Error("Invalid ID type: boolean is not a valid IDBValidKey"));const c=a.get(r);c.onerror=()=>o(c.error),c.onsuccess=()=>{if(!c.result)return void o(new Error(`Record with id ${r} not found`));const t={...c.result,...s},i=a.put(t);i.onerror=()=>o(i.error),i.onsuccess=()=>{const r={...t};this.events.trigger("update",e,r),n(r)}}})),delete:async r=>new Promise(((s,n)=>{let o;o=t||this.db.transaction([e],"readwrite");const i=o.objectStore(e);if("boolean"==typeof r)return void n(new Error("Invalid ID type: boolean is not a valid IDBValidKey"));const a=i.delete(r);a.onerror=()=>n(a.error),a.onsuccess=()=>{this.events.trigger("delete",e,r),s()}})),upsert:async r=>new Promise(((s,n)=>{let o;o=t||this.db.transaction([e],"readwrite");const i=o.objectStore(e),a=Object.entries(r.where);if(0===a.length)return void n(new Error("Where clause is required."));const c=i.openCursor();c.onerror=()=>n(c.error),c.onsuccess=t=>{const o=t.target.result;if(o){const t=o.value;if((e=>a.every((([t,r])=>e[t]===r)))(t)){const o={...t,...r.update},a=i.put(o);return a.onerror=()=>n(a.error),void(a.onsuccess=()=>{this.events.trigger("update",e,o),s(o)})}o.continue()}else{const t=this.applyDefaults(e,r.create),o=i.add(t);o.onerror=()=>n(o.error),o.onsuccess=()=>{const r=Object.keys(this.schema[e].fields).find((t=>this.schema[e].fields[t].primaryKey));if(!r)throw new Error(`No primary key defined for object store "${e}"`);const n={...t,[r]:o.result};this.events.trigger("create",e,n),s(n)}}}}))}}applyDefaults(e,t){const r=this.schema[e],s={...t};for(const[e,n]of Object.entries(r.fields))if(!(e in t)&&n.default){const t=e;switch(n.default.type){case"now":s[t]=new Date;break;case"static":s[t]=n.default.value;break;case"function":s[t]=n.default.fn()}}return s}}export function field(e){if(e.primaryKey&&!["number","string","date"].includes(e.type))throw new Error(`Primary key must be of type "number", "string" or "date", got "${e.type}"`);if(e.default)switch(e.type){case"number":if(!["autoincrement","static","function"].includes(e.default.type))throw new Error(`Invalid default type for number field: ${e.default.type}`);break;case"date":if(!["now","static","function"].includes(e.default.type))throw new Error(`Invalid default type for date field: ${e.default.type}`);break;case"string":case"boolean":if(!["static","function"].includes(e.default.type))throw new Error(`Invalid default type for ${e.type} field: ${e.default.type}`)}const t=!!e.default,r=!!e.primaryKey,s=!!e.unique;return Object.assign(e,{[fieldSymbol]:!0,hasDefault:t,isPrimaryKey:r,isUnique:s})}export function defineSchema(e){for(const[t,r]of Object.entries(e))for(const[e,s]of Object.entries(r.fields))if(!(fieldSymbol in s)||!0!==s[fieldSymbol])throw new Error(`Field "${e}" in store "${t}" must be created using the \`field\` utility function.`);return e}const $debug=(...e)=>{"undefined"==typeof self&&"undefined"!=typeof window||console.log(...e)},formatBytes=e=>{const t=["B","KB","MB","GB","TB"];let r=0,s=e;for(;s>=1024&&r<t.length-1;)s/=1024,r++;return`${s.toFixed(2)} ${t[r]}`};