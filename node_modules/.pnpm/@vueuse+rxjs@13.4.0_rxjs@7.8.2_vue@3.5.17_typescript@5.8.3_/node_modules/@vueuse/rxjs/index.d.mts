import { ObservableInput, Observable, NextObserver, BehaviorSubject, Subject, Unsubscribable } from 'rxjs';
import { Ref, WatchOptions, MaybeRef, WatchStopHandle, WatchSource, ShallowRef } from 'vue';
import { MultiWatchSources, MapSources, MapOldSources } from '@vueuse/shared';

declare function from<T>(value: ObservableInput<T> | Ref<T>, watchOptions?: WatchOptions): Observable<T>;
declare function fromEvent<T extends HTMLElement | null>(value: MaybeRef<T>, event: string): Observable<Event>;

declare function toObserver<T>(value: Ref<T>): NextObserver<T>;

interface UseObservableOptions<I> {
    onError?: (err: any) => void;
    /**
     * The value that should be set if the observable has not emitted.
     */
    initialValue?: I | undefined;
}
declare function useObservable<H, I = undefined>(observable: Observable<H>, options?: UseObservableOptions<I | undefined>): Readonly<Ref<H | I>>;

type OnCleanup = (cleanupFn: () => void) => void;
type WatchExtractedObservableCallback<Value, OldValue, ObservableElement> = (value: NonNullable<Value>, oldValue: OldValue, onCleanup: OnCleanup) => Observable<ObservableElement>;
interface WatchExtractedObservableOptions {
    onError?: (err: unknown) => void;
    onComplete?: () => void;
}
declare function watchExtractedObservable<T extends MultiWatchSources, E, Immediate extends Readonly<boolean> = false>(sources: [...T], extractor: WatchExtractedObservableCallback<MapSources<T>, MapOldSources<T, Immediate>, E>, callback: (snapshot: E) => void, subscriptionOptions?: WatchExtractedObservableOptions, watchOptions?: WatchOptions<Immediate>): WatchStopHandle;
declare function watchExtractedObservable<T extends Readonly<MultiWatchSources>, E, Immediate extends Readonly<boolean> = false>(source: T, extractor: WatchExtractedObservableCallback<MapSources<T>, MapOldSources<T, Immediate>, E>, callback: (snapshot: E) => void, subscriptionOptions?: WatchExtractedObservableOptions, watchOptions?: WatchOptions<Immediate>): WatchStopHandle;
declare function watchExtractedObservable<T, E, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, extractor: WatchExtractedObservableCallback<T, Immediate extends true ? T | undefined : T, E>, callback: (snapshot: E) => void, subscriptionOptions?: WatchExtractedObservableOptions, watchOptions?: WatchOptions<Immediate>): WatchStopHandle;
declare function watchExtractedObservable<T extends object, E, Immediate extends Readonly<boolean> = false>(source: T, extractor: WatchExtractedObservableCallback<T, Immediate extends true ? T | undefined : T, E>, callback: (snapshot: E) => void, subscriptionOptions?: WatchExtractedObservableOptions, watchOptions?: WatchOptions<Immediate>): WatchStopHandle;

interface UseExtractedObservableOptions<E> extends UseObservableOptions<E> {
    onComplete?: () => void;
}
declare function useExtractedObservable<T extends MultiWatchSources, E, Immediate extends Readonly<boolean> = false>(sources: [...T], extractor: WatchExtractedObservableCallback<MapSources<T>, MapOldSources<T, Immediate>, E>, options?: UseExtractedObservableOptions<E>, watchOptions?: WatchOptions<Immediate>): Readonly<ShallowRef<E>>;
declare function useExtractedObservable<T extends Readonly<MultiWatchSources>, E, Immediate extends Readonly<boolean> = false>(sources: T, extractor: WatchExtractedObservableCallback<MapSources<T>, MapOldSources<T, Immediate>, E>, options?: UseExtractedObservableOptions<E>, watchOptions?: WatchOptions<Immediate>): Readonly<ShallowRef<E>>;
declare function useExtractedObservable<T, E, Immediate extends Readonly<boolean> = false>(sources: WatchSource<T>, extractor: WatchExtractedObservableCallback<T, Immediate extends true ? T | undefined : T, E>, options?: UseExtractedObservableOptions<E>, watchOptions?: WatchOptions<Immediate>): Readonly<ShallowRef<E>>;
declare function useExtractedObservable<T extends object, E, Immediate extends Readonly<boolean> = false>(sources: T, extractor: WatchExtractedObservableCallback<T, Immediate extends true ? T | undefined : T, E>, options?: UseExtractedObservableOptions<E>, watchOptions?: WatchOptions<Immediate>): Readonly<ShallowRef<E>>;

interface UseSubjectOptions<I = undefined> extends Omit<UseObservableOptions<I>, 'initialValue'> {
}
declare function useSubject<H>(subject: BehaviorSubject<H>, options?: UseSubjectOptions): Ref<H>;
declare function useSubject<H>(subject: Subject<H>, options?: UseSubjectOptions): Ref<H | undefined>;

declare function useSubscription(subscription: Unsubscribable): void;

export { from, fromEvent, toObserver, useExtractedObservable, useObservable, useSubject, useSubscription, watchExtractedObservable };
export type { OnCleanup, UseExtractedObservableOptions, UseObservableOptions, UseSubjectOptions, WatchExtractedObservableCallback, WatchExtractedObservableOptions };
