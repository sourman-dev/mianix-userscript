import { Devtools, UnexpectedError } from '@livestore/common';
import type { Scope, Worker } from '@livestore/utils/effect';
import { Effect, Schema, WebChannel } from '@livestore/utils/effect';
import type { MeshNode } from '@livestore/webmesh';
import * as WorkerSchema from '../worker/schema.js';
export * as WorkerSchema from '../worker/schema.js';
declare global {
    var __debugWebmeshNode: any;
}
export declare const makeSessionInfoBroadcastChannel: Effect.Effect<WebChannel.WebChannel<Devtools.SessionInfo.Message, Devtools.SessionInfo.Message>, UnexpectedError, Scope.Scope>;
export declare const makeNodeName: {
    sharedWorker: ({ storeId }: {
        storeId: string;
    }) => string;
    browserExtension: {
        contentscriptMain: (tabId: number) => string;
        contentscriptIframe: (tabId: number) => string;
    };
};
export declare const ClientSessionContentscriptMainReq: Schema.TaggedStruct<"ClientSessionContentscriptMainReq", {
    storeId: typeof Schema.String;
    clientId: typeof Schema.String;
    sessionId: typeof Schema.String;
}>;
export declare const ClientSessionContentscriptMainRes: Schema.TaggedStruct<"ClientSessionContentscriptMainRes", {
    tabId: typeof Schema.Number;
}>;
export declare const makeStaticClientSessionChannel: {
    contentscriptMain: Effect.Effect<WebChannel.WebChannel<{
        readonly _tag: "ClientSessionContentscriptMainReq";
        readonly storeId: string;
        readonly clientId: string;
        readonly sessionId: string;
    }, {
        readonly _tag: "ClientSessionContentscriptMainRes";
        readonly tabId: number;
    }, never>, never, Scope.Scope>;
    clientSession: Effect.Effect<WebChannel.WebChannel<{
        readonly _tag: "ClientSessionContentscriptMainRes";
        readonly tabId: number;
    }, {
        readonly _tag: "ClientSessionContentscriptMainReq";
        readonly storeId: string;
        readonly clientId: string;
        readonly sessionId: string;
    }, never>, never, Scope.Scope>;
};
export declare const connectViaWorker: ({ node, target, worker, }: {
    node: MeshNode;
    target: string;
    worker: Worker.SerializedWorkerPool<typeof WorkerSchema.Request.Type>;
}) => Effect.Effect<void, UnexpectedError, Scope.Scope>;
//# sourceMappingURL=index.d.ts.map