const E = new TextDecoder(), U = new TextEncoder();
function W() {
  let e, t, n = {}, r = "", i = "", u = "";
  return {
    setInstance(o) {
      e = o;
    },
    setHostFormatter(o) {
      t = o;
    },
    createImportObject() {
      let o = new Uint8Array(0), s = 0;
      const g = (l) => {
        o = new Uint8Array(l), s = 0;
      };
      return {
        dprint: {
          host_clear_bytes: (l) => {
            g(l);
          },
          host_read_buffer: (l, a) => {
            o.set(A(e, l, a), s), s += a;
          },
          host_write_buffer: (l, a, _) => {
            A(e, l, _).set(o.slice(a, a + _));
          },
          host_take_file_path: () => {
            r = E.decode(o), g(0);
          },
          host_take_override_config: () => {
            n = JSON.parse(E.decode(o)), g(0);
          },
          host_format: () => {
            const l = E.decode(o);
            try {
              return i = t?.({
                filePath: r,
                fileText: l,
                overrideConfig: n
              }) ?? l, l === i ? 0 : 1;
            } catch (a) {
              return u = String(a), 2;
            }
          },
          host_get_formatted_text: () => (o = U.encode(i), s = 0, o.length),
          host_get_error_text: () => (o = U.encode(u), s = 0, o.length)
        }
      };
    }
  };
}
function D(e, t) {
  t.setInstance(e);
  const n = e.exports, { get_plugin_schema_version: r, set_file_path: i, set_override_config: u, get_formatted_text: o, format: s, get_error_text: g, get_plugin_info: l, get_resolved_config: a, get_config_diagnostics: _, set_global_config: b, set_plugin_config: x, get_license_text: p, reset_config: S } = n, h = r(), v = 3;
  if (h !== 2 && h !== v)
    throw new Error(`Not compatible plugin. Expected schema ${v}, but plugin had ${h}.`);
  let y = !1;
  return {
    setConfig(c, d) {
      C(c, d);
    },
    getConfigDiagnostics() {
      T();
      const c = _();
      return JSON.parse(N(e, c));
    },
    getResolvedConfig() {
      T();
      const c = a();
      return JSON.parse(N(e, c));
    },
    getFileMatchingInfo() {
      const c = l(), d = JSON.parse(N(e, c));
      return {
        // deno-lint-ignore no-explicit-any
        fileExtensions: d.fileExtensions ?? [],
        // deno-lint-ignore no-explicit-any
        fileNames: d.fileNames ?? []
      };
    },
    getPluginInfo() {
      const c = l(), d = JSON.parse(N(e, c));
      return delete d.fileNames, delete d.fileExtensions, d;
    },
    getLicenseText() {
      const c = p();
      return N(e, c);
    },
    formatText(c, d) {
      if (c.bytesRange != null)
        return c.fileText;
      if (t.setHostFormatter(d), T(), c.overrideConfig != null) {
        if (h === 2)
          throw new Error("Cannot set the override configuration for this old plugin.");
        P(e, JSON.stringify(c.overrideConfig)), u();
      }
      P(e, c.filePath), i(), P(e, c.fileText);
      const w = s();
      switch (w) {
        case 0:
          return c.fileText;
        case 1:
          return N(e, o());
        case 2:
          throw new Error(N(e, g()));
        default:
          throw new Error(`Unexpected response code: ${w}`);
      }
    }
  };
  function T() {
    y || C({}, {});
  }
  function C(c, d) {
    S?.(), P(e, JSON.stringify(c)), b(), P(e, JSON.stringify(d)), x(), y = !0;
  }
}
function P(e, t) {
  const n = e.exports, r = U.encode(t), i = r.length, u = n.get_wasm_memory_buffer_size(), o = F(e);
  n.clear_shared_bytes(i);
  let s = 0;
  for (; s < i; ) {
    const g = Math.min(i - s, u);
    A(e, o, g).set(r.slice(s, s + g)), n.add_to_shared_bytes_from_buffer(g), s += g;
  }
  return i;
}
function N(e, t) {
  const n = e.exports, r = n.get_wasm_memory_buffer_size(), i = F(e), u = new Uint8Array(t);
  let o = 0;
  for (; o < t; ) {
    const s = Math.min(t - o, r);
    n.set_buffer_with_shared_bytes(o, s);
    const g = A(e, i, s);
    u.set(g, o), o += s;
  }
  return E.decode(u);
}
function F(e) {
  return e.exports.get_wasm_memory_buffer();
}
function A(e, t, n) {
  return new Uint8Array(
    // deno-lint-ignore no-explicit-any
    e.exports.memory.buffer,
    t,
    n
  );
}
const V = {}, H = K(globalThis, V);
function K(e, t) {
  return new Proxy(e, {
    get(n, r, i) {
      return r in t ? t[r] : e[r];
    },
    set(n, r, i) {
      return r in t && delete t[r], e[r] = i, !0;
    },
    deleteProperty(n, r) {
      let i = !1;
      return r in t && (delete t[r], i = !0), r in e && (delete e[r], i = !0), i;
    },
    ownKeys(n) {
      const r = Reflect.ownKeys(e), i = Reflect.ownKeys(t), u = new Set(i);
      return [...r.filter((o) => !u.has(o)), ...i];
    },
    defineProperty(n, r, i) {
      return r in t && delete t[r], Reflect.defineProperty(e, r, i), !0;
    },
    getOwnPropertyDescriptor(n, r) {
      return r in t ? Reflect.getOwnPropertyDescriptor(t, r) : Reflect.getOwnPropertyDescriptor(e, r);
    },
    has(n, r) {
      return r in t || r in e;
    }
  });
}
const M = new TextDecoder(), R = new TextEncoder();
function I() {
  function e(o) {
    try {
      const s = H;
      s.Deno ? s.Deno.stderr.writeSync(o) : s.process && s.process.stderr.writeSync(o);
    } catch {
    }
  }
  let t, n, r = "", i = "";
  return {
    setInstance(o) {
      t = o;
    },
    setHostFormatter(o) {
      n = o;
    },
    createImportObject() {
      let o = new Uint8Array(0);
      return {
        env: {
          fd_write: (s, g, l, a) => {
            let _ = 0;
            const b = t.exports.memory.buffer, x = new DataView(b);
            for (let p = 0; p < l; p++) {
              const S = g + p * 8, h = x.getUint32(S, !0), v = x.getUint32(S + 4, !0), y = new Uint8Array(b, h, v);
              if (s === 1 || s === 2)
                e(y);
              else
                return 1;
              _ += v;
            }
            return x.setUint32(a, _, !0), 0;
          }
        },
        dprint: {
          host_has_cancelled: () => 0,
          host_write_buffer: (s) => {
            J(t, s, o.length).set(o);
          },
          host_format: (s, g, l, a, _, b, x, p) => {
            const S = u(s, g), h = u(_, b), v = h === "" ? {} : JSON.parse(h), y = u(x, p), T = l === 0 && a === p ? void 0 : [l, a];
            try {
              return r = n?.({
                filePath: S,
                fileText: y,
                bytesRange: T,
                overrideConfig: v
              }) ?? y, y === r ? 0 : 1;
            } catch (C) {
              return i = String(C), 2;
            }
          },
          host_get_formatted_text: () => (o = R.encode(r), o.length),
          host_get_error_text: () => (o = R.encode(i), o.length)
        }
      };
    }
  };
  function u(o, s) {
    return M.decode(J(t, o, s));
  }
}
function O(e, t) {
  t.setInstance(e);
  const n = 1, r = e.exports, { get_shared_bytes_ptr: i, set_file_path: u, set_override_config: o, clear_shared_bytes: s, get_formatted_text: g, format: l, format_range: a, get_error_text: _, get_plugin_info: b, get_config_file_matching: x, get_resolved_config: p, get_config_diagnostics: S, get_license_text: h, register_config: v, release_config: y } = r;
  let T = !1;
  return {
    setConfig(f, m) {
      c(f, m);
    },
    getConfigDiagnostics() {
      C();
      const f = S(n);
      return JSON.parse(w(f));
    },
    getResolvedConfig() {
      C();
      const f = p(n);
      return JSON.parse(w(f));
    },
    getFileMatchingInfo() {
      const f = x(n);
      return JSON.parse(w(f));
    },
    getPluginInfo() {
      const f = b();
      return JSON.parse(w(f));
    },
    getLicenseText() {
      const f = h();
      return w(f);
    },
    formatText(f, m) {
      if (f.bytesRange != null && a == null)
        return f.fileText;
      t.setHostFormatter(m), C(), f.overrideConfig != null && (d(JSON.stringify(f.overrideConfig)), o()), d(f.filePath), u(), d(f.fileText);
      const B = f.bytesRange != null ? a(n, f.bytesRange[0], f.bytesRange[1]) : l(n);
      switch (B) {
        case 0:
          return f.fileText;
        case 1:
          return w(g());
        case 2:
          throw new Error(w(_()));
        default:
          throw new Error(`Unexpected response code: ${B}`);
      }
    }
  };
  function C() {
    T || c({}, {});
  }
  function c(f, m) {
    y(n), d(JSON.stringify({
      global: f,
      plugin: m
    })), v(n), T = !0;
  }
  function d(f) {
    const m = R.encode(f), B = s(m.length);
    J(e, B, m.length).set(m);
  }
  function w(f) {
    const m = i();
    return M.decode(J(e, m, f));
  }
}
function J(e, t, n) {
  return new Uint8Array(
    // deno-lint-ignore no-explicit-any
    e.exports.memory.buffer,
    t,
    n
  );
}
async function L(e) {
  const t = await e;
  if (t.status !== 200)
    throw new Error(`Unexpected status code: ${t.status}
${await t.text()}`);
  if (typeof WebAssembly.instantiateStreaming == "function" && t.headers.get("content-type") === "application/wasm") {
    const n = await WebAssembly.compileStreaming(t);
    return $(n);
  } else
    return t.arrayBuffer().then((n) => z(n));
}
function z(e) {
  const t = new WebAssembly.Module(e);
  return $(t);
}
function $(e) {
  if (k(e) === 3) {
    const n = W(), r = new WebAssembly.Instance(e, n.createImportObject());
    return D(r, n);
  } else {
    const n = I(), r = new WebAssembly.Instance(e, n.createImportObject());
    return O(r, n);
  }
}
function k(e) {
  const t = G(e);
  if (t == null)
    throw new Error("Couldn't determine dprint plugin version. Maybe the js-formatter version is too old?");
  if (t === 3 || t === 4)
    return t;
  throw t > 4 ? new Error(`Unsupported new dprint plugin version '${t}'. Maybe the js-formatter version is too old?`) : new Error(`Unsupported old dprint plugin version '${t}'. Please upgrade the plugin.`);
}
function G(e) {
  function t(r) {
    if (r === "get_plugin_schema_version")
      return 3;
    const i = "dprint_plugin_version_";
    if (r.startsWith(i)) {
      const u = parseInt(r.substring(i.length), 10);
      if (!isNaN(u))
        return u;
    }
  }
  const n = WebAssembly.Module.exports(e);
  for (const r of n) {
    const i = t(r.name);
    if (i != null)
      return i;
  }
}
export {
  z as createFromBuffer,
  $ as createFromWasmModule,
  L as createStreaming
};
