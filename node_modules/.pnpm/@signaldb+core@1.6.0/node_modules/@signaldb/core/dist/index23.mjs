var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import Collection from "./index3.mjs";
import combinePersistenceAdapters from "./index5.mjs";
import createPersistenceAdapter from "./index8.mjs";
import createSignal from "./index21.mjs";
function createReplicationAdapter(options) {
  return createPersistenceAdapter({
    async register(onChange) {
      if (!options.registerRemoteChange)
        return;
      await options.registerRemoteChange(onChange);
    },
    load: () => options.pull(),
    save: (items, changes) => {
      if (!options.push)
        throw new Error("Pushing is not configured for this collection. Try to pass a `push` function to the collection options.");
      return options.push(changes, items);
    }
  });
}
class ReplicatedCollection extends Collection {
  /**
   * Creates a new instance of the `ReplicatedCollection` class.
   * Sets up the replication adapter, combining it with an optional persistence adapter, and
   * initializes signals for tracking remote pull and push operations.
   * @param options - The configuration options for the replicated collection.
   * @param options.pull - A function to fetch data from the remote source.
   * @param options.push - An optional function to send changes and items to the remote source.
   * @param options.registerRemoteChange - An optional function to register a listener for remote changes.
   * @param options.persistence - An optional persistence adapter to combine with replication.
   * @param options.reactivity - A reactivity adapter for observing changes in the collection.
   * @param options.transform - A transformation function to apply to items when retrieving them.
   * @param options.indices - An array of index providers for optimized querying.
   * @param options.enableDebugMode - A boolean to enable or disable debug mode.
   */
  constructor(options) {
    const replicationAdapter = createReplicationAdapter({
      registerRemoteChange: options.registerRemoteChange,
      pull: async () => {
        this.isPullingRemoteSignal.set(true);
        try {
          return await options.pull();
        } finally {
          this.isPullingRemoteSignal.set(false);
        }
      },
      push: options.push ? async (changes, items) => {
        if (!options.push)
          throw new Error("Pushing is not configured for this collection. Try to pass a `push` function to the collection options.");
        this.isPushingRemoteSignal.set(true);
        try {
          await options.push(changes, items);
        } finally {
          this.isPushingRemoteSignal.set(false);
        }
      } : void 0
    });
    const persistenceAdapter = (options == null ? void 0 : options.persistence) ? combinePersistenceAdapters(replicationAdapter, options.persistence) : replicationAdapter;
    super({
      ...options,
      persistence: persistenceAdapter
    });
    __publicField(this, "isPullingRemoteSignal");
    __publicField(this, "isPushingRemoteSignal");
    this.isPullingRemoteSignal = createSignal(options.reactivity, false);
    this.isPushingRemoteSignal = createSignal(options.reactivity, false);
  }
  /**
   * Checks whether the collection is currently performing any loading operation,
   * including pulling or pushing data from/to the remote source, or standard
   * persistence adapter operations.
   * ⚡️ this function is reactive!
   * @returns A boolean indicating if the collection is currently loading or synchronizing.
   */
  isLoading() {
    const isPullingRemote = this.isPullingRemoteSignal.get();
    const isPushingRemote = this.isPushingRemoteSignal.get();
    const isLoading = super.isLoading();
    return isPullingRemote || isPushingRemote || isLoading;
  }
}
export {
  createReplicationAdapter,
  ReplicatedCollection as default
};
