"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class EventEmitter {
  constructor() {
    __publicField(this, "_maxListeners", 100);
    /**
     * We store a set of the listeners for each event.
     */
    __publicField(this, "_listenerStore", /* @__PURE__ */ new Map());
  }
  setMaxListeners(max) {
    this._maxListeners = max;
    return this;
  }
  /**
   * Subscribe to an event with a listener function.
   * @param eventName The event name (key of E).
   * @param listener  A function that receives the emitted arguments.
   * @returns         The emitter instance (for chaining).
   */
  on(eventName, listener) {
    let listenersSet = this._listenerStore.get(eventName);
    if (!listenersSet) {
      listenersSet = /* @__PURE__ */ new Set();
      this._listenerStore.set(eventName, listenersSet);
    }
    listenersSet.add(listener);
    if (listenersSet.size > this._maxListeners) {
      console.warn(`Possible EventEmitter memory leak detected. ${listenersSet.size} ${String(eventName)} listeners added. Use emitter.setMaxListeners() to increase limit.`);
    }
    return this;
  }
  /**
   * Subscribe to an event with a listener function.
   * @param eventName The event name (key of E).
   * @param listener  A function that receives the emitted arguments.
   * @returns         The emitter instance (for chaining).
   */
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  /**
   * Subscribe to an event, handling it only once. Automatically removes
   * the listener after it fires the first time.
   * @param eventName The event name (key of E).
   * @param listener  A function that receives the emitted arguments.
   * @returns         The emitter instance (for chaining).
   */
  once(eventName, listener) {
    const onceWrapper = (...args) => {
      listener(...args);
      this.off(eventName, onceWrapper);
    };
    return this.on(eventName, onceWrapper);
  }
  /**
   * Unsubscribe a previously subscribed listener.
   * @param eventName The event name (key of E).
   * @param listener  The original function passed to `on` or `once`.
   * @returns         The emitter instance (for chaining).
   */
  off(eventName, listener) {
    const listenersSet = this._listenerStore.get(eventName);
    if (!listenersSet)
      return this;
    listenersSet.delete(listener);
    if (listenersSet.size === 0) {
      this._listenerStore.delete(eventName);
    }
    return this;
  }
  /**
   * Unsubscribe a previously subscribed listener.
   * @param eventName The event name (key of E).
   * @param listener  The original function passed to `on` or `once`.
   * @returns         The emitter instance (for chaining).
   */
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  /**
   * Emit (dispatch) an event with a variable number of arguments.
   * @param eventName The event name (key of E).
   * @param args      The arguments to pass to subscribed listeners.
   */
  emit(eventName, ...args) {
    this.listeners(eventName).forEach((listener) => {
      listener(...args);
    });
  }
  /**
   * Returns the array of listener functions currently registered for a given event.
   * @param eventName The event name (key of E).
   * @returns         An array of listener functions.
   */
  listeners(eventName) {
    const listenersSet = this._listenerStore.get(eventName);
    if (!listenersSet)
      return [];
    return [...listenersSet.values()];
  }
  /**
   * Returns the number of listeners for a given event.
   * @param eventName The event name (key of E).
   * @returns         The number of listeners.
   */
  listenerCount(eventName) {
    const listenersSet = this._listenerStore.get(eventName);
    return listenersSet ? listenersSet.size : 0;
  }
  /**
   * Removes all listeners for a given event, or all events if none is specified.
   * @param eventName Optional. If omitted, clears all eventsâ€™ listeners.
   * @returns         The emitter instance (for chaining).
   */
  removeAllListeners(eventName) {
    if (eventName === void 0) {
      for (const [eventName_, listenersSet] of this._listenerStore.entries()) {
        for (const listener of listenersSet.values()) {
          this.off(eventName_, listener);
        }
      }
      this._listenerStore.clear();
    } else {
      const listenersSet = this._listenerStore.get(eventName);
      if (listenersSet) {
        for (const listener of listenersSet.values()) {
          this.off(eventName, listener);
        }
        this._listenerStore.delete(eventName);
      }
    }
    return this;
  }
}
module.exports = EventEmitter;
