import { isNil, isReadonlyArray } from '@livestore/utils';
import { Schema } from '@livestore/utils/effect';
import { SessionIdSymbol } from './adapter-types.js';
import { isQueryBuilder } from './schema/state/sqlite/query-builder/api.js';
import { getResultSchema } from './schema/state/sqlite/query-builder/impl.js';
import { prepareBindValues } from './util.js';
export const getExecArgsFromEvent = ({ eventDef, materializer, db, event, }) => {
    const eventArgsDecoded = event.decoded === undefined ? Schema.decodeUnknownSync(eventDef.schema)(event.encoded.args) : event.decoded.args;
    const eventArgsEncoded = isNil(event.decoded?.args)
        ? undefined
        : Schema.encodeUnknownSync(eventDef.schema)(event.decoded.args);
    const query = (rawQueryOrQueryBuilder) => {
        if (isQueryBuilder(rawQueryOrQueryBuilder)) {
            const { query, bindValues } = rawQueryOrQueryBuilder.asSql();
            const rawResults = db.select(query, prepareBindValues(bindValues, query));
            const resultSchema = getResultSchema(rawQueryOrQueryBuilder);
            return Schema.decodeSync(resultSchema)(rawResults);
        }
        else {
            const { query, bindValues } = rawQueryOrQueryBuilder;
            return db.select(query, prepareBindValues(bindValues, query));
        }
    };
    const res = materializer(eventArgsDecoded, {
        eventDef,
        query,
        // TODO properly implement this
        currentFacts: new Map(),
    });
    const statementRes = mapMaterializerResult(res);
    return statementRes.map((statementRes) => {
        const statementSql = statementRes.sql;
        const bindValues = typeof statementRes === 'string' ? eventArgsEncoded : statementRes.bindValues;
        const writeTables = typeof statementRes === 'string' ? undefined : statementRes.writeTables;
        return { statementSql, bindValues: prepareBindValues(bindValues ?? {}, statementSql), writeTables };
    });
};
const mapMaterializerResult = (materializerResult) => {
    if (isReadonlyArray(materializerResult)) {
        return materializerResult.flatMap(mapMaterializerResult);
    }
    if (isQueryBuilder(materializerResult)) {
        const { query, bindValues } = materializerResult.asSql();
        return [{ sql: query, bindValues: bindValues, writeTables: undefined }];
    }
    else if (typeof materializerResult === 'string') {
        return [{ sql: materializerResult, bindValues: {}, writeTables: undefined }];
    }
    else {
        return [
            {
                sql: materializerResult.sql,
                bindValues: materializerResult.bindValues,
                writeTables: materializerResult.writeTables,
            },
        ];
    }
};
// NOTE we should explore whether there is a more elegant solution
// e.g. by leveraging the schema to replace the sessionIdSymbol
export const replaceSessionIdSymbol = (bindValues, sessionId) => {
    deepReplaceValue(bindValues, SessionIdSymbol, sessionId);
};
const deepReplaceValue = (input, searchValue, replaceValue) => {
    if (Array.isArray(input)) {
        for (const i in input) {
            if (input[i] === searchValue) {
                input[i] = replaceValue;
            }
            else {
                deepReplaceValue(input[i], searchValue, replaceValue);
            }
        }
    }
    else if (typeof input === 'object' && input !== null) {
        for (const key in input) {
            if (input[key] === searchValue) {
                input[key] = replaceValue;
            }
            else {
                deepReplaceValue(input[key], searchValue, replaceValue);
            }
        }
    }
};
//# sourceMappingURL=materializer-helper.js.map