//scan for multiple in range - https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getKey
import { MSG_TYPES } from "./broadcastChannel.js";
import { Relations } from "./relations.js";
import { abortTx } from "./utils.js";
/**
 * A utility instance that represents a collection in an IndexedDB database and provides methods for interacting with the collection.
 * @template {Collection} T
 */
export class AsyncIDBStore {
    db;
    collection;
    name;
    #isRelaying = false;
    #onBeforeCreate;
    #onBeforeDelete;
    #eventListeners;
    #tx;
    #serialize;
    #deserialize;
    #relations = {};
    constructor(db, collection, name) {
        this.db = db;
        this.collection = collection;
        this.name = name;
        this.#onBeforeDelete = [];
        this.#onBeforeCreate = [];
        this.#eventListeners = {
            write: [],
            delete: [],
            "write|delete": [],
            clear: [],
        };
        const { read, write } = this.collection.serializationConfig;
        this.#serialize = write;
        this.#deserialize = read;
    }
    /**
     * @template {CollectionEvent} Evt
     * @param {Evt} event The event to listen to. Can be `write`, `delete`, or `write|delete`.
     * @param {CollectionEventCallback<T, Evt>} listener The callback function that will be called when the event is triggered.
     */
    addEventListener(event, listener) {
        this.#eventListeners[event].push(listener);
    }
    /**
     * @template {CollectionEvent} Evt
     * @param {Evt} event The event to listen to. Can be `write`, `delete`, or `write|delete`.
     * @param {CollectionEventCallback<T, Evt>} listener The callback function registered with `addEventListener`.
     */
    removeEventListener(event, listener) {
        this.#eventListeners[event] = this.#eventListeners[event].filter((l) => l !== listener);
    }
    /**
     * Wrap a record in an active record, enabling the use of the `save` and `delete` methods
     * @param {CollectionRecord<T>} record
     */
    wrap(record) {
        this.assertNoRelations(record, "wrap");
        return Object.assign(record, {
            save: async () => {
                const res = await this.update(record);
                if (res === null)
                    throw new Error("[async-idb-orm]: record not found");
                return this.wrap(res);
            },
            delete: async () => {
                const key = this.getRecordKey(record);
                await this.delete(key);
            },
        });
    }
    /**
     * Unwrap an active record, removing the `save` and `delete` methods
     * @param {CollectionRecord<T> | ActiveRecord<CollectionRecord<T>>} activeRecord - The record to unwrap
     */
    unwrap(activeRecord) {
        const { save, delete: _del, ...rest } = activeRecord;
        return rest;
    }
    /**
     * Creates a new record in the store
     * @param {CollectionDTO<T>} data - The data to create a new record with. This will be transformed using the `create` transformer if provided.
     */
    create(data) {
        const { create: transformer } = this.collection.transformers;
        data = this.unwrap(data);
        if (transformer)
            data = transformer(data);
        return this.queueTask(async (ctx, resolve, reject) => {
            const serialized = this.#serialize(data);
            if (this.#onBeforeCreate.length) {
                const fkErrs = [];
                await this.getPreCreationForeignKeyErrors(serialized, ctx, fkErrs);
                if (fkErrs.length)
                    return reject(fkErrs);
            }
            const request = ctx.objectStore.add(serialized);
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                if (request.result === undefined)
                    return reject(request.error);
                const res = !this.collection.idMode
                    ? data
                    : { ...data, [this.collection.keyPath]: request.result };
                this.emit("write", res);
                this.emit("write|delete", res);
                resolve(res);
            };
        });
    }
    /**
     * Creates a new record in the store, and upgrades it to an active record
     * @param {CollectionDTO<T>} data The data to create a new record with. This will be transformed using the `create` transformer if provided.
     */
    async createActive(data) {
        const res = await this.create(data);
        return this.wrap(res);
    }
    /**
     * Finds a record based on keyPath or predicate
     * @param {CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean)} predicateOrKey
     * @param {FindOptions<R, string>} [options] - Options for finding with relations
     */
    find(predicateOrKey, options) {
        return new Promise((resolve, reject) => {
            this.db.getInstance((db) => {
                const queryCtx = new RelationalQueryContext(db, this.#tx);
                if (typeof predicateOrKey === "function") {
                    queryCtx
                        .findByPredicate(this, predicateOrKey, options, 1)
                        .then((res) => resolve(res[0] ?? null), reject);
                }
                else {
                    queryCtx
                        .findByKey(this, predicateOrKey, options)
                        .then(resolve, reject);
                }
            });
        });
    }
    /**
     * Finds a record based on keyPath or predicate and upgrades it to an active record.
     */
    async findActive(predicateOrKey // asdasd
    ) {
        const res = await this.find(predicateOrKey);
        if (res === null)
            return null;
        return this.wrap(res);
    }
    /**
     * Finds many records based on keyPath or predicate
     */
    async findMany(predicate, options) {
        const limit = options?.limit || Infinity;
        return new Promise((resolve, reject) => {
            this.db.getInstance((db) => {
                const queryCtx = new RelationalQueryContext(db, this.#tx);
                queryCtx
                    .findByPredicate(this, predicate, options, limit)
                    .then(resolve, reject);
            });
        });
    }
    /**
     * Finds many records based on predicate, upgrading them to active records
     */
    async findManyActive(predicate, options) {
        return (await this.findMany(predicate, options)).map((item) => this.wrap(item));
    }
    /**
     * Gets all records in the store
     */
    all(options) {
        return new Promise((resolve, reject) => {
            this.db.getInstance((db) => {
                new RelationalQueryContext(db, this.#tx)
                    .findAll(this, options)
                    .then(resolve, reject);
            });
        });
    }
    /**
     * Gets all records in the store, upgrading them to active records
     */
    async allActive() {
        return (await this.all()).map((item) => this.wrap(item));
    }
    /**
     * Updates a record
     */
    async update(record) {
        this.assertNoRelations(record, "update");
        record = this.unwrap(record);
        const { create, update } = this.collection.transformers;
        const key = this.getRecordKey(record);
        const existing = await this.read(key);
        let transformer;
        if (existing === null) {
            if (arguments[1] !== true) {
                throw new Error(`[async-idb-orm]: record in collection ${this.name} with key ${this.getRecordKey(record)} not found.`);
            }
            transformer = create;
        }
        else {
            transformer = update;
        }
        transformer && (record = transformer(record));
        const serialized = this.#serialize(record);
        return this.queueTask(async (ctx, resolve, reject) => {
            if (this.#onBeforeCreate.length) {
                const fkErrs = [];
                await this.getPreCreationForeignKeyErrors(serialized, ctx, fkErrs);
                if (fkErrs.length)
                    return reject(fkErrs);
            }
            const request = ctx.objectStore.put(serialized);
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                if (!request.result)
                    return reject(request.error);
                this.emit("write", record);
                this.emit("write|delete", record);
                resolve(record);
            };
        });
    }
    /**
     * Upserts many records in the store
     * @param {CollectionRecord<T>[]} data The records to upsert
     */
    upsert(...data) {
        // @ts-expect-error we're passing an extra argument to `update` for the `upsert` flag
        return Promise.all(data.map((item) => this.update(item, true)));
    }
    /**
     * Deletes a record based on keyPath or predicate function
     * @param {CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean)} predicateOrKey The keyPath or predicate function
     */
    async delete(predicateOrKey) {
        if (typeof predicateOrKey === "function") {
            const [deleted] = await this.deleteMany(predicateOrKey, 1);
            return deleted ?? null;
        }
        const data = await this.read(predicateOrKey);
        if (data === null)
            return null;
        return this.queueTask(async (ctx, resolve, reject) => {
            if (this.#onBeforeDelete.length) {
                const key = this.getRecordKey(data);
                const fkErrs = [];
                await this.getPreDeletionForeignKeyErrors(key, ctx, fkErrs);
                if (fkErrs.length)
                    return reject(fkErrs);
            }
            const request = ctx.objectStore.delete(predicateOrKey);
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                this.emit("delete", data);
                this.emit("write|delete", data);
                resolve(data);
            };
        });
    }
    /**
     * Deletes many records based on predicate function
     * @param {(item: CollectionRecord<T>) => boolean} predicate
     * @param {number} [limit] The maximum number of records to delete (defaults to `Infinity`)
     */
    deleteMany(predicate, limit = Infinity) {
        return this.queueTask((ctx, resolve, reject) => {
            const request = ctx.objectStore.openCursor();
            const results = [];
            request.onerror = (err) => reject(err);
            request.onsuccess = async () => {
                const cursor = request.result;
                if (!cursor)
                    return resolve(results);
                const record = this.#deserialize(cursor.value);
                if (!predicate(record))
                    return cursor.continue();
                if (this.#onBeforeDelete.length) {
                    const fkErrs = [];
                    await this.getPreDeletionForeignKeyErrors(cursor.key, ctx, fkErrs);
                    if (fkErrs.length)
                        return reject(fkErrs);
                }
                cursor.delete();
                this.emit("delete", record);
                this.emit("write|delete", record);
                results.push(record);
                if (--limit) {
                    return cursor.continue();
                }
                return resolve(results);
            };
        });
    }
    /**
     * Deletes all records in the store. Use with caution: **this method is not foreign key aware**
     */
    clear() {
        return this.queueTask((ctx, resolve, reject) => {
            const request = ctx.objectStore.clear();
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                this.emit("clear", null);
                resolve();
            };
        });
    }
    /**
     * Iterates over all records in the store
     */
    async *[Symbol.asyncIterator]() {
        let objectStore;
        if (this.#tx) {
            objectStore = this.#tx.objectStore(this.name);
        }
        else {
            const db = await new Promise((res) => this.db.getInstance(res));
            objectStore = db.transaction(this.name, "readonly").objectStore(this.name);
        }
        const request = objectStore.openCursor();
        const resultQueue = this.createLazyIterator(request);
        for await (const item of resultQueue) {
            if (item === null)
                continue;
            yield this.#deserialize(item);
        }
    }
    /**
     * Counts the number of records in the store
     */
    count() {
        return this.queueTask((ctx, resolve, reject) => {
            const request = ctx.objectStore.count();
            request.onerror = (err) => reject(err);
            request.onsuccess = () => resolve(request.result);
        });
    }
    /**
     * Gets the last record in an index
     * @param {CollectionIndexName<T>} name The name of the index to query the record by
     * @returns {Promise<CollectionRecord<T, U> | null>} The last record in the index, or null if the index is empty
     */
    max(name) {
        return this.firstByKeyDirection(name, "prev");
    }
    /**
     * Gets the first record in an index
     * @param {CollectionIndexName<T>} name The name of the index to query the record by
     * @returns {Promise<CollectionRecord<T> | null>} The first record in the index, or null if the index is empty
     */
    min(name) {
        return this.firstByKeyDirection(name, "next");
    }
    /**
     * Iterates over all records in an index
     * @generator
     */
    async *iterateIndex(name, keyRange) {
        const db = await new Promise((res) => this.db.getInstance(res));
        const objectStore = db.transaction(this.name, "readonly").objectStore(this.name);
        const request = objectStore.index(name).openCursor(keyRange ?? null);
        const resultQueue = this.createLazyIterator(request);
        for await (const item of resultQueue) {
            if (item === null)
                continue;
            yield this.#deserialize(item);
        }
    }
    /**
     * Gets a range of records from an index
     */
    async getIndexRange(name, keyRange) {
        return this.queueTask((ctx, resolve, reject) => {
            const request = ctx.objectStore.index(name).openCursor(keyRange);
            const results = [];
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                const cursor = request.result;
                if (!cursor)
                    return resolve(results);
                const value = this.#deserialize(cursor.value);
                results.push(value);
                cursor.continue();
            };
        });
    }
    static relay(store, evtName, data) {
        store.#isRelaying = true;
        store.emit(evtName, data);
        store.#isRelaying = false;
    }
    static getCollection(store) {
        return store.collection;
    }
    static getRelations(store) {
        return store.#relations;
    }
    static cloneForTransaction(tx, store, eventQueue) {
        const cloned = new AsyncIDBStore(store.db, store.collection, store.name);
        cloned.#tx = tx;
        cloned.#eventListeners = store.#eventListeners;
        cloned.emit = (event, data) => eventQueue.push(() => store.emit(event, data));
        cloned.#onBeforeCreate = store.#onBeforeCreate;
        cloned.#onBeforeDelete = store.#onBeforeDelete;
        cloned.#relations = store.#relations;
        return cloned;
    }
    static init(store) {
        store.initForeignKeys();
        store.cacheRelations();
    }
    cacheRelations() {
        this.#relations = Object.entries(this.db.relations).reduce((acc, [_, rels]) => {
            if (!(rels instanceof Relations))
                return acc;
            if (rels.from !== this.collection)
                return acc;
            for (const relationName in rels.relationsMap) {
                const tgtCollection = rels.to;
                const tgtStore = Object.entries(this.db.stores).find(([_, store]) => store.collection === tgtCollection)?.[1];
                if (!tgtStore)
                    continue;
                acc[relationName] = {
                    other: tgtStore,
                    def: rels.relationsMap[relationName],
                };
            }
            return acc;
        }, {});
    }
    firstByKeyDirection(name, direction) {
        return this.queueTask((ctx, resolve, reject) => {
            const request = ctx.objectStore.index(name).openCursor(null, direction);
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                const cursor = request.result;
                if (!cursor)
                    return resolve(null);
                resolve(this.#deserialize(cursor.value));
            };
        });
    }
    async read(id) {
        return this.queueTask((ctx, resolve, reject) => {
            const request = ctx.objectStore.get(id);
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                if (!request.result)
                    return resolve(null);
                resolve(this.#deserialize(request.result));
            };
        });
    }
    emit(evtName, data) {
        const listeners = this.#eventListeners[evtName] ?? [];
        for (const listener of listeners) {
            listener(data);
        }
        if (!this.#isRelaying && this.db.relayEnabled) {
            this.db.bc.postMessage({
                type: MSG_TYPES.RELAY,
                name: this.name,
                event: evtName,
                data,
            });
        }
    }
    getRecordKey(record) {
        const keyPath = this.collection.keyPath;
        if (Array.isArray(keyPath)) {
            return keyPath.map((key) => record[key]);
        }
        return record[keyPath];
    }
    queueTask(reqHandler) {
        return new Promise((resolve, reject) => {
            const tx = this.#tx;
            if (tx) {
                return reqHandler({ db: tx.db, objectStore: tx.objectStore(this.name), tx }, resolve, reject);
            }
            this.db.getInstance((db) => {
                const tx = db.transaction(this.db.storeNames, "readwrite");
                const objectStore = tx.objectStore(this.name);
                reqHandler({ db, objectStore, tx }, resolve, reject);
            });
        });
    }
    createLazyIterator(request) {
        let resolveQueueBlocker;
        // create an infinite promise that we can resolve on command to yield the next result
        let queueBlocker = new Promise((resolve) => {
            resolveQueueBlocker = resolve;
        });
        const resultQueue = [queueBlocker];
        request.onerror = (e) => {
            resolveQueueBlocker(null);
            throw e;
        };
        request.onsuccess = () => {
            const cursor = request.result;
            if (!cursor)
                return resolveQueueBlocker(null);
            resultQueue.push(cursor.value);
            resolveQueueBlocker(null); // unblock to allow resolving of this record
            // reblock until next record
            queueBlocker = new Promise((resolve) => {
                resolveQueueBlocker = resolve;
            });
            resultQueue.push(queueBlocker);
            cursor.continue();
        };
        return resultQueue;
    }
    async getPreDeletionForeignKeyErrors(key, ctx, errs) {
        await Promise.all(this.#onBeforeDelete.map((cb) => cb(key, ctx, errs)));
    }
    async getPreCreationForeignKeyErrors(record, ctx, errs) {
        await Promise.all(this.#onBeforeCreate.map((cb) => cb(record, ctx, errs)));
    }
    initForeignKeys() {
        if (!this.collection.foreignKeys.length) {
            return;
        }
        this.#onBeforeCreate.push(async (record, { tx }, errs) => {
            // ensure all fkeys point to valid records
            await Promise.all(this.collection.foreignKeys.map(({ ref, collection }) => new Promise((resolve) => {
                const [name] = Object.entries(this.db.stores).find(([, s]) => s.collection === collection);
                const objectStore = tx.objectStore(name);
                const key = record[ref];
                const request = objectStore.get(key);
                request.onerror = (e) => {
                    abortTx(tx);
                    const err = new Error(`[async-idb-orm]: An error occurred while applying FK ${this.name}:${ref} (${key})`);
                    err.cause = e;
                    errs.push(err);
                    resolve();
                };
                request.onsuccess = () => {
                    if (!request.result) {
                        const err = new Error(`[async-idb-orm]: Foreign key invalid: missing FK reference ${this.name}:${ref} (${key})`);
                        errs.push(err);
                    }
                    resolve();
                };
            })));
        });
        for (const { ref: field, collection, onDelete } of this.collection.foreignKeys) {
            const [name, store] = Object.entries(this.db.stores).find(([, s]) => s.collection === collection);
            switch (onDelete) {
                case "cascade":
                    store.#onBeforeDelete.push((key, ctx, errs) => {
                        return new Promise((resolve) => {
                            const tx = ctx.tx;
                            const objectStore = tx.objectStore(this.name);
                            const request = objectStore.openCursor();
                            request.onerror = (err) => {
                                abortTx(tx);
                                const e = new Error("[async-idb-orm]: An error occurred while applying FK -> cascade delete");
                                e.cause = err;
                                errs.push(e);
                                resolve();
                            };
                            const cascadeDelete = async () => {
                                const cursor = request.result;
                                if (!cursor)
                                    return resolve();
                                if (cursor.value[field] === key) {
                                    const dependentErrs = [];
                                    await this.getPreDeletionForeignKeyErrors(this.getRecordKey(cursor.value), ctx, dependentErrs);
                                    if (dependentErrs.length) {
                                        abortTx(tx);
                                        return resolve();
                                    }
                                    cursor.delete();
                                }
                                cursor.continue();
                            };
                            request.onsuccess = cascadeDelete;
                        });
                    });
                    break;
                case "restrict":
                    store.#onBeforeDelete.push((key, ctx, errs) => {
                        return new Promise((resolve) => {
                            const tx = ctx.tx;
                            const objectStore = tx.objectStore(this.name);
                            const request = objectStore.openCursor();
                            request.onerror = (err) => {
                                abortTx(tx);
                                const e = new Error("[async-idb-orm]: An error occurred while enforcing FK -> delete restriction");
                                e.cause = err;
                                errs.push(e);
                                resolve();
                            };
                            const ensureNoReference = async () => {
                                const cursor = request.result;
                                if (!cursor)
                                    return resolve();
                                if (cursor.value[field] === key) {
                                    abortTx(tx);
                                    errs.push(new Error(`[async-idb-orm]: Failed to delete record in collection ${name} because it is referenced by another record in collection ${this.name}`));
                                    return resolve();
                                }
                                const dependentErrs = [];
                                await this.getPreDeletionForeignKeyErrors(this.getRecordKey(cursor.value), ctx, dependentErrs);
                                if (dependentErrs.length) {
                                    abortTx(tx);
                                    return resolve();
                                }
                                cursor.continue();
                            };
                            request.onsuccess = ensureNoReference;
                        });
                    });
                    break;
                case "set null":
                    store.#onBeforeDelete.push((key, ctx, errs) => {
                        return new Promise((resolve) => {
                            const tx = ctx.tx;
                            const objectStore = tx.objectStore(this.name);
                            const request = objectStore.openCursor();
                            request.onerror = (err) => {
                                abortTx(tx);
                                errs.push(new Error(err));
                                resolve();
                            };
                            const setNull = () => {
                                const cursor = request.result;
                                if (!cursor)
                                    return resolve();
                                if (cursor.value[field] !== key)
                                    return cursor.continue();
                                const updateReq = cursor.update(this.#serialize({ ...cursor.value, [field]: null }));
                                updateReq.onerror = (err) => {
                                    abortTx(tx);
                                    errs.push(new Error(err));
                                    resolve();
                                };
                                updateReq.onsuccess = () => cursor.continue();
                            };
                            request.onsuccess = setNull;
                        });
                    });
                    break;
                default:
                    break;
            }
        }
    }
    assertNoRelations(record, action) {
        for (const relationName in this.#relations) {
            if (relationName in record) {
                throw new Error(`[async-idb-orm]: unable to ${action} record with relation ${relationName}`);
            }
        }
    }
}
class RelationalQueryContext {
    db;
    tx;
    constructor(db, tx) {
        this.db = db;
        this.tx = tx ?? this.db.transaction(this.db.objectStoreNames, "readonly");
    }
    async findAll(store, options) {
        const { read: deserialize } = AsyncIDBStore.getCollection(store).serializationConfig;
        return new Promise((resolve, reject) => {
            const objectStore = this.tx.objectStore(store.name);
            const request = objectStore.getAll();
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                const deserialized = request.result.map(deserialize);
                if (options?.with) {
                    return Promise.all(deserialized.map((item) => this.resolveRelations(store, item, options.with))).then(resolve, reject);
                }
                resolve(deserialized);
            };
        });
    }
    async findByKey(store, id, options) {
        return new Promise((resolve, reject) => {
            const objectStore = this.tx.objectStore(store.name);
            const request = objectStore.get(id);
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                if (!request.result) {
                    return resolve(null);
                }
                const record = AsyncIDBStore.getCollection(store).serializationConfig.read(request.result);
                if (options?.with) {
                    return this.resolveRelations(store, record, options.with).then(resolve, reject);
                }
                resolve(record);
            };
        });
    }
    async findByPredicate(store, predicate, options, limit) {
        limit ||= Infinity;
        const { read: deserialize } = AsyncIDBStore.getCollection(store).serializationConfig;
        return new Promise((_resolve, reject) => {
            const objectStore = this.tx.objectStore(store.name);
            const request = objectStore.openCursor();
            const results = [];
            const resolve = () => {
                if (options?.with) {
                    return Promise.all(results.map((record) => this.resolveRelations(store, record, options.with))).then(() => _resolve(results));
                }
                _resolve(results);
            };
            request.onerror = (err) => reject(err);
            request.onsuccess = () => {
                const cursor = request.result;
                if (!cursor)
                    return resolve();
                const value = deserialize(cursor.value);
                if (predicate(value)) {
                    results.push(value);
                    if (results.length >= limit)
                        return resolve();
                }
                cursor.continue();
            };
        });
    }
    async resolveRelations(store, record, withOptions) {
        const relations = AsyncIDBStore.getRelations(store);
        await Promise.all(Object.entries(withOptions).map(([relationName, options]) => this.fetchRelatedRecords(record, relations[relationName], options).then((result) => {
            ;
            record[relationName] = result;
        })));
        return record;
    }
    async fetchRelatedRecords(record, relationDef, options) {
        const { def, other } = relationDef;
        const { type: relationType, from: sourceField, to: targetField } = def;
        const sourceValue = record[sourceField];
        const basePredicate = (item) => item[targetField] === sourceValue;
        const predicate = options?.where
            ? (item) => basePredicate(item) && options.where(item)
            : basePredicate;
        if (relationType === "one-to-one") {
            return (await this.findByPredicate(other, predicate, options, 1))[0] ?? null;
        }
        else if (relationType === "one-to-many") {
            return this.findByPredicate(other, predicate, options, options?.limit);
        }
        return relationType === "one-to-many" ? [] : null;
    }
}
