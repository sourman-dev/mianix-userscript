import type { AsyncIDB } from "./idb";
import { CollectionIDMode, CollectionIndex, SerializationConfig } from "./types";
export declare const $COLLECTION_INTERNAL: unique symbol;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
export type CollectionTransformers<RecordType extends Record<string, any>, DTO extends Record<string, any>, IDMode extends CollectionIDMode, KeyPath extends string> = {
    /**
     * @optional
     * @description Transformer for creating the record
     */
    create?: (data: DTO) => IDMode extends CollectionIDMode.AutoIncrement ? Prettify<Omit<RecordType, KeyPath> & {
        [key in KeyPath]?: number;
    }> : RecordType;
    /**
     * @optional
     * @description Transformer for updating the record
     */
    update?: (data: RecordType) => RecordType;
};
type InvalidRecordKeyError = Error & {
    Brand: "InvalidRecordKeyError";
};
type ForeignKeyOnDelete = "cascade" | "restrict" | "no action" | "set null";
type CollectionForeignKeyConfig<RecordType extends Record<string, any>> = {
    ref: keyof RecordType & string;
    collection: Collection<any, any, any, any, any>;
    onDelete: ForeignKeyOnDelete;
};
type ForeignKeyConfigCallback<RecordType extends Record<string, any>> = (fields: {
    [key in keyof RecordType & string]: key;
}) => CollectionForeignKeyConfig<RecordType>[];
/**
 * @description Collection builder
 * @see {@link Collection.create}
 */
export declare class Collection<RecordType extends Record<string, any>, DTO extends Record<string, any> = RecordType, KeyPath extends keyof RecordType & string = "id" extends keyof RecordType & string ? "id" : never, Indexes extends CollectionIndex<RecordType>[] = never, IDMode extends CollectionIDMode = CollectionIDMode.UserAssigned> {
    [$COLLECTION_INTERNAL]: {
        record: RecordType;
        dto: DTO;
    };
    idMode: IDMode;
    keyPath: KeyPath;
    indexes: Indexes;
    foreignKeys: CollectionForeignKeyConfig<RecordType>[];
    transformers: {
        create?: (data: DTO) => RecordType;
        update?: (data: RecordType) => RecordType;
    };
    serializationConfig: SerializationConfig<RecordType, any>;
    private constructor();
    /**
     * Sets the key for this collection
     */
    withKeyPath<const Key extends keyof RecordType & string, const AutoIncr extends boolean>(keyPath: Key, options?: {
        autoIncrement?: AutoIncr;
    }): AutoIncr extends true ? RecordType[Key] extends number ? Collection<RecordType, DTO, Key, Indexes, CollectionIDMode.AutoIncrement> : InvalidRecordKeyError : Collection<RecordType, DTO, Key, Indexes, CollectionIDMode.UserAssigned>;
    /**
     * Sets the indexes for this collection
     * @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex
     */
    withIndexes<const IdxArray extends CollectionIndex<RecordType>[]>(indexes: IdxArray): Collection<RecordType, DTO, KeyPath, IdxArray, IDMode>;
    /**
     * Sets the foreign keys for this collection
     */
    withForeignKeys(callbackOrKeys: ForeignKeyConfigCallback<RecordType> | CollectionForeignKeyConfig<RecordType>[]): this;
    /**
     * Sets the transformers for this collection
     */
    withTransformers(transformers: CollectionTransformers<RecordType, DTO, IDMode, KeyPath>): this;
    withSerialization<T>(config: SerializationConfig<RecordType, T>): this;
    /**
     * Creates a new collection
     * @example
     * ```ts
     * type Todo = { id: number; text: string; createdAt: number }
     * type TodoDTO = { text: string }
     *
     * const todos = Collection.create<Todo, TodoDTO>()
     *   .withKeyPath("id")
     *   .withIndexes([{ keyPath: "createdAt", name: "idx_createdAt" }])
     *   .withTransformers({
     *      create: ({ text }) => ({
     *        id: crypto.randomUUID(),
     *        text,
     *        createdAt: Date.now()
     *      })
     *   })
     *
     * ```
     */
    static create<RecordType extends Record<string, any>, DTO extends Record<string, any> = any>(): Collection<RecordType, DTO, "id" extends keyof RecordType & string ? "id" : keyof RecordType & string>;
    static validate(db: AsyncIDB<any, any>, collection: Collection<any, any, any, any>, logErr: (err: any) => void): void;
    private static validateKeyPath;
}
export {};
