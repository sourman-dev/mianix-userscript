import { CollectionIDMode, } from "./types";
import { Collection } from "./collection.js";
import { AsyncIDBStore } from "./idbStore.js";
import { MSG_TYPES } from "./broadcastChannel.js";
/**
 * @private
 * Internal usage only. Do not use directly.
 */
export class AsyncIDB {
    name;
    config;
    #db;
    #instanceCallbacks;
    stores;
    storeNames;
    onUpgrade;
    bc;
    relayEnabled;
    version;
    schema;
    relations;
    constructor(name, config) {
        this.name = name;
        this.config = config;
        this.#db = null;
        this.#instanceCallbacks = [];
        this.schema = config.schema;
        this.relations = config.relations ?? {};
        this.version = config.version;
        this.stores = this.createStores();
        this.storeNames = Object.keys(this.schema);
        this.relayEnabled = config.relayEvents !== false;
        let latest = this.version;
        this.bc = new BroadcastChannel(`[async-idb-orm]:${this.name}`);
        this.bc.onmessage = (e) => {
            /**
             * - New tab with new version sends us a "CLOSE_FOR_UPGRADE" message, so we close the db.
             * - Once the other tab initializes it replies with an "REINIT" message.
             */
            switch (e.data.type) {
                case MSG_TYPES.CLOSE_FOR_UPGRADE:
                    if (this.version === e.data.newVersion)
                        return;
                    this.#db?.close();
                    latest = e.data.newVersion;
                    break;
                case MSG_TYPES.REINIT:
                    if (this.version === latest)
                        return;
                    this.config.onBeforeReinit?.(this.version, latest);
                    this.version = latest;
                    this.stores = this.createStores();
                    this.init();
                    break;
                case MSG_TYPES.RELAY:
                    const store = this.stores[e.data.name];
                    if (!store)
                        return;
                    AsyncIDBStore.relay(store, e.data.event, e.data.data);
                    break;
            }
        };
        this.init();
    }
    getInstance(instanceCallback) {
        if (!this.#db) {
            this.#instanceCallbacks.push(instanceCallback);
            return;
        }
        instanceCallback(this.#db);
    }
    async transaction(callback, options) {
        const idbInstance = await new Promise((res) => this.getInstance(res));
        const tx = idbInstance.transaction(this.storeNames, "readwrite", options);
        const eventQueue = [];
        const txCollections = this.cloneStoresForTransaction(tx, eventQueue);
        let aborted = false;
        tx.addEventListener("abort", () => (aborted = true));
        try {
            const res = (await callback(txCollections, tx));
            for (let i = 0; i < eventQueue.length; i++)
                eventQueue[i]();
            return res;
        }
        catch (error) {
            if (!aborted)
                tx.abort();
            throw error;
        }
    }
    init() {
        let schemaValid = true;
        for (const [name, collection] of Object.entries(this.schema)) {
            Collection.validate(this, collection, (err) => ((schemaValid = false),
                (this.config.onError ?? console.error)(`[async-idb-orm]: encountered error with collection "${name}":`, err)));
        }
        if (!schemaValid)
            return;
        for (const store of Object.values(this.stores)) {
            AsyncIDBStore.init(store);
        }
        const request = indexedDB.open(this.name, this.version);
        request.onerror = this.config.onError ?? console.error;
        let wasBlocked = false;
        request.onblocked = () => {
            wasBlocked = true;
            // send a "blocking" message to the other tab, indicating that it should close the connection.
            this.bc.postMessage({ type: MSG_TYPES.CLOSE_FOR_UPGRADE, newVersion: this.version });
        };
        request.onupgradeneeded = async (e) => {
            await this.initializeStores(request, e);
        };
        request.onsuccess = () => {
            this.#db = request.result;
            this.config.onOpen?.(this.#db);
            if (wasBlocked) {
                // if our initialization was blocked, we can now let the other tab know we're ready
                this.bc.postMessage({ type: MSG_TYPES.REINIT });
            }
            while (this.#instanceCallbacks.length) {
                this.#instanceCallbacks.shift()(this.#db);
            }
        };
    }
    createStores() {
        return Object.entries(this.schema).reduce((acc, [name, collection]) => ({
            ...acc,
            [name]: new AsyncIDBStore(this, collection, name),
        }), {});
    }
    cloneStoresForTransaction(tx, eventQueue) {
        return Object.entries(this.stores).reduce((acc, [name, store]) => {
            return {
                ...acc,
                [name]: AsyncIDBStore.cloneForTransaction(tx, store, eventQueue),
            };
        }, {});
    }
    async initializeStores(request, event) {
        const dbInstance = request.result;
        if (this.onUpgrade) {
            const ctx = {
                db: dbInstance,
                collections: this.cloneStoresForTransaction(request.transaction, []),
                deleteStore: (name) => dbInstance.deleteObjectStore(name),
                createStore: (name) => this.createStore(dbInstance, name),
            };
            await this.onUpgrade(ctx, event);
        }
        for (const storeName of Object.keys(this.stores)) {
            if (dbInstance.objectStoreNames.contains(storeName)) {
                continue;
            }
            this.createStore(dbInstance, storeName);
        }
    }
    createStore(db, name) {
        const store = this.stores[name];
        const { keyPath, indexes, idMode } = AsyncIDBStore.getCollection(store);
        const objectStore = db.createObjectStore(store.name, {
            keyPath,
            autoIncrement: idMode === CollectionIDMode.AutoIncrement,
        });
        for (const { name, key, options } of indexes) {
            objectStore.createIndex(name, key, options);
        }
        return objectStore;
    }
}
