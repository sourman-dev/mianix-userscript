import { CollectionIDMode } from "./types";
import { AsyncIDBStore } from "./idbStore.js";
import { keyPassThroughProxy } from "./utils.js";
const CollectionBuilderSentinel = Symbol();
export const $COLLECTION_INTERNAL = Symbol.for("collection.internal");
const ERR_KEYPATH_MISSING = 0;
const ERR_KEYPATH_EMPTY = 1;
const ERR_KEYPATH_DUPLICATE = 2;
/**
 * @description Collection builder
 * @see {@link Collection.create}
 */
export class Collection {
    [$COLLECTION_INTERNAL];
    idMode;
    keyPath;
    indexes;
    foreignKeys;
    transformers = {};
    serializationConfig = {
        write: (data) => data,
        read: (data) => data,
    };
    constructor(key) {
        if (key !== CollectionBuilderSentinel)
            throw new Error("Cannot call CollectionBuilder directly - use Collection.create<T>()");
        this.keyPath = "id";
        this.indexes = [];
        this.foreignKeys = [];
        this[$COLLECTION_INTERNAL] = null;
        this.idMode = "userAssignedId";
    }
    /**
     * Sets the key for this collection
     */
    withKeyPath(keyPath, options) {
        if (options?.autoIncrement) {
            this.idMode = CollectionIDMode.AutoIncrement;
        }
        this.keyPath = keyPath;
        return this;
    }
    /**
     * Sets the indexes for this collection
     * @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex
     */
    withIndexes(indexes) {
        this.indexes = indexes;
        return this;
    }
    /**
     * Sets the foreign keys for this collection
     */
    withForeignKeys(callbackOrKeys) {
        this.foreignKeys = Array.isArray(callbackOrKeys)
            ? callbackOrKeys
            : callbackOrKeys(keyPassThroughProxy);
        return this;
    }
    /**
     * Sets the transformers for this collection
     */
    withTransformers(transformers) {
        this.transformers = transformers;
        return this;
    }
    withSerialization(config) {
        this.serializationConfig = config;
        return this;
    }
    /**
     * Creates a new collection
     * @example
     * ```ts
     * type Todo = { id: number; text: string; createdAt: number }
     * type TodoDTO = { text: string }
     *
     * const todos = Collection.create<Todo, TodoDTO>()
     *   .withKeyPath("id")
     *   .withIndexes([{ keyPath: "createdAt", name: "idx_createdAt" }])
     *   .withTransformers({
     *      create: ({ text }) => ({
     *        id: crypto.randomUUID(),
     *        text,
     *        createdAt: Date.now()
     *      })
     *   })
     *
     * ```
     */
    static create() {
        return new Collection(CollectionBuilderSentinel);
    }
    static validate(db, collection, logErr) {
        this.validateKeyPath(collection.keyPath, (err, data) => err === ERR_KEYPATH_MISSING
            ? logErr(`Missing keyPath`)
            : err === ERR_KEYPATH_EMPTY
                ? logErr(`Invalid - keyPath cannot be empty array`)
                : logErr(`Duplicated keyPath key "${data}"`));
        const seenIndexNames = new Set();
        const dupeIndexNames = new Set();
        for (const index of collection.indexes) {
            this.validateKeyPath(index.key, (err, data) => err === ERR_KEYPATH_MISSING
                ? logErr(`Missing keyPath for index "${index.name}"`)
                : err === ERR_KEYPATH_EMPTY
                    ? logErr(`Invalid keyPath for index "${index.name}"`)
                    : logErr(`Duplicated keyPath key "${data}" for index "${index.name}"`));
            if (seenIndexNames.has(index.name))
                dupeIndexNames.add(index.name);
            seenIndexNames.add(index.name);
        }
        if (dupeIndexNames.size) {
            logErr(`Duplicate index names: ${Array.from(dupeIndexNames).join(", ")}`);
        }
        for (const fkConfig of collection.foreignKeys) {
            const match = Object.entries(db.stores).find(([, s]) => AsyncIDBStore.getCollection(s) === fkConfig.collection);
            if (!match) {
                logErr("Foreign key references a non-existent collection");
            }
        }
    }
    static validateKeyPath(keyPath, handler) {
        if (!keyPath)
            return handler(ERR_KEYPATH_MISSING, null);
        if (typeof keyPath === "string")
            return;
        if (keyPath.length === 0)
            return handler(ERR_KEYPATH_EMPTY, null);
        const seenKeys = new Set();
        for (const key of keyPath) {
            if (seenKeys.has(key))
                handler(ERR_KEYPATH_DUPLICATE, key);
            seenKeys.add(key);
        }
    }
}
