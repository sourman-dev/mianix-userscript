import type { CollectionIndex, CollectionEvent, CollectionRecord, CollectionDTO, CollectionKeyPathType, CollectionIndexName, ActiveRecord, CollectionEventCallback, RelationsSchema, FindOptions, RelationResult, AnyCollection } from "./types";
import type { AsyncIDB } from "./idb";
import { Collection } from "./collection.js";
import { RelationDefinition } from "./relations.js";
type StoreRelation = {
    other: AsyncIDBStore<any, any>;
    def: RelationDefinition<any, any>;
};
/**
 * A utility instance that represents a collection in an IndexedDB database and provides methods for interacting with the collection.
 * @template {Collection} T
 */
export declare class AsyncIDBStore<T extends Collection<Record<string, any>, any, any, CollectionIndex<any>[], any>, R extends RelationsSchema> {
    #private;
    private db;
    private collection;
    name: string;
    constructor(db: AsyncIDB<any, any>, collection: T, name: string);
    /**
     * @template {CollectionEvent} Evt
     * @param {Evt} event The event to listen to. Can be `write`, `delete`, or `write|delete`.
     * @param {CollectionEventCallback<T, Evt>} listener The callback function that will be called when the event is triggered.
     */
    addEventListener<Evt extends CollectionEvent>(event: Evt, listener: CollectionEventCallback<T, Evt>): void;
    /**
     * @template {CollectionEvent} Evt
     * @param {Evt} event The event to listen to. Can be `write`, `delete`, or `write|delete`.
     * @param {CollectionEventCallback<T, Evt>} listener The callback function registered with `addEventListener`.
     */
    removeEventListener<Evt extends CollectionEvent>(event: Evt, listener: CollectionEventCallback<T, Evt>): void;
    /**
     * Wrap a record in an active record, enabling the use of the `save` and `delete` methods
     * @param {CollectionRecord<T>} record
     */
    wrap(record: CollectionRecord<T>): ActiveRecord<CollectionRecord<T>>;
    /**
     * Unwrap an active record, removing the `save` and `delete` methods
     * @param {CollectionRecord<T> | ActiveRecord<CollectionRecord<T>>} activeRecord - The record to unwrap
     */
    unwrap(activeRecord: CollectionRecord<T> | ActiveRecord<CollectionRecord<T>>): CollectionRecord<T>;
    /**
     * Creates a new record in the store
     * @param {CollectionDTO<T>} data - The data to create a new record with. This will be transformed using the `create` transformer if provided.
     */
    create(data: CollectionDTO<T>): Promise<CollectionRecord<T>>;
    /**
     * Creates a new record in the store, and upgrades it to an active record
     * @param {CollectionDTO<T>} data The data to create a new record with. This will be transformed using the `create` transformer if provided.
     */
    createActive(data: CollectionDTO<T>): Promise<ActiveRecord<CollectionRecord<T>>>;
    /**
     * Finds a record based on keyPath or predicate
     * @param {CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean)} predicateOrKey
     * @param {FindOptions<R, string>} [options] - Options for finding with relations
     */
    find<Options extends FindOptions<R, T>>(predicateOrKey: CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean), options?: Options): Promise<RelationResult<T, R, Options> | null>;
    /**
     * Finds a record based on keyPath or predicate and upgrades it to an active record.
     */
    findActive(predicateOrKey: CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean)): Promise<ActiveRecord<CollectionRecord<T>> | null>;
    /**
     * Finds many records based on keyPath or predicate
     */
    findMany<Options extends FindOptions<R, T>>(predicate: (item: CollectionRecord<T>) => boolean, options?: Options & {
        limit?: number;
    }): Promise<RelationResult<T, R, Options>[]>;
    /**
     * Finds many records based on predicate, upgrading them to active records
     */
    findManyActive(predicate: (item: CollectionRecord<T>) => boolean, options?: {
        limit?: number;
    }): Promise<CollectionRecord<T>[]>;
    /**
     * Gets all records in the store
     */
    all<Options extends FindOptions<R, T>>(options?: Options): Promise<RelationResult<T, R, Options>[]>;
    /**
     * Gets all records in the store, upgrading them to active records
     */
    allActive(): Promise<ActiveRecord<CollectionRecord<T>>[]>;
    /**
     * Updates a record
     */
    update(record: CollectionRecord<T>): Promise<CollectionRecord<T>>;
    /**
     * Upserts many records in the store
     * @param {CollectionRecord<T>[]} data The records to upsert
     */
    upsert(...data: CollectionRecord<T>[]): Promise<Awaited<CollectionRecord<T>>[]>;
    /**
     * Deletes a record based on keyPath or predicate function
     * @param {CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean)} predicateOrKey The keyPath or predicate function
     */
    delete(predicateOrKey: CollectionKeyPathType<T> | ((item: CollectionRecord<T>) => boolean)): Promise<CollectionRecord<T> | null>;
    /**
     * Deletes many records based on predicate function
     * @param {(item: CollectionRecord<T>) => boolean} predicate
     * @param {number} [limit] The maximum number of records to delete (defaults to `Infinity`)
     */
    deleteMany(predicate: (item: CollectionRecord<T>) => boolean, limit?: number): Promise<CollectionRecord<T>[]>;
    /**
     * Deletes all records in the store. Use with caution: **this method is not foreign key aware**
     */
    clear(): Promise<void>;
    /**
     * Iterates over all records in the store
     */
    [Symbol.asyncIterator](): AsyncGenerator<CollectionRecord<T>, void, unknown>;
    /**
     * Counts the number of records in the store
     */
    count(): Promise<number>;
    /**
     * Gets the last record in an index
     * @param {CollectionIndexName<T>} name The name of the index to query the record by
     * @returns {Promise<CollectionRecord<T, U> | null>} The last record in the index, or null if the index is empty
     */
    max<U extends CollectionIndexName<T>>(name: U): Promise<CollectionRecord<T> | null>;
    /**
     * Gets the first record in an index
     * @param {CollectionIndexName<T>} name The name of the index to query the record by
     * @returns {Promise<CollectionRecord<T> | null>} The first record in the index, or null if the index is empty
     */
    min<U extends CollectionIndexName<T>>(name: U): Promise<CollectionRecord<T> | null>;
    /**
     * Iterates over all records in an index
     * @generator
     */
    iterateIndex<U extends CollectionIndexName<T>>(name: U, keyRange?: IDBKeyRange): AsyncGenerator<CollectionRecord<T>, void, unknown>;
    /**
     * Gets a range of records from an index
     */
    getIndexRange<U extends CollectionIndexName<T>>(name: U, keyRange: IDBKeyRange): Promise<CollectionRecord<T>[]>;
    static relay<U extends CollectionEvent>(store: AsyncIDBStore<any, any>, evtName: U, data: U extends "clear" ? null : CollectionRecord<any>): void;
    static getCollection(store: AsyncIDBStore<any, any>): AnyCollection;
    static getRelations(store: AsyncIDBStore<any, any>): Record<string, StoreRelation>;
    static cloneForTransaction(tx: IDBTransaction, store: AsyncIDBStore<any, any>, eventQueue: Function[]): AsyncIDBStore<any, RelationsSchema>;
    static init(store: AsyncIDBStore<any, any>): void;
    private cacheRelations;
    private firstByKeyDirection;
    private read;
    private emit;
    private getRecordKey;
    private queueTask;
    private createLazyIterator;
    private getPreDeletionForeignKeyErrors;
    private getPreCreationForeignKeyErrors;
    private initForeignKeys;
    private assertNoRelations;
}
export {};
