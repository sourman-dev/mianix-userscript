import {
  createPersistenceAdapter
} from "./chunk-AIGFJJZW.js";
import "./chunk-ILHRZGIS.js";

// node_modules/.pnpm/@signaldb+indexeddb@1.1.0_@signaldb+core@1.6.0/node_modules/@signaldb/indexeddb/dist/index.mjs
function v(u, m) {
  const { prefix: E = "signaldb-" } = m || {}, l = `${E}${u}`, s = "items";
  function i() {
    return new Promise((o, c) => {
      const e = indexedDB.open(l, 1);
      e.addEventListener("upgradeneeded", () => {
        const r = e.result;
        r.objectStoreNames.contains(s) || r.createObjectStore(s, { keyPath: "id" });
      }), e.addEventListener("success", () => o(e.result)), e.addEventListener("error", () => {
        var r;
        return c(new Error(((r = e.error) == null ? void 0 : r.message) || "Database error"));
      });
    });
  }
  async function b() {
    const o = await i();
    return new Promise((c, e) => {
      const t = o.transaction(s, "readonly").objectStore(s).getAll();
      t.addEventListener("success", () => c(t.result)), t.addEventListener("error", () => {
        var n;
        return e(new Error(((n = t.error) == null ? void 0 : n.message) || "Error fetching items"));
      });
    });
  }
  return createPersistenceAdapter({
    async load() {
      return { items: await b() };
    },
    async save(o, { added: c, modified: e, removed: r }) {
      const t = (await i()).transaction(s, "readwrite"), n = t.objectStore(s);
      return c.forEach((a) => n.add(a)), e.forEach((a) => n.put(a)), r.forEach((a) => n.delete(a.id)), new Promise((a, p) => {
        t.addEventListener("complete", () => a()), t.addEventListener("error", () => {
          var d;
          return p(new Error(((d = t.error) == null ? void 0 : d.message) || "Transaction error"));
        });
      });
    },
    async register() {
    }
  });
}
export {
  v as default
};
//# sourceMappingURL=@signaldb_indexeddb.js.map
