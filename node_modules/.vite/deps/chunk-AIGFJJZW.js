import {
  __export,
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-ILHRZGIS.js";

// node_modules/.pnpm/fast-sort@3.4.1/node_modules/fast-sort/dist/sort.mjs
var castComparer = function(comparer) {
  return function(a, b, order) {
    return comparer(a, b, order) * order;
  };
};
var throwInvalidConfigErrorIfTrue = function(condition, context) {
  if (condition)
    throw Error("Invalid sort config: " + context);
};
var unpackObjectSorter = function(sortByObj) {
  var _a = sortByObj || {}, asc = _a.asc, desc = _a.desc;
  var order = asc ? 1 : -1;
  var sortBy = asc || desc;
  throwInvalidConfigErrorIfTrue(!sortBy, "Expected `asc` or `desc` property");
  throwInvalidConfigErrorIfTrue(asc && desc, "Ambiguous object with `asc` and `desc` config properties");
  var comparer = sortByObj.comparer && castComparer(sortByObj.comparer);
  return { order, sortBy, comparer };
};
var multiPropertySorterProvider = function(defaultComparer2) {
  return function multiPropertySorter(sortBy, sortByArr, depth, order, comparer, a, b) {
    var valA;
    var valB;
    if (typeof sortBy === "string") {
      valA = a[sortBy];
      valB = b[sortBy];
    } else if (typeof sortBy === "function") {
      valA = sortBy(a);
      valB = sortBy(b);
    } else {
      var objectSorterConfig = unpackObjectSorter(sortBy);
      return multiPropertySorter(objectSorterConfig.sortBy, sortByArr, depth, objectSorterConfig.order, objectSorterConfig.comparer || defaultComparer2, a, b);
    }
    var equality = comparer(valA, valB, order);
    if ((equality === 0 || valA == null && valB == null) && sortByArr.length > depth) {
      return multiPropertySorter(sortByArr[depth], sortByArr, depth + 1, order, comparer, a, b);
    }
    return equality;
  };
};
function getSortStrategy(sortBy, comparer, order) {
  if (sortBy === void 0 || sortBy === true) {
    return function(a, b) {
      return comparer(a, b, order);
    };
  }
  if (typeof sortBy === "string") {
    throwInvalidConfigErrorIfTrue(sortBy.includes("."), "String syntax not allowed for nested properties.");
    return function(a, b) {
      return comparer(a[sortBy], b[sortBy], order);
    };
  }
  if (typeof sortBy === "function") {
    return function(a, b) {
      return comparer(sortBy(a), sortBy(b), order);
    };
  }
  if (Array.isArray(sortBy)) {
    var multiPropSorter_1 = multiPropertySorterProvider(comparer);
    return function(a, b) {
      return multiPropSorter_1(sortBy[0], sortBy, 1, order, comparer, a, b);
    };
  }
  var objectSorterConfig = unpackObjectSorter(sortBy);
  return getSortStrategy(objectSorterConfig.sortBy, objectSorterConfig.comparer || comparer, objectSorterConfig.order);
}
var sortArray = function(order, ctx, sortBy, comparer) {
  var _a;
  if (!Array.isArray(ctx)) {
    return ctx;
  }
  if (Array.isArray(sortBy) && sortBy.length < 2) {
    _a = sortBy, sortBy = _a[0];
  }
  return ctx.sort(getSortStrategy(sortBy, comparer, order));
};
function createNewSortInstance(opts) {
  var comparer = castComparer(opts.comparer);
  return function(arrayToSort) {
    var ctx = Array.isArray(arrayToSort) && !opts.inPlaceSorting ? arrayToSort.slice() : arrayToSort;
    return {
      asc: function(sortBy) {
        return sortArray(1, ctx, sortBy, comparer);
      },
      desc: function(sortBy) {
        return sortArray(-1, ctx, sortBy, comparer);
      },
      by: function(sortBy) {
        return sortArray(1, ctx, sortBy, comparer);
      }
    };
  };
}
var defaultComparer = function(a, b, order) {
  if (a == null)
    return order;
  if (b == null)
    return -order;
  if (typeof a !== typeof b) {
    return typeof a < typeof b ? -1 : 1;
  }
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
};
var sort = createNewSortInstance({
  comparer: defaultComparer
});
var inPlaceSort = createNewSortInstance({
  comparer: defaultComparer,
  inPlaceSorting: true
});

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index24.mjs
function get(value, path) {
  const segments = path.split(/[.[\]]/g);
  if (segments[0] === "")
    segments.shift();
  if (segments.at(-1) === "")
    segments.pop();
  let current = value;
  for (const key of segments) {
    if (current == null || key.trim() === "")
      return;
    current = current[key];
  }
  if (current === void 0)
    return;
  return current;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index15.mjs
function sortItems(items, sortFields) {
  return sort(items).by(Object.entries(sortFields).map(([key, value]) => {
    const order = value === 1 ? "asc" : "desc";
    return { [order]: (i) => get(i, key) };
  }));
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index25.mjs
function set(object, path, value, deleteIfUndefined = false) {
  if (object == null)
    return object;
  const segments = path.split(/[.[\]]/g);
  if (segments[0] === "")
    segments.shift();
  if (segments.at(-1) === "")
    segments.pop();
  const apply = (node) => {
    if (segments.length > 1) {
      const key = segments.shift();
      const nextIsNumber = !Number.isNaN(Number.parseInt(segments[0], 10));
      if (node[key] === void 0) {
        node[key] = nextIsNumber ? [] : {};
      }
      apply(node[key]);
    } else {
      if (deleteIfUndefined && value === void 0) {
        delete node[segments[0]];
        return;
      }
      node[segments[0]] = value;
    }
  };
  apply(object);
  return object;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index16.mjs
function project(item, fields) {
  const allFieldsDeactivated = Object.values(fields).every((value) => value === 0);
  if (allFieldsDeactivated) {
    const result2 = { ...item };
    Object.keys(fields).forEach((key) => {
      const fieldValue = get(item, key);
      if (fieldValue === void 0)
        return;
      set(result2, key, void 0, true);
    });
    return result2;
  }
  const result = {};
  Object.entries(fields).forEach(([key, value]) => {
    const fieldValue = get(item, key);
    if (fieldValue === void 0)
      return;
    if (fieldValue == null && value !== 1)
      return;
    set(result, key, value === 1 ? fieldValue : void 0);
  });
  return result;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index10.mjs
function isEqual(a, b) {
  if (Object.is(a, b))
    return true;
  if (a instanceof RegExp && b instanceof RegExp)
    return a.toString() === b.toString();
  if (a instanceof Date && b instanceof Date)
    return a.getTime() === b.getTime();
  if (typeof a !== "object")
    return false;
  if (typeof b !== "object")
    return false;
  if (a === null)
    return false;
  if (b === null)
    return false;
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length)
    return false;
  for (const key of aKeys) {
    if (!bKeys.includes(key))
      return false;
    if (!isEqual(a[key], b[key]))
      return false;
  }
  return true;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index26.mjs
function uniqueBy(array, fn) {
  const set2 = /* @__PURE__ */ new Set();
  return array.filter((element) => {
    const value = typeof fn === "function" ? fn(element) : element[fn];
    return !set2.has(value) && set2.add(value);
  });
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index17.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var Observer = class {
  /**
   * Creates a new instance of the `Observer` class.
   * Sets up event bindings and initializes the callbacks for tracking changes in a collection.
   * @param bindEvents - A function to bind external events to the observer. Must return a cleanup function to unbind those events.
   */
  constructor(bindEvents) {
    __publicField(this, "previousItems", []);
    __publicField(this, "callbacks");
    __publicField(this, "unbindEvents");
    this.callbacks = {
      added: [],
      addedBefore: [],
      changed: [],
      changedField: [],
      movedBefore: [],
      removed: []
    };
    this.unbindEvents = bindEvents();
  }
  call(event, ...args) {
    this.callbacks[event].forEach(({ callback, options }) => {
      if (!options.skipInitial || !options.isInitial) {
        callback(...args);
      }
    });
  }
  hasCallbacks(events) {
    return events.some((event) => this.callbacks[event].length > 0);
  }
  /**
   * Determines if the observer has no active callbacks registered for any events.
   * @returns A boolean indicating whether the observer is empty (i.e., no callbacks are registered).
   */
  isEmpty() {
    return !this.hasCallbacks([
      "added",
      "addedBefore",
      "changed",
      "changedField",
      "movedBefore",
      "removed"
    ]);
  }
  /**
   * Compares the previous state of items with the new state and triggers the appropriate callbacks
   * for events such as added, removed, changed, or moved items.
   * @param newItems - The new list of items to compare against the previous state.
   */
  runChecks(newItems) {
    const oldItemsMap = new Map(this.previousItems.map((item, index) => [
      item.id,
      { item, index, beforeItem: this.previousItems[index + 1] || null }
    ]));
    const newItemsMap = new Map(newItems.map((item, index) => [
      item.id,
      { item, index, beforeItem: newItems[index + 1] || null }
    ]));
    if (this.hasCallbacks(["changed", "changedField", "movedBefore", "removed"])) {
      oldItemsMap.forEach(({ item: oldItem, index, beforeItem: oldBeforeItem }) => {
        var _a;
        const newItem = newItemsMap.get(oldItem.id);
        if (newItem) {
          if (this.hasCallbacks(["changed", "changedField"]) && !isEqual(newItem.item, oldItem)) {
            this.call("changed", newItem.item);
            if (this.hasCallbacks(["changedField"])) {
              const keys = uniqueBy([
                ...Object.keys(newItem.item),
                ...Object.keys(oldItem)
              ], (value) => value);
              keys.forEach((key) => {
                if (isEqual(newItem.item[key], oldItem[key]))
                  return;
                this.call("changedField", newItem.item, key, oldItem[key], newItem.item[key]);
              });
            }
          }
          if (newItem.index !== index && ((_a = newItem.beforeItem) == null ? void 0 : _a.id) !== (oldBeforeItem == null ? void 0 : oldBeforeItem.id)) {
            this.call("movedBefore", newItem.item, newItem.beforeItem);
          }
        } else {
          this.call("removed", oldItem);
        }
      });
    }
    if (this.hasCallbacks(["added", "addedBefore"])) {
      newItems.forEach((newItem, index) => {
        const oldItem = oldItemsMap.get(newItem.id);
        if (oldItem)
          return;
        this.call("added", newItem);
        this.call("addedBefore", newItem, newItems[index + 1] || null);
      });
    }
    this.previousItems = newItems;
    Object.keys(this.callbacks).forEach((key) => {
      const event = key;
      const callbacks = this.callbacks[event];
      this.callbacks[event] = callbacks.map((callback) => ({
        ...callback,
        options: {
          ...callback.options,
          isInitial: false
        }
      }));
    });
  }
  /**
   * Stops the observer by unbinding all events and cleaning up resources.
   */
  stop() {
    this.unbindEvents();
  }
  /**
   * Registers callbacks for specific events to observe changes in the collection.
   * @param callbacks - An object containing the callbacks for various events (e.g., 'added', 'removed').
   * @param skipInitial - A boolean indicating whether to skip invoking the callbacks for the initial state of the collection.
   */
  addCallbacks(callbacks, skipInitial = false) {
    Object.keys(callbacks).forEach((key) => {
      const typedKey = key;
      this.callbacks[typedKey].push({
        callback: callbacks[typedKey],
        options: { skipInitial, isInitial: true }
      });
    });
  }
  /**
   * Removes the specified callbacks for specific events, unregistering them from the observer.
   * @param callbacks - An object containing the callbacks to be removed for various events.
   */
  removeCallbacks(callbacks) {
    Object.keys(callbacks).forEach((key) => {
      const typedKey = key;
      const index = this.callbacks[typedKey].findIndex(({ callback }) => callback === callbacks[typedKey]);
      this.callbacks[typedKey].splice(index, 1);
    });
  }
};

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index2.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function isInReactiveScope(reactivity) {
  if (!reactivity)
    return false;
  if (!reactivity.isInScope)
    return true;
  return reactivity.isInScope();
}
var Cursor = class {
  /**
   * Creates a new instance of the `Cursor` class.
   * Provides utilities for querying, observing, and transforming items from a collection.
   * @template T - The type of the items in the collection.
   * @template U - The transformed item type after applying transformations (default is T).
   * @param getItems - A function that retrieves the filtered list of items.
   * @param options - Optional configuration for the cursor.
   * @param options.transform - A transformation function to apply to each item when retrieving them.
   * @param options.bindEvents - A function to bind reactivity events for the cursor, which should return a cleanup function.
   * @param options.fields - A projection object defining which fields of the item should be included or excluded.
   * @param options.sort - A sort specifier to determine the order of the items.
   * @param options.skip - The number of items to skip from the beginning of the result set.
   * @param options.limit - The maximum number of items to return in the result set.
   * @param options.reactive - A reactivity adapter to enable observing changes in the cursor's result set.
   * @param options.fieldTracking - A boolean to enable fine-grained field tracking for reactivity.
   */
  constructor(getItems, options) {
    __publicField2(this, "observer");
    __publicField2(this, "getFilteredItems");
    __publicField2(this, "options");
    __publicField2(this, "onCleanupCallbacks", []);
    this.getFilteredItems = getItems;
    this.options = options || {};
  }
  addGetters(item) {
    if (!isInReactiveScope(this.options.reactive))
      return item;
    const depend = this.depend.bind(this);
    return Object.entries(item).reduce((memo, [key, value]) => {
      Object.defineProperty(memo, key, {
        get() {
          depend({
            changedField: (notify) => (changedItem, changedFieldName) => {
              if (changedFieldName !== key || changedItem.id !== item.id)
                return;
              notify();
            }
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
      return memo;
    }, {});
  }
  transform(rawItem) {
    const item = this.options.fieldTracking ? this.addGetters(rawItem) : rawItem;
    if (!this.options.transform)
      return item;
    return this.options.transform(item);
  }
  getItems() {
    const items = this.getFilteredItems();
    const { sort: sort2, skip, limit } = this.options;
    const sorted = sort2 ? sortItems(items, sort2) : items;
    const skipped = skip ? sorted.slice(skip) : sorted;
    const limited = limit ? skipped.slice(0, limit) : skipped;
    const idExcluded = this.options.fields && this.options.fields.id === 0;
    return limited.map((item) => {
      if (!this.options.fields)
        return item;
      return {
        ...idExcluded ? {} : { id: item.id },
        ...project(item, this.options.fields)
      };
    });
  }
  depend(changeEvents) {
    if (!this.options.reactive)
      return;
    if (!isInReactiveScope(this.options.reactive))
      return;
    const signal = this.options.reactive.create();
    signal.depend();
    const notify = () => signal.notify();
    function buildNotifier(event) {
      const eventHandler = changeEvents[event];
      return (...args) => {
        if (eventHandler === true) {
          notify();
          return;
        }
        if (typeof eventHandler !== "function")
          return;
        eventHandler(notify)(...args);
      };
    }
    const stop = this.observeRawChanges({
      added: buildNotifier("added"),
      addedBefore: buildNotifier("addedBefore"),
      changed: buildNotifier("changed"),
      changedField: buildNotifier("changedField"),
      movedBefore: buildNotifier("movedBefore"),
      removed: buildNotifier("removed")
    }, true);
    if (this.options.reactive.onDispose) {
      this.options.reactive.onDispose(() => stop(), signal);
    }
    this.onCleanup(stop);
  }
  ensureObserver() {
    if (!this.observer) {
      const observer = new Observer(() => {
        const requery = () => {
          observer.runChecks(this.getItems());
        };
        const cleanup = this.options.bindEvents && this.options.bindEvents(requery);
        return () => {
          if (cleanup)
            cleanup();
        };
      });
      this.onCleanup(() => observer.stop());
      this.observer = observer;
    }
    return this.observer;
  }
  observeRawChanges(callbacks, skipInitial = false) {
    const observer = this.ensureObserver();
    observer.addCallbacks(callbacks, skipInitial);
    observer.runChecks(this.getItems());
    return () => {
      observer.removeCallbacks(callbacks);
      if (!observer.isEmpty())
        return;
      observer.stop();
      this.observer = void 0;
    };
  }
  /**
   * Cleans up all resources associated with the cursor, such as reactive bindings
   * and event listeners. This method should be called when the cursor is no longer needed
   * to prevent memory leaks.
   */
  cleanup() {
    this.onCleanupCallbacks.forEach((callback) => {
      callback();
    });
    this.onCleanupCallbacks = [];
  }
  /**
   * Registers a cleanup callback to be executed when the `cleanup` method is called.
   * Useful for managing resources and ensuring proper cleanup of bindings or listeners.
   * @param callback - A function to be executed during cleanup.
   */
  onCleanup(callback) {
    this.onCleanupCallbacks.push(callback);
  }
  /**
   * Iterates over each item in the cursor's result set, applying the provided callback
   * function to each transformed item.
   * ⚡️ this function is reactive!
   * @param callback - A function to execute for each item in the result set.
   * @param callback.item - The transformed item.
   */
  forEach(callback) {
    const items = this.getItems();
    this.depend({
      addedBefore: true,
      removed: true,
      movedBefore: true,
      ...this.options.fieldTracking ? {} : { changed: true }
    });
    items.forEach((item) => {
      callback(this.transform(item));
    });
  }
  /**
   * Creates a new array populated with the results of applying the provided callback
   * function to each transformed item in the cursor's result set.
   * ⚡️ this function is reactive!
   * @template V - The type of the items in the resulting array.
   * @param callback - A function to execute for each item in the result set.
   * @param callback.item - The transformed item.
   * @returns An array of results after applying the callback to each item.
   */
  map(callback) {
    const results = [];
    this.forEach((item) => {
      results.push(callback(item));
    });
    return results;
  }
  /**
   * Fetches all transformed items from the cursor's result set as an array.
   * Automatically applies filtering, sorting, and limiting as per the cursor's options.
   * ⚡️ this function is reactive!
   * @returns An array of transformed items in the result set.
   */
  fetch() {
    return this.map((item) => item);
  }
  /**
   * Counts the total number of items in the cursor's result set after applying
   * filtering and other criteria.
   * ⚡️ this function is reactive!
   * @returns The total number of items in the result set.
   */
  count() {
    const items = this.getItems();
    this.depend({
      added: true,
      removed: true
    });
    return items.length;
  }
  /**
   * Observes changes to the cursor's result set and triggers the specified callbacks
   * when items are added, removed, or updated. Supports reactivity and transformation.
   * @param callbacks - An object containing the callback functions to handle different change events.
   * @param callbacks.added - Triggered when an item is added to the result set.
   * @param callbacks.removed - Triggered when an item is removed from the result set.
   * @param callbacks.changed - Triggered when an item in the result set is modified.
   * @param callbacks.addedBefore - Triggered when an item is added before another item in the result set.
   * @param callbacks.movedBefore - Triggered when an item is moved before another item in the result set.
   * @param callbacks.changedField - Triggered when a specific field of an item changes.
   * @param skipInitial - A boolean indicating whether to skip the initial notification of the current result set.
   * @returns A function to stop observing changes.
   */
  observeChanges(callbacks, skipInitial = false) {
    return this.observeRawChanges(Object.entries(callbacks).reduce((memo, [callbackName, callback]) => {
      if (!callback)
        return memo;
      return {
        ...memo,
        [callbackName]: (item, before) => {
          const transformedValue = this.transform(item);
          const hasBeforeParameter = before !== void 0;
          const transformedBeforeValue = hasBeforeParameter && before ? this.transform(before) : null;
          return callback(transformedValue, ...hasBeforeParameter ? [transformedBeforeValue] : []);
        }
      };
    }, {}), skipInitial);
  }
  /**
   * Forces the cursor to re-evaluate its result set by re-fetching items
   * from the collection. This is useful when the underlying data or query
   * criteria have changed, and you want to ensure the cursor reflects the latest state.
   */
  requery() {
    if (!this.observer)
      return;
    this.observer.runChecks(this.getItems());
  }
};

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index13.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var EventEmitter = class {
  constructor() {
    __publicField3(this, "_maxListeners", 100);
    __publicField3(this, "_listenerStore", /* @__PURE__ */ new Map());
  }
  setMaxListeners(max) {
    this._maxListeners = max;
    return this;
  }
  /**
   * Subscribe to an event with a listener function.
   * @param eventName The event name (key of E).
   * @param listener  A function that receives the emitted arguments.
   * @returns         The emitter instance (for chaining).
   */
  on(eventName, listener) {
    let listenersSet = this._listenerStore.get(eventName);
    if (!listenersSet) {
      listenersSet = /* @__PURE__ */ new Set();
      this._listenerStore.set(eventName, listenersSet);
    }
    listenersSet.add(listener);
    if (listenersSet.size > this._maxListeners) {
      console.warn(`Possible EventEmitter memory leak detected. ${listenersSet.size} ${String(eventName)} listeners added. Use emitter.setMaxListeners() to increase limit.`);
    }
    return this;
  }
  /**
   * Subscribe to an event with a listener function.
   * @param eventName The event name (key of E).
   * @param listener  A function that receives the emitted arguments.
   * @returns         The emitter instance (for chaining).
   */
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  /**
   * Subscribe to an event, handling it only once. Automatically removes
   * the listener after it fires the first time.
   * @param eventName The event name (key of E).
   * @param listener  A function that receives the emitted arguments.
   * @returns         The emitter instance (for chaining).
   */
  once(eventName, listener) {
    const onceWrapper = (...args) => {
      listener(...args);
      this.off(eventName, onceWrapper);
    };
    return this.on(eventName, onceWrapper);
  }
  /**
   * Unsubscribe a previously subscribed listener.
   * @param eventName The event name (key of E).
   * @param listener  The original function passed to `on` or `once`.
   * @returns         The emitter instance (for chaining).
   */
  off(eventName, listener) {
    const listenersSet = this._listenerStore.get(eventName);
    if (!listenersSet)
      return this;
    listenersSet.delete(listener);
    if (listenersSet.size === 0) {
      this._listenerStore.delete(eventName);
    }
    return this;
  }
  /**
   * Unsubscribe a previously subscribed listener.
   * @param eventName The event name (key of E).
   * @param listener  The original function passed to `on` or `once`.
   * @returns         The emitter instance (for chaining).
   */
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  /**
   * Emit (dispatch) an event with a variable number of arguments.
   * @param eventName The event name (key of E).
   * @param args      The arguments to pass to subscribed listeners.
   */
  emit(eventName, ...args) {
    this.listeners(eventName).forEach((listener) => {
      listener(...args);
    });
  }
  /**
   * Returns the array of listener functions currently registered for a given event.
   * @param eventName The event name (key of E).
   * @returns         An array of listener functions.
   */
  listeners(eventName) {
    const listenersSet = this._listenerStore.get(eventName);
    if (!listenersSet)
      return [];
    return [...listenersSet.values()];
  }
  /**
   * Returns the number of listeners for a given event.
   * @param eventName The event name (key of E).
   * @returns         The number of listeners.
   */
  listenerCount(eventName) {
    const listenersSet = this._listenerStore.get(eventName);
    return listenersSet ? listenersSet.size : 0;
  }
  /**
   * Removes all listeners for a given event, or all events if none is specified.
   * @param eventName Optional. If omitted, clears all events’ listeners.
   * @returns         The emitter instance (for chaining).
   */
  removeAllListeners(eventName) {
    if (eventName === void 0) {
      for (const [eventName_, listenersSet] of this._listenerStore.entries()) {
        for (const listener of listenersSet.values()) {
          this.off(eventName_, listener);
        }
      }
      this._listenerStore.clear();
    } else {
      const listenersSet = this._listenerStore.get(eventName);
      if (listenersSet) {
        for (const listener of listenersSet.values()) {
          this.off(eventName, listener);
        }
        this._listenerStore.delete(eventName);
      }
    }
    return this;
  }
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/util.js
var MingoError = class extends Error {
};
var MISSING = Symbol("missing");
var ERR_CYCLE_FOUND = "mingo: cycle detected while processing object/array";
var DEFAULT_HASH_FUNCTION = (value) => {
  const s = stringify(value);
  let hash = 0;
  let i = s.length;
  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);
  return hash >>> 0;
};
var isPrimitive = (v) => typeof v !== "object" && typeof v !== "function" || v === null;
var isScalar = (v) => isPrimitive(v) || isDate(v) || isRegExp(v);
var SORT_ORDER = {
  undefined: 1,
  null: 2,
  number: 3,
  string: 4,
  symbol: 5,
  object: 6,
  array: 7,
  arraybuffer: 8,
  boolean: 9,
  date: 10,
  regexp: 11,
  function: 12
};
function compare(a, b) {
  if (a === MISSING) a = void 0;
  if (b === MISSING) b = void 0;
  const customOrder = 100;
  const [u, v] = [a, b].map(
    (n) => SORT_ORDER[isTypedArray(n) ? "arraybuffer" : typeOf(n)] ?? customOrder
    /*custom objects have highest sort order*/
  );
  if (u !== v) return u - v;
  if (u === customOrder) {
    a = stringify(a);
    b = stringify(b);
  }
  return isEqual2(a, b) ? 0 : a < b ? -1 : 1;
}
var _hashFn, _keyMap, _unpack;
var _ValueMap = class _ValueMap extends Map {
  constructor() {
    super();
    // The hash function
    __privateAdd(this, _hashFn, DEFAULT_HASH_FUNCTION);
    // maps the hashcode to key set
    __privateAdd(this, _keyMap, /* @__PURE__ */ new Map());
    // returns a tuple of [<masterKey>, <hash>]. Expects an object key.
    __privateAdd(this, _unpack, (key) => {
      const hash = __privateGet(this, _hashFn).call(this, key);
      return [(__privateGet(this, _keyMap).get(hash) || []).find((k) => isEqual2(k, key)), hash];
    });
  }
  /**
   * Returns a new {@link ValueMap} object.
   * @param fn An optional custom hash function
   */
  static init(fn) {
    const m = new _ValueMap();
    if (fn) __privateSet(m, _hashFn, fn);
    return m;
  }
  clear() {
    super.clear();
    __privateGet(this, _keyMap).clear();
  }
  /**
   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    if (isPrimitive(key)) return super.delete(key);
    const [masterKey, hash] = __privateGet(this, _unpack).call(this, key);
    if (!super.delete(masterKey)) return false;
    __privateGet(this, _keyMap).set(
      hash,
      __privateGet(this, _keyMap).get(hash).filter((k) => !isEqual2(k, masterKey))
    );
    return true;
  }
  /**
   * Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.
   * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned.
   */
  get(key) {
    if (isPrimitive(key)) return super.get(key);
    const [masterKey, _] = __privateGet(this, _unpack).call(this, key);
    return super.get(masterKey);
  }
  /**
   * @returns boolean indicating whether an element with the specified key exists or not.
   */
  has(key) {
    if (isPrimitive(key)) return super.has(key);
    const [masterKey, _] = __privateGet(this, _unpack).call(this, key);
    return super.has(masterKey);
  }
  /**
   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
   */
  set(key, value) {
    if (isPrimitive(key)) return super.set(key, value);
    const [masterKey, hash] = __privateGet(this, _unpack).call(this, key);
    if (super.has(masterKey)) {
      super.set(masterKey, value);
    } else {
      super.set(key, value);
      const keys = __privateGet(this, _keyMap).get(hash) || [];
      keys.push(key);
      __privateGet(this, _keyMap).set(hash, keys);
    }
    return this;
  }
  /**
   * @returns the number of elements in the Map.
   */
  get size() {
    return super.size;
  }
};
_hashFn = new WeakMap();
_keyMap = new WeakMap();
_unpack = new WeakMap();
var ValueMap = _ValueMap;
function assert(condition, message) {
  if (!condition) throw new MingoError(message);
}
function typeOf(v) {
  var _a, _b;
  if (v === null) return "null";
  const t = typeof v;
  if (t !== "object" && t in SORT_ORDER) return t;
  if (isArray(v)) return "array";
  if (isDate(v)) return "date";
  if (isRegExp(v)) return "regexp";
  const s = Object.prototype.toString.call(v);
  return s === "[object Object]" ? ((_b = (_a = v == null ? void 0 : v.constructor) == null ? void 0 : _a.name) == null ? void 0 : _b.toLowerCase()) || "object" : s.substring(8, s.length - 1).toLowerCase();
}
var isBoolean = (v) => typeof v === "boolean";
var isString = (v) => typeof v === "string";
var isSymbol = (v) => typeof v === "symbol";
var isNumber = (v) => !isNaN(v) && typeof v === "number";
var isArray = Array.isArray;
var isObject = (v) => typeOf(v) === "object";
var isObjectLike = (v) => !isPrimitive(v);
var isDate = (v) => v instanceof Date;
var isRegExp = (v) => v instanceof RegExp;
var isFunction = (v) => typeof v === "function";
var isNil = (v) => v === null || v === void 0;
var truthy = (arg, strict = true) => !!arg || strict && arg === "";
var isEmpty = (x) => isNil(x) || isString(x) && !x || isArray(x) && x.length === 0 || isObject(x) && Object.keys(x).length === 0;
var ensureArray = (x) => isArray(x) ? x : [x];
var has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);
var isTypedArray = (v) => typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(v);
var cloneDeep = (v, refs) => {
  if (isNil(v) || isBoolean(v) || isNumber(v) || isString(v)) return v;
  if (isDate(v)) return new Date(v);
  if (isRegExp(v)) return new RegExp(v);
  if (isTypedArray(v)) {
    const ctor = v.constructor;
    return new ctor(v);
  }
  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();
  if (refs.has(v)) throw new Error(ERR_CYCLE_FOUND);
  refs.add(v);
  try {
    if (isArray(v)) {
      const arr = new Array(v.length);
      for (let i = 0; i < v.length; i++) arr[i] = cloneDeep(v[i], refs);
      return arr;
    }
    if (isObject(v)) {
      const obj = {};
      for (const k of Object.keys(v)) obj[k] = cloneDeep(v[k], refs);
      return obj;
    }
  } finally {
    refs.delete(v);
  }
  return v;
};
var isMissing = (v) => v === MISSING;
function merge(target, input) {
  if (isMissing(target) || isNil(target)) return input;
  if (isMissing(input) || isNil(input)) return target;
  if (isPrimitive(target) || isPrimitive(input)) return input;
  if (isArray(target) && isArray(input)) {
    assert(
      target.length === input.length,
      "arrays must be of equal length to merge."
    );
  }
  for (const k of Object.keys(input)) {
    target[k] = merge(target[k], input[k]);
  }
  return target;
}
function intersection(input, hashFunc = DEFAULT_HASH_FUNCTION) {
  const vmaps = [ValueMap.init(hashFunc), ValueMap.init(hashFunc)];
  if (input.length === 0) return [];
  if (input.some((arr) => arr.length === 0)) return [];
  if (input.length === 1) return [...input];
  input[input.length - 1].forEach((v) => vmaps[0].set(v, true));
  for (let i = input.length - 2; i > -1; i--) {
    input[i].forEach((v) => {
      if (vmaps[0].has(v)) vmaps[1].set(v, true);
    });
    if (vmaps[1].size === 0) return [];
    vmaps.reverse();
    vmaps[1].clear();
  }
  return Array.from(vmaps[0].keys());
}
function flatten(xs, depth = 1) {
  const arr = new Array();
  function flatten2(ys, n) {
    for (let i = 0, len = ys.length; i < len; i++) {
      if (isArray(ys[i]) && (n > 0 || n < 0)) {
        flatten2(ys[i], Math.max(-1, n - 1));
      } else {
        arr.push(ys[i]);
      }
    }
  }
  flatten2(xs, depth);
  return arr;
}
function getMembersOf(o) {
  const props = {};
  while (o) {
    for (const k of Object.getOwnPropertyNames(o))
      if (!(k in props)) props[k] = o[k];
    o = Object.getPrototypeOf(o);
  }
  return props;
}
var hasCustomString = (o) => o !== null && o !== void 0 && o["toString"] !== Object.prototype.toString;
function isEqual2(a, b) {
  if (a === b || Object.is(a, b)) return true;
  if (a === null || b === null) return false;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object") return false;
  if (isDate(a)) return isDate(b) && +a === +b;
  if (isRegExp(a)) return isRegExp(b) && a.toString() === b.toString();
  const t = typeOf(a);
  if (t !== typeOf(b)) return false;
  switch (t) {
    case "array":
      if (a.length !== b.length) return false;
      for (let i = 0, size = a.length; i < size; i++) {
        if (!isEqual2(a[i], b[i])) return false;
      }
      return true;
    case "object": {
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      if (ka.length !== kb.length) return false;
      for (const k of ka) {
        if (!(k in b && isEqual2(a[k], b[k]))) return false;
      }
      return true;
    }
    default:
      return hasCustomString(a) && a.toString() === b.toString();
  }
}
function unique(input, hashFunc = DEFAULT_HASH_FUNCTION) {
  const m = ValueMap.init(hashFunc);
  input.forEach((v) => m.set(v, true));
  return Array.from(m.keys());
}
function stringify(v, refs) {
  if (v === null) return "null";
  if (v === void 0) return "undefined";
  if (isString(v) || isNumber(v) || isBoolean(v)) return JSON.stringify(v);
  if (isDate(v)) return v.toISOString();
  if (isRegExp(v) || isSymbol(v) || isFunction(v))
    return v.toString();
  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();
  if (refs.has(v)) throw new Error(ERR_CYCLE_FOUND);
  try {
    refs.add(v);
    if (isArray(v)) return "[" + v.map((s2) => stringify(s2, refs)).join(",") + "]";
    if (isObject(v)) {
      const keys = Object.keys(v).sort();
      return "{" + keys.map((k) => `${k}:${stringify(v[k], refs)}`).join() + "}";
    }
    const s = hasCustomString(v) ? v.toString() : stringify(getMembersOf(v), refs);
    return typeOf(v) + "(" + s + ")";
  } finally {
    refs.delete(v);
  }
}
function groupBy(collection, keyFunc, hashFunc = DEFAULT_HASH_FUNCTION) {
  if (collection.length < 1) return /* @__PURE__ */ new Map();
  const result = ValueMap.init(hashFunc);
  for (let i = 0; i < collection.length; i++) {
    const obj = collection[i];
    const key = keyFunc(obj, i) ?? null;
    let a = result.get(key);
    if (!a) {
      a = [obj];
      result.set(key, a);
    } else {
      a.push(obj);
    }
  }
  return result;
}
function getValue(obj, key) {
  return isObjectLike(obj) ? obj[key] : void 0;
}
function unwrap(arr, depth) {
  if (depth < 1) return arr;
  while (depth-- && arr.length === 1) arr = arr[0];
  return arr;
}
function resolve(obj, selector, options) {
  let depth = 0;
  function resolve2(o, path) {
    let value = o;
    for (let i = 0; i < path.length; i++) {
      const field = path[i];
      const isText = /^\d+$/.exec(field) === null;
      if (isText && isArray(value)) {
        if (i === 0 && depth > 0) break;
        depth += 1;
        const subpath = path.slice(i);
        value = value.reduce((acc, item) => {
          const v = resolve2(item, subpath);
          if (v !== void 0) acc.push(v);
          return acc;
        }, []);
        break;
      } else {
        value = getValue(value, field);
      }
      if (value === void 0) break;
    }
    return value;
  }
  const res = isScalar(obj) ? obj : resolve2(obj, selector.split("."));
  return isArray(res) && (options == null ? void 0 : options.unwrapArray) ? unwrap(res, depth) : res;
}
function resolveGraph(obj, selector, options) {
  const sep = selector.indexOf(".");
  const key = sep == -1 ? selector : selector.substring(0, sep);
  const next = selector.substring(sep + 1);
  const hasNext = sep != -1;
  if (isArray(obj)) {
    const isIndex = /^\d+$/.test(key);
    const arr = isIndex && (options == null ? void 0 : options.preserveIndex) ? [...obj] : [];
    if (isIndex) {
      const index = parseInt(key);
      let value2 = getValue(obj, index);
      if (hasNext) {
        value2 = resolveGraph(value2, next, options);
      }
      if (options == null ? void 0 : options.preserveIndex) {
        arr[index] = value2;
      } else {
        arr.push(value2);
      }
    } else {
      for (const item of obj) {
        const value2 = resolveGraph(item, selector, options);
        if (options == null ? void 0 : options.preserveMissing) {
          arr.push(value2 == void 0 ? MISSING : value2);
        } else if (value2 != void 0 || (options == null ? void 0 : options.preserveIndex)) {
          arr.push(value2);
        }
      }
    }
    return arr;
  }
  const res = (options == null ? void 0 : options.preserveKeys) ? { ...obj } : {};
  let value = getValue(obj, key);
  if (hasNext) {
    value = resolveGraph(value, next, options);
  }
  if (value === void 0) return void 0;
  res[key] = value;
  return res;
}
function filterMissing(obj) {
  if (isArray(obj)) {
    for (let i = obj.length - 1; i >= 0; i--) {
      if (obj[i] === MISSING) {
        obj.splice(i, 1);
      } else {
        filterMissing(obj[i]);
      }
    }
  } else if (isObject(obj)) {
    for (const k in obj) {
      if (has(obj, k)) {
        filterMissing(obj[k]);
      }
    }
  }
}
var NUMBER_RE = /^\d+$/;
function walk(obj, selector, fn, options) {
  const names = selector.split(".");
  const key = names[0];
  const next = names.slice(1).join(".");
  if (names.length === 1) {
    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {
      fn(obj, key);
    }
  } else {
    if ((options == null ? void 0 : options.buildGraph) && isNil(obj[key])) {
      obj[key] = {};
    }
    const item = obj[key];
    if (!item) return;
    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
    if (isArray(item) && (options == null ? void 0 : options.descendArray) && !isNextArrayIndex) {
      item.forEach((e) => walk(e, next, fn, options));
    } else {
      walk(item, next, fn, options);
    }
  }
}
function setValue(obj, selector, value) {
  walk(
    obj,
    selector,
    (item, key) => {
      item[key] = isFunction(value) ? value(item[key]) : value;
    },
    { buildGraph: true }
  );
}
function removeValue(obj, selector, options) {
  walk(
    obj,
    selector,
    (item, key) => {
      if (isArray(item)) {
        item.splice(parseInt(key), 1);
      } else if (isObject(item)) {
        delete item[key];
      }
    },
    options
  );
}
var OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
function isOperator(name) {
  return OPERATOR_NAME_PATTERN.test(name);
}
function normalize(expr) {
  if (isScalar(expr)) {
    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };
  }
  if (isObjectLike(expr)) {
    if (!Object.keys(expr).some(isOperator)) return { $eq: expr };
    if (has(expr, "$regex")) {
      const newExpr = { ...expr };
      newExpr["$regex"] = new RegExp(
        expr["$regex"],
        expr["$options"]
      );
      delete newExpr["$options"];
      return newExpr;
    }
  }
  return expr;
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/core.js
var ProcessingMode = ((ProcessingMode2) => {
  ProcessingMode2[ProcessingMode2["CLONE_OFF"] = 0] = "CLONE_OFF";
  ProcessingMode2[ProcessingMode2["CLONE_INPUT"] = 1] = "CLONE_INPUT";
  ProcessingMode2[ProcessingMode2["CLONE_OUTPUT"] = 2] = "CLONE_OUTPUT";
  ProcessingMode2[ProcessingMode2["CLONE_ALL"] = 3] = "CLONE_ALL";
  return ProcessingMode2;
})(ProcessingMode || {});
var _options, _root, _local;
var _ComputeOptions = class _ComputeOptions {
  constructor(options, root, local) {
    __privateAdd(this, _options);
    /** Reference to the root object when processing subgraphs of the object. */
    __privateAdd(this, _root);
    __privateAdd(this, _local);
    __privateSet(this, _options, options);
    this.update(root, local);
  }
  /**
   * Initialize new ComputeOptions.
   * @returns {ComputeOptions}
   */
  static init(options, root, local) {
    var _a;
    return !(options instanceof _ComputeOptions) ? new _ComputeOptions(options, root, local) : new _ComputeOptions(__privateGet(options, _options), options.root ?? root, {
      ...__privateGet(options, _local),
      ...local,
      variables: Object.assign(
        {},
        (_a = __privateGet(options, _local)) == null ? void 0 : _a.variables,
        local == null ? void 0 : local.variables
      )
    });
  }
  /**
   * Updates the internal state.
   *
   * @param root The new root context for this object.
   * @param local The new local state to merge into current if it exists.
   * @returns
   */
  update(root, local) {
    var _a;
    __privateSet(this, _root, root);
    const variables = Object.assign(
      {},
      (_a = __privateGet(this, _local)) == null ? void 0 : _a.variables,
      local == null ? void 0 : local.variables
    );
    if (Object.keys(variables).length) {
      __privateSet(this, _local, { ...local, variables });
    } else {
      __privateSet(this, _local, local ?? {});
    }
    return this;
  }
  getOptions() {
    return Object.freeze({
      ...__privateGet(this, _options),
      context: Context.from(__privateGet(this, _options).context)
    });
  }
  get root() {
    return __privateGet(this, _root);
  }
  get local() {
    return __privateGet(this, _local);
  }
  get idKey() {
    return __privateGet(this, _options).idKey;
  }
  get collation() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.collation;
  }
  get processingMode() {
    var _a;
    return ((_a = __privateGet(this, _options)) == null ? void 0 : _a.processingMode) || 0;
  }
  get useStrictMode() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.useStrictMode;
  }
  get scriptEnabled() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.scriptEnabled;
  }
  get useGlobalContext() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.useGlobalContext;
  }
  get hashFunction() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.hashFunction;
  }
  get collectionResolver() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.collectionResolver;
  }
  get jsonSchemaValidator() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.jsonSchemaValidator;
  }
  get variables() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.variables;
  }
  get context() {
    var _a;
    return (_a = __privateGet(this, _options)) == null ? void 0 : _a.context;
  }
};
_options = new WeakMap();
_root = new WeakMap();
_local = new WeakMap();
var ComputeOptions = _ComputeOptions;
function initOptions(options) {
  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({
    idKey: "_id",
    scriptEnabled: true,
    useStrictMode: true,
    useGlobalContext: true,
    processingMode: 0,
    ...options,
    context: (options == null ? void 0 : options.context) ? Context.from(options == null ? void 0 : options.context) : Context.init()
  });
}
var OpType = ((OpType2) => {
  OpType2["ACCUMULATOR"] = "accumulator";
  OpType2["EXPRESSION"] = "expression";
  OpType2["PIPELINE"] = "pipeline";
  OpType2["PROJECTION"] = "projection";
  OpType2["QUERY"] = "query";
  OpType2["WINDOW"] = "window";
  return OpType2;
})(OpType || {});
var _operators;
var _Context = class _Context {
  constructor() {
    __privateAdd(this, _operators, /* @__PURE__ */ new Map());
  }
  static init() {
    return new _Context();
  }
  static from(ctx) {
    const instance = _Context.init();
    if (isNil(ctx)) return instance;
    __privateGet(ctx, _operators).forEach((v, k) => instance.addOperators(k, v));
    return instance;
  }
  addOperators(type, operators) {
    if (!__privateGet(this, _operators).has(type)) __privateGet(this, _operators).set(type, {});
    for (const [name, fn] of Object.entries(operators)) {
      if (!this.getOperator(type, name)) {
        __privateGet(this, _operators).get(type)[name] = fn;
      }
    }
    return this;
  }
  getOperator(type, name) {
    const ops = __privateGet(this, _operators).get(type) ?? {};
    return ops[name] ?? null;
  }
  addAccumulatorOps(ops) {
    return this.addOperators("accumulator", ops);
  }
  addExpressionOps(ops) {
    return this.addOperators("expression", ops);
  }
  addQueryOps(ops) {
    return this.addOperators("query", ops);
  }
  addPipelineOps(ops) {
    return this.addOperators("pipeline", ops);
  }
  addProjectionOps(ops) {
    return this.addOperators("projection", ops);
  }
  addWindowOps(ops) {
    return this.addOperators("window", ops);
  }
};
_operators = new WeakMap();
var Context = _Context;
var GC = Context.init();
var GC_REGISTRY = {
  [
    "accumulator"
    /* ACCUMULATOR */
  ]: GC.addAccumulatorOps.bind(GC),
  [
    "expression"
    /* EXPRESSION */
  ]: GC.addExpressionOps.bind(GC),
  [
    "pipeline"
    /* PIPELINE */
  ]: GC.addPipelineOps.bind(GC),
  [
    "projection"
    /* PROJECTION */
  ]: GC.addProjectionOps.bind(GC),
  [
    "query"
    /* QUERY */
  ]: GC.addQueryOps.bind(GC),
  [
    "window"
    /* WINDOW */
  ]: GC.addWindowOps.bind(GC)
};
function useOperators(type, operators) {
  for (const [name, fn] of Object.entries(operators)) {
    assert(
      isFunction(fn) && isOperator(name),
      `'${name}' is not a valid operator`
    );
    const currentFn = getOperator(type, name, null);
    assert(
      !currentFn || fn === currentFn,
      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`
    );
  }
  GC_REGISTRY[type](operators);
}
function getOperator(type, name, options) {
  const { context: ctx, useGlobalContext: fallback } = options || {};
  const fn = ctx ? ctx.getOperator(type, name) : null;
  return !fn && fallback ? GC.getOperator(type, name) : fn;
}
function computeValue(obj, expr, operator, options) {
  const copts = ComputeOptions.init(options, obj);
  return !!operator && isOperator(operator) ? computeOperator(obj, expr, operator, copts) : computeExpression(obj, expr, copts);
}
var SYSTEM_VARS = ["$$ROOT", "$$CURRENT", "$$REMOVE", "$$NOW"];
function computeExpression(obj, expr, options) {
  var _a;
  if (isString(expr) && expr.length > 0 && expr[0] === "$") {
    if (REDACT_ACTIONS.includes(expr)) return expr;
    let ctx = options.root;
    const arr = expr.split(".");
    if (SYSTEM_VARS.includes(arr[0])) {
      switch (arr[0]) {
        case "$$ROOT":
          break;
        case "$$CURRENT":
          ctx = obj;
          break;
        case "$$REMOVE":
          ctx = void 0;
          break;
        case "$$NOW":
          ctx = /* @__PURE__ */ new Date();
          break;
      }
      expr = expr.slice(arr[0].length + 1);
    } else if (arr[0].slice(0, 2) === "$$") {
      ctx = Object.assign(
        {},
        // global vars
        options.variables,
        // current item is added before local variables because the binding may be changed.
        { this: obj },
        // local vars
        (_a = options == null ? void 0 : options.local) == null ? void 0 : _a.variables
      );
      const name = arr[0].slice(2);
      assert(has(ctx, name), `Use of undefined variable: ${name}`);
      expr = expr.slice(2);
    } else {
      expr = expr.slice(1);
    }
    return expr === "" ? ctx : resolve(ctx, expr);
  }
  if (isArray(expr)) {
    return expr.map((item) => computeExpression(obj, item, options));
  }
  if (isObject(expr)) {
    const result = {};
    const elems = Object.entries(expr);
    for (const [key, val] of elems) {
      if (isOperator(key)) {
        assert(elems.length == 1, "expression must have single operator.");
        return computeOperator(obj, val, key, options);
      }
      result[key] = computeExpression(obj, val, options);
    }
    return result;
  }
  return expr;
}
function computeOperator(obj, expr, operator, options) {
  const callExpression = getOperator(
    "expression",
    operator,
    options
  );
  if (callExpression) return callExpression(obj, expr, options);
  const callAccumulator = getOperator(
    "accumulator",
    operator,
    options
  );
  assert(!!callAccumulator, `accumulator '${operator}' is not registered.`);
  if (!isArray(obj)) {
    obj = computeExpression(obj, expr, options);
    expr = null;
  }
  assert(isArray(obj), `arguments must resolve to array for ${operator}.`);
  return callAccumulator(obj, expr, options);
}
var REDACT_ACTIONS = ["$$KEEP", "$$PRUNE", "$$DESCEND"];

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/boolean/index.js
var boolean_exports = {};
__export(boolean_exports, {
  $and: () => $and,
  $not: () => $not,
  $or: () => $or
});

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/boolean/and.js
var $and = (obj, expr, options) => {
  const value = computeValue(obj, expr, null, options);
  return truthy(value, options.useStrictMode) && value.every((v) => truthy(v, options.useStrictMode));
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/boolean/not.js
var $not = (obj, expr, options) => {
  const booleanExpr = ensureArray(expr);
  if (booleanExpr.length == 0) return false;
  assert(booleanExpr.length == 1, "Expression $not takes exactly 1 argument");
  return !computeValue(obj, booleanExpr[0], null, options);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/boolean/or.js
var $or = (obj, expr, options) => {
  const value = computeValue(obj, expr, null, options);
  const strict = options.useStrictMode;
  return truthy(value, strict) && value.some((v) => truthy(v, strict));
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/index.js
var comparison_exports = {};
__export(comparison_exports, {
  $cmp: () => $cmp,
  $eq: () => $eq2,
  $gt: () => $gt2,
  $gte: () => $gte2,
  $lt: () => $lt2,
  $lte: () => $lte2,
  $ne: () => $ne2
});

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js
var $cmp = (obj, expr, options) => {
  const args = computeValue(obj, expr, null, options);
  assert(
    isArray(args) && args.length == 2,
    "$cmp: expression must resolve to array of size 2."
  );
  return compare(args[0], args[1]);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/lazy.js
function Lazy(source) {
  return source instanceof Iterator ? source : new Iterator(source);
}
function concat(...iterators) {
  let index = 0;
  return Lazy(() => {
    while (index < iterators.length) {
      const o = iterators[index].next();
      if (!o.done) return o;
      index++;
    }
    return { done: true };
  });
}
function isGenerator(o) {
  return !!o && typeof o === "object" && typeof (o == null ? void 0 : o.next) === "function";
}
function isIterable(o) {
  return !!o && (typeof o === "object" || typeof o === "function") && typeof o[Symbol.iterator] === "function";
}
var _iteratees, _buffer, _getNext, _done;
var Iterator = class {
  constructor(source) {
    __privateAdd(this, _iteratees, []);
    __privateAdd(this, _buffer, []);
    __privateAdd(this, _getNext);
    __privateAdd(this, _done, false);
    const iter = isIterable(source) ? source[Symbol.iterator]() : isGenerator(source) ? source : typeof source === "function" ? { next: source } : null;
    assert(
      !!iter,
      `Iterator must be initialized with an iterable or function.`
    );
    let index = -1;
    let current = { done: false };
    __privateSet(this, _getNext, () => {
      while (!current.done) {
        current = iter.next();
        if (current.done) break;
        let value = current.value;
        index++;
        const ok = __privateGet(this, _iteratees).every(({ op: action, fn }) => {
          const res = fn(value, index);
          return action === "map" ? !!(value = res) || true : res;
        });
        if (ok) return { value, done: false };
      }
      return { done: true };
    });
  }
  /**
   * Add an iteratee to this lazy sequence
   */
  push(op, fn) {
    __privateGet(this, _iteratees).push({ op, fn });
    return this;
  }
  next() {
    return __privateGet(this, _getNext).call(this);
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f) {
    return this.push("map", f);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} f
   */
  filter(f) {
    return this.push("filter", f);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n) {
    return n > 0 ? this.filter((_) => !(n === 0 || n-- === 0)) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n) {
    return n > 0 ? this.filter((_) => n === 0 || n-- === 0) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Callback<Source, Any[]>} fn Tranform function of type (Array) => (Any)
   */
  transform(fn) {
    const self = this;
    let iter;
    return Lazy(() => {
      if (!iter) iter = Lazy(fn(self.value()));
      return iter.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    while (!__privateGet(this, _done)) {
      const { done, value } = __privateGet(this, _getNext).call(this);
      if (!done) __privateGet(this, _buffer).push(value);
      __privateSet(this, _done, done);
    }
    return __privateGet(this, _buffer);
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f) {
    for (; ; ) {
      const o = this.next();
      if (o.done) break;
      if (f(o.value) === false) return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f, initialValue) {
    let o = this.next();
    if (initialValue === void 0 && !o.done) {
      initialValue = o.value;
      o = this.next();
    }
    while (!o.done) {
      initialValue = f(initialValue, o.value);
      o = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce(
      (acc, _) => ++acc,
      0
    );
  }
  [Symbol.iterator]() {
    return this;
  }
};
_iteratees = new WeakMap();
_buffer = new WeakMap();
_getNext = new WeakMap();
_done = new WeakMap();

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/pipeline/limit.js
var $limit = (collection, expr, _options4) => collection.take(expr);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/pipeline/project.js
var $project = (collection, expr, options) => {
  if (isEmpty(expr)) return collection;
  validateExpression(expr, options);
  return collection.map(createHandler(expr, ComputeOptions.init(options)));
};
function createHandler(expr, options, isRoot = true) {
  const idKey = options.idKey;
  const expressionKeys2 = Object.keys(expr);
  const excludedKeys = new Array();
  const includedKeys = new Array();
  const handlers = {};
  for (const key of expressionKeys2) {
    const subExpr = expr[key];
    if (isNumber(subExpr) || isBoolean(subExpr)) {
      if (subExpr) {
        includedKeys.push(key);
      } else {
        excludedKeys.push(key);
      }
    } else if (isArray(subExpr)) {
      handlers[key] = (o) => subExpr.map((v) => computeValue(o, v, null, options.update(o)) ?? null);
    } else if (isObject(subExpr)) {
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const projectFn = getOperator(
        OpType.PROJECTION,
        operator,
        options
      );
      if (projectFn) {
        const foundSlice = operator === "$slice";
        if (foundSlice && !ensureArray(subExpr[operator]).every(isNumber)) {
          handlers[key] = (o) => computeValue(o, subExpr, key, options.update(o));
        } else {
          handlers[key] = (o) => projectFn(o, subExpr[operator], key, options.update(o));
        }
      } else if (isOperator(operator)) {
        handlers[key] = (o) => computeValue(o, subExpr[operator], operator, options);
      } else {
        validateExpression(subExpr, options);
        handlers[key] = (o) => {
          if (!has(o, key)) return computeValue(o, subExpr, null, options);
          if (isRoot) options.update(o);
          const target = resolve(o, key);
          const fn = createHandler(subExpr, options, false);
          if (isArray(target)) return target.map(fn);
          if (isObject(target)) return fn(target);
          return fn(o);
        };
      }
    } else {
      handlers[key] = isString(subExpr) && subExpr[0] === "$" ? (o) => computeValue(o, subExpr, key, options) : (_) => subExpr;
    }
  }
  const handlerKeys = Object.keys(handlers);
  const idKeyExcluded = excludedKeys.includes(idKey);
  const idKeyOnlyExcluded = isRoot && idKeyExcluded && excludedKeys.length === 1 && !includedKeys.length && !handlerKeys.length;
  if (idKeyOnlyExcluded) {
    return (o) => {
      const newObj = { ...o };
      delete newObj[idKey];
      return newObj;
    };
  }
  const idKeyImplicit = isRoot && !idKeyExcluded && !includedKeys.includes(idKey);
  const opts = {
    preserveMissing: true
  };
  return (o) => {
    const newObj = {};
    if (excludedKeys.length && !includedKeys.length) {
      merge(newObj, o);
      for (const k of excludedKeys) {
        removeValue(newObj, k, { descendArray: true });
      }
    }
    for (const k of includedKeys) {
      const pathObj = resolveGraph(o, k, opts) ?? {};
      merge(newObj, pathObj);
    }
    if (includedKeys.length) filterMissing(newObj);
    for (const k of handlerKeys) {
      const value = handlers[k](o);
      if (value === void 0) {
        removeValue(newObj, k, { descendArray: true });
      } else {
        setValue(newObj, k, value);
      }
    }
    if (idKeyImplicit && has(o, idKey)) {
      newObj[idKey] = resolve(o, idKey);
    }
    return newObj;
  };
}
function validateExpression(expr, options) {
  let exclusions = false;
  let inclusions = false;
  for (const [k, v] of Object.entries(expr)) {
    assert(!k.startsWith("$"), "Field names may not start with '$'.");
    assert(
      !k.endsWith(".$"),
      "Positional projection operator '$' is not supported."
    );
    if (k === (options == null ? void 0 : options.idKey)) continue;
    if (v === 0 || v === false) {
      exclusions = true;
    } else if (v === 1 || v === true) {
      inclusions = true;
    }
    assert(
      !(exclusions && inclusions),
      "Projection cannot have a mix of inclusion and exclusion."
    );
  }
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/pipeline/skip.js
var $skip = (collection, expr, _options4) => {
  return collection.drop(expr);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/pipeline/sort.js
var $sort = (collection, sortKeys, options) => {
  if (isEmpty(sortKeys) || !isObject(sortKeys)) return collection;
  let cmp = compare;
  const collationSpec = options.collation;
  if (isObject(collationSpec) && isString(collationSpec.locale)) {
    cmp = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = groupBy(
        coll,
        (obj) => resolve(obj, key),
        options.hashFunction
      );
      const sortedKeys = Array.from(groups.keys()).sort(cmp);
      if (sortKeys[key] === -1) sortedKeys.reverse();
      let i = 0;
      for (const k of sortedKeys) for (const v of groups.get(k)) coll[i++] = v;
      assert(i == coll.length, "bug: counter must match collection size.");
    }
    return coll;
  });
};
var COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a ≠ b, a ≠ á, a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if (spec.caseLevel === true) {
    if (localeOpt.sensitivity === "base") localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent") localeOpt.sensitivity = "variant";
  }
  const collator = new Intl.Collator(spec.locale, localeOpt);
  return (a, b) => {
    if (!isString(a) || !isString(b)) return compare(a, b);
    const i = collator.compare(a, b);
    if (i < 0) return -1;
    if (i > 0) return 1;
    return 0;
  };
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/cursor.js
var OPERATORS = { $sort, $skip, $limit };
var _source, _predicate, _projection, _options2, _operators2, _result, _buffer2;
var Cursor2 = class {
  /**
   * Creates an instance of the Cursor class.
   *
   * @param source - The source of data to be iterated over.
   * @param predicate - A function or condition to filter the data.
   * @param projection - An object specifying the fields to include or exclude in the result.
   * @param options - Optional settings to customize the behavior of the cursor.
   */
  constructor(source, predicate, projection, options) {
    __privateAdd(this, _source);
    __privateAdd(this, _predicate);
    __privateAdd(this, _projection);
    __privateAdd(this, _options2);
    __privateAdd(this, _operators2, {});
    __privateAdd(this, _result, null);
    __privateAdd(this, _buffer2, []);
    __privateSet(this, _source, source);
    __privateSet(this, _predicate, predicate);
    __privateSet(this, _projection, projection);
    __privateSet(this, _options2, options);
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (__privateGet(this, _result)) return __privateGet(this, _result);
    __privateSet(this, _result, Lazy(__privateGet(this, _source)).filter(__privateGet(this, _predicate)));
    const mode = __privateGet(this, _options2).processingMode;
    if (mode & ProcessingMode.CLONE_INPUT) __privateGet(this, _result).map(cloneDeep);
    for (const op of ["$sort", "$skip", "$limit"]) {
      if (has(__privateGet(this, _operators2), op)) {
        __privateSet(this, _result, OPERATORS[op](
          __privateGet(this, _result),
          __privateGet(this, _operators2)[op],
          __privateGet(this, _options2)
        ));
      }
    }
    if (Object.keys(__privateGet(this, _projection)).length) {
      __privateSet(this, _result, $project(__privateGet(this, _result), __privateGet(this, _projection), __privateGet(this, _options2)));
    }
    if (mode & ProcessingMode.CLONE_OUTPUT) __privateGet(this, _result).map(cloneDeep);
    return __privateGet(this, _result);
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = Lazy([...__privateGet(this, _buffer2)]);
    __privateGet(this, _buffer2).length = 0;
    return concat(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n) {
    __privateGet(this, _operators2)["$skip"] = n;
    return this;
  }
  /**
   * Limits the number of items returned by the cursor.
   *
   * @param n - The maximum number of items to return.
   * @returns The current cursor instance for chaining.
   */
  limit(n) {
    __privateGet(this, _operators2)["$limit"] = n;
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {AnyObject} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    __privateGet(this, _operators2)["$sort"] = modifier;
    return this;
  }
  /**
   * Applies a sort operation to the cursor using the specified sort modifier.
   *
   * @param modifier - An object specifying the sort order. The keys represent
   * the field names, and the values indicate the sort direction (e.g., 1 for
   * ascending and -1 for descending).
   * @returns The current cursor instance for method chaining.
   */
  collation(spec) {
    __privateSet(this, _options2, { ...__privateGet(this, _options2), collation: spec });
    return this;
  }
  /**
   * Retrieves the next item in the cursor.
   *
   * If there are items in the internal buffer, the next item is returned from the buffer.
   * Otherwise, it fetches the next item from the underlying data source.
   *
   * @returns The next item of type `T` if available, or `undefined` if there are no more items.
   */
  next() {
    if (__privateGet(this, _buffer2).length > 0) {
      return __privateGet(this, _buffer2).pop();
    }
    const o = this.fetch().next();
    if (o.done) return;
    return o.value;
  }
  /**
   * Determines if there are more elements available in the cursor.
   *
   * This method checks if there are any elements left in the internal buffer.
   * If the buffer is empty, it attempts to fetch the next element from the source.
   * If a new element is found, it is added to the buffer and the method returns `true`.
   * Otherwise, it returns `false` indicating no more elements are available.
   *
   * @returns {boolean} `true` if there are more elements to iterate over, otherwise `false`.
   */
  hasNext() {
    if (__privateGet(this, _buffer2).length > 0) return true;
    const o = this.fetch().next();
    if (o.done) return false;
    __privateGet(this, _buffer2).push(o.value);
    return true;
  }
  /**
   * Transforms the elements of the cursor using the provided callback function.
   *
   * @template R - The type of the elements in the resulting array.
   * @template T - The type of the elements in the cursor.
   * @param fn - A callback function that is invoked for each element in the cursor.
   *             It receives the current element, its index, and the entire array as arguments.
   * @returns An array of transformed elements of type `R`.
   */
  map(fn) {
    return this.all().map(fn);
  }
  /**
   * Iterates over all elements in the cursor and executes the provided callback function for each element.
   *
   * @param fn - A callback function to execute for each element. The function receives the following arguments:
   *   - `t`: The current element being processed in the cursor.
   *   - `i`: The index of the current element in the array.
   *   - `a`: The array of all elements in the cursor.
   */
  forEach(fn) {
    this.all().forEach(fn);
  }
  /**
   * Returns an iterator for the cursor, allowing it to be used in `for...of` loops.
   * The iterator fetches all the results from the cursor.
   *
   * @returns {Iterator} An iterator over the fetched results.
   */
  [Symbol.iterator]() {
    return this.fetchAll();
  }
};
_source = new WeakMap();
_predicate = new WeakMap();
_projection = new WeakMap();
_options2 = new WeakMap();
_operators2 = new WeakMap();
_result = new WeakMap();
_buffer2 = new WeakMap();

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/query.js
var TOP_LEVEL_RE = /^\$(and|or|nor|expr|jsonSchema)$/;
var _compiled, _options3, _condition;
var Query = class {
  /**
   * Creates an instance of the query with the specified condition and options.
   *
   * @param condition - The query condition object used to define the criteria for matching documents.
   * @param options - Optional configuration settings to customize the query behavior.
   */
  constructor(condition, options) {
    __privateAdd(this, _compiled);
    __privateAdd(this, _options3);
    __privateAdd(this, _condition);
    __privateSet(this, _condition, cloneDeep(condition));
    __privateSet(this, _options3, initOptions(options));
    __privateSet(this, _compiled, []);
    this.compile();
  }
  compile() {
    assert(
      isObject(__privateGet(this, _condition)),
      `query criteria must be an object: ${JSON.stringify(__privateGet(this, _condition))}`
    );
    const whereOperator = {};
    for (const [field, expr] of Object.entries(__privateGet(this, _condition))) {
      if ("$where" === field) {
        assert(
          __privateGet(this, _options3).scriptEnabled,
          "$where operator requires 'scriptEnabled' option to be true."
        );
        Object.assign(whereOperator, { field, expr });
      } else if (TOP_LEVEL_RE.test(field)) {
        this.processOperator(field, field, expr);
      } else {
        assert(!isOperator(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries(
          normalize(expr)
        )) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(
          whereOperator.field,
          whereOperator.field,
          whereOperator.expr
        );
      }
    }
  }
  processOperator(field, operator, value) {
    const call = getOperator(
      OpType.QUERY,
      operator,
      __privateGet(this, _options3)
    );
    assert(!!call, `unknown query operator ${operator}`);
    __privateGet(this, _compiled).push(call(field, value, __privateGet(this, _options3)));
  }
  /**
   * Tests whether the given object satisfies all compiled predicates.
   *
   * @template T - The type of the object to test.
   * @param obj - The object to be tested against the compiled predicates.
   * @returns `true` if the object satisfies all predicates, otherwise `false`.
   */
  test(obj) {
    return __privateGet(this, _compiled).every((p) => p(obj));
  }
  /**
   * Returns a cursor for iterating over the items in the given collection that match the query criteria.
   *
   * @typeParam T - The type of the items in the resulting cursor.
   * @param collection - The source collection to search through.
   * @param projection - An optional object specifying fields to include or exclude
   *                      in the returned items.
   * @returns A `Cursor` instance for iterating over the matching items.
   */
  find(collection, projection) {
    return new Cursor2(
      collection,
      (o) => this.test(o),
      projection || {},
      __privateGet(this, _options3)
    );
  }
};
_compiled = new WeakMap();
_options3 = new WeakMap();
_condition = new WeakMap();

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/_predicates.js
function processQuery(selector, value, options, predicate) {
  const opts = { unwrapArray: true };
  const depth = Math.max(1, selector.split(".").length - 1);
  return (o) => {
    const lhs = resolve(o, selector, opts);
    return predicate(lhs, value, { ...options, depth });
  };
}
function processExpression(obj, expr, options, predicate) {
  const args = computeValue(obj, expr, null, options);
  return predicate(...args);
}
function $eq(a, b, options) {
  if (isEqual2(a, b)) return true;
  if (isNil(a) && isNil(b)) return true;
  if (isArray(a)) {
    return a.some((v) => isEqual2(v, b)) || flatten(a, options == null ? void 0 : options.depth).some((v) => isEqual2(v, b));
  }
  return false;
}
function $ne(a, b, options) {
  return !$eq(a, b, options);
}
function $in(a, b, options) {
  if (isNil(a)) return b.some((v) => v === null);
  return intersection([ensureArray(a), b], options == null ? void 0 : options.hashFunction).length > 0;
}
function $nin(a, b, options) {
  return !$in(a, b, options);
}
function $lt(a, b, _options4) {
  return compare2(a, b, (x, y) => compare(x, y) < 0);
}
function $lte(a, b, _options4) {
  return compare2(a, b, (x, y) => compare(x, y) <= 0);
}
function $gt(a, b, _options4) {
  return compare2(a, b, (x, y) => compare(x, y) > 0);
}
function $gte(a, b, _options4) {
  return compare2(a, b, (x, y) => compare(x, y) >= 0);
}
function $mod(a, b, _options4) {
  return ensureArray(a).some(
    (x) => b.length === 2 && x % b[0] === b[1]
  );
}
function $regex(a, b, options) {
  const lhs = ensureArray(a);
  const match2 = (x) => isString(x) && truthy(b.exec(x), options == null ? void 0 : options.useStrictMode);
  return lhs.some(match2) || flatten(lhs, 1).some(match2);
}
function $all(values, queries, options) {
  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query of queries) {
    if (!matched) break;
    if (isObject(query) && Object.keys(query).includes("$elemMatch")) {
      matched = $elemMatch(values, query["$elemMatch"], options);
    } else if (isRegExp(query)) {
      matched = values.some((s) => typeof s === "string" && query.test(s));
    } else {
      matched = values.some((v) => isEqual2(query, v));
    }
  }
  return matched;
}
function $size(a, b, _options4) {
  return Array.isArray(a) && a.length === b;
}
function isNonBooleanOperator(name) {
  return isOperator(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch(a, b, options) {
  if (isArray(a) && !isEmpty(a)) {
    let format = (x) => x;
    let criteria = b;
    if (Object.keys(b).every(isNonBooleanOperator)) {
      criteria = { temp: b };
      format = (x) => ({ temp: x });
    }
    const query = new Query(criteria, options);
    for (let i = 0, len = a.length; i < len; i++) {
      if (query.test(format(a[i]))) {
        return true;
      }
    }
  }
  return false;
}
var isNull = (a) => a === null;
var compareFuncs = {
  array: isArray,
  boolean: isBoolean,
  bool: isBoolean,
  date: isDate,
  number: isNumber,
  int: isNumber,
  long: isNumber,
  double: isNumber,
  decimal: isNumber,
  null: isNull,
  object: isObject,
  regexp: isRegExp,
  regex: isRegExp,
  string: isString,
  // added for completeness
  undefined: isNil,
  // deprecated
  // Mongo identifiers
  1: isNumber,
  //double
  2: isString,
  3: isObject,
  4: isArray,
  6: isNil,
  // deprecated
  8: isBoolean,
  9: isDate,
  10: isNull,
  11: isRegExp,
  16: isNumber,
  //int
  18: isNumber,
  //long
  19: isNumber
  //decimal
};
function compareType(a, b, _) {
  const f = compareFuncs[b];
  return f ? f(a) : false;
}
function $type(a, b, options) {
  return isArray(b) ? b.findIndex((t) => compareType(a, t, options)) >= 0 : compareType(a, b, options);
}
function compare2(a, b, f) {
  return ensureArray(a).some((x) => typeOf(x) === typeOf(b) && f(x, b));
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/eq.js
var $eq2 = (obj, expr, options) => processExpression(obj, expr, options, $eq);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/gt.js
var $gt2 = (obj, expr, options) => processExpression(obj, expr, options, $gt);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/gte.js
var $gte2 = (obj, expr, options) => processExpression(obj, expr, options, $gte);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/lt.js
var $lt2 = (obj, expr, options) => processExpression(obj, expr, options, $lt);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/lte.js
var $lte2 = (obj, expr, options) => processExpression(obj, expr, options, $lte);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/comparison/ne.js
var $ne2 = (obj, expr, options) => processExpression(obj, expr, options, $ne);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/expression/array/slice.js
var $slice = (obj, expr, options) => {
  const args = computeValue(obj, expr, null, options);
  const arr = args[0];
  let skip = args[1];
  let limit = args[2];
  if (isNil(limit)) {
    if (skip < 0) {
      skip = Math.max(0, arr.length + skip);
    } else {
      limit = skip;
      skip = 0;
    }
  } else {
    if (skip < 0) {
      skip = Math.max(0, arr.length + skip);
    }
    assert(
      limit > 0,
      `Invalid argument for $slice operator. Limit must be a positive number`
    );
    limit += skip;
  }
  return arr.slice(skip, limit);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/projection/index.js
var projection_exports = {};
__export(projection_exports, {
  $elemMatch: () => $elemMatch2,
  $slice: () => $slice2
});

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/projection/elemMatch.js
var $elemMatch2 = (obj, expr, field, options) => {
  const arr = resolve(obj, field);
  const query = new Query(expr, options);
  assert(isArray(arr), "$elemMatch: argument must resolve to array");
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (query.test(arr[i])) {
      if (options.useStrictMode) return [arr[i]];
      result.push(arr[i]);
    }
  }
  return result.length > 0 ? result : void 0;
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/projection/slice.js
var $slice2 = (obj, expr, field, options) => {
  const xs = resolve(obj, field);
  const exprAsArray = expr;
  if (!isArray(xs)) return xs;
  return $slice(
    obj,
    isArray(expr) ? [xs, ...exprAsArray] : [xs, expr],
    options
  );
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/index.js
var query_exports = {};
__export(query_exports, {
  $all: () => $all2,
  $and: () => $and2,
  $bitsAllClear: () => $bitsAllClear,
  $bitsAllSet: () => $bitsAllSet,
  $bitsAnyClear: () => $bitsAnyClear,
  $bitsAnySet: () => $bitsAnySet,
  $elemMatch: () => $elemMatch3,
  $eq: () => $eq3,
  $exists: () => $exists,
  $expr: () => $expr,
  $gt: () => $gt3,
  $gte: () => $gte3,
  $in: () => $in2,
  $jsonSchema: () => $jsonSchema,
  $lt: () => $lt3,
  $lte: () => $lte3,
  $mod: () => $mod2,
  $ne: () => $ne3,
  $nin: () => $nin2,
  $nor: () => $nor,
  $not: () => $not2,
  $or: () => $or2,
  $regex: () => $regex2,
  $size: () => $size2,
  $type: () => $type2,
  $where: () => $where
});

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/array/all.js
var $all2 = (selector, value, options) => processQuery(selector, value, options, $all);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/array/elemMatch.js
var $elemMatch3 = (selector, value, options) => processQuery(selector, value, options, $elemMatch);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/array/size.js
var $size2 = (selector, value, options) => processQuery(selector, value, options, $size);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js
var processBitwiseQuery = (selector, value, predicate) => {
  return processQuery(
    selector,
    value,
    null,
    (value2, mask) => {
      let b = 0;
      if (isArray(mask)) {
        for (const n of mask) b = b | 1 << n;
      } else {
        b = mask;
      }
      return predicate(value2 & b, b);
    }
  );
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllClear.js
var $bitsAllClear = (selector, value, _options4) => processBitwiseQuery(selector, value, (result, _) => result == 0);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllSet.js
var $bitsAllSet = (selector, value, _options4) => processBitwiseQuery(selector, value, (result, mask) => result == mask);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js
var $bitsAnyClear = (selector, value, _options4) => processBitwiseQuery(selector, value, (result, mask) => result < mask);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnySet.js
var $bitsAnySet = (selector, value, _options4) => processBitwiseQuery(selector, value, (result, _) => result > 0);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/eq.js
var $eq3 = (selector, value, options) => processQuery(selector, value, options, $eq);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/gt.js
var $gt3 = (selector, value, options) => processQuery(selector, value, options, $gt);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/gte.js
var $gte3 = (selector, value, options) => processQuery(selector, value, options, $gte);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/in.js
var $in2 = (selector, value, options) => processQuery(selector, value, options, $in);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/lt.js
var $lt3 = (selector, value, options) => processQuery(selector, value, options, $lt);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/lte.js
var $lte3 = (selector, value, options) => processQuery(selector, value, options, $lte);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/ne.js
var $ne3 = (selector, value, options) => processQuery(selector, value, options, $ne);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/comparison/nin.js
var $nin2 = (selector, value, options) => processQuery(selector, value, options, $nin);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/element/exists.js
var $exists = (selector, value, _options4) => {
  const nested = selector.includes(".");
  const b = !!value;
  if (!nested || selector.match(/\.\d+$/)) {
    return (o) => resolve(o, selector) !== void 0 === b;
  }
  return (o) => {
    const path = resolveGraph(o, selector, { preserveIndex: true });
    const val = resolve(path, selector.substring(0, selector.lastIndexOf(".")));
    return isArray(val) ? val.some((v) => v !== void 0) === b : val !== void 0 === b;
  };
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/element/type.js
var $type2 = (selector, value, options) => processQuery(selector, value, options, $type);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/evaluation/expr.js
function $expr(_, rhs, options) {
  return (obj) => computeValue(obj, rhs, null, options);
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js
function $jsonSchema(_, schema, options) {
  assert(
    !!(options == null ? void 0 : options.jsonSchemaValidator),
    "$jsonSchema: must configure 'jsonSchemaValidator' option to this operator."
  );
  const validate = options == null ? void 0 : options.jsonSchemaValidator(schema);
  return (obj) => validate(obj);
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/evaluation/mod.js
var $mod2 = (selector, value, options) => processQuery(selector, value, options, $mod);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/evaluation/regex.js
var $regex2 = (selector, value, options) => processQuery(selector, value, options, $regex);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/evaluation/where.js
function $where(_, rhs, options) {
  assert(
    options.scriptEnabled,
    "$where operator requires 'scriptEnabled' option to be true"
  );
  const f = rhs;
  assert(isFunction(f), "$where only accepts a Function object");
  return (obj) => truthy(f.call(obj), options == null ? void 0 : options.useStrictMode);
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/logical/and.js
var $and2 = (_, rhs, options) => {
  assert(
    isArray(rhs),
    "Invalid expression: $and expects value to be an Array."
  );
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.every((q) => q.test(obj));
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/logical/or.js
var $or2 = (_, rhs, options) => {
  assert(isArray(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.some((q) => q.test(obj));
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/logical/nor.js
var $nor = (_, rhs, options) => {
  assert(
    isArray(rhs),
    "Invalid expression. $nor expects value to be an array."
  );
  const f = $or2("$or", rhs, options);
  return (obj) => !f(obj);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/query/logical/not.js
var $not2 = (selector, rhs, options) => {
  const criteria = {};
  criteria[selector] = normalize(rhs);
  const query = new Query(criteria, options);
  return (obj) => !query.test(obj);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/init/basic.js
useOperators(OpType.EXPRESSION, {
  ...boolean_exports,
  ...comparison_exports
});
useOperators(OpType.PIPELINE, {
  $project,
  $skip,
  $limit,
  $sort
});
useOperators(OpType.PROJECTION, projection_exports);
useOperators(OpType.QUERY, query_exports);

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/index.js
var update_exports = {};
__export(update_exports, {
  $addToSet: () => $addToSet,
  $bit: () => $bit,
  $currentDate: () => $currentDate,
  $inc: () => $inc,
  $max: () => $max,
  $min: () => $min,
  $mul: () => $mul,
  $pop: () => $pop,
  $pull: () => $pull,
  $pullAll: () => $pullAll,
  $push: () => $push2,
  $rename: () => $rename,
  $set: () => $set,
  $unset: () => $unset
});

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/_internal.js
var UPDATE_OPTIONS = {
  cloneMode: "copy",
  queryOptions: initOptions({
    context: Context.init().addQueryOps(query_exports).addExpressionOps(boolean_exports).addExpressionOps(comparison_exports)
  })
};
var clone = (mode, val) => {
  switch (mode) {
    case "deep":
      return cloneDeep(val);
    case "copy": {
      if (isDate(val)) return new Date(val);
      if (isArray(val)) return [...val];
      if (isObject(val)) return { ...val };
      if (isRegExp(val)) return new RegExp(val);
      return val;
    }
    default:
      return val;
  }
};
var FILTER_IDENT_RE = /^[a-z]+[a-zA-Z0-9]*$/;
function tokenizePath(selector) {
  if (!selector.includes(".$")) {
    return [{ parent: selector, selector }, []];
  }
  const begin = selector.indexOf(".$");
  const end = selector.indexOf("]");
  const parent = selector.substring(0, begin);
  const child = selector.substring(begin + 3, end);
  assert(
    child === "" || FILTER_IDENT_RE.test(child),
    "The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters."
  );
  const rest = selector.substring(end + 2);
  const [next, elems] = rest ? tokenizePath(rest) : [];
  return [
    { selector, parent, child: child || "$", next },
    [child, ...elems || []].filter(Boolean)
  ];
}
var applyUpdate = (o, n, q, f, opts) => {
  const { parent, child: c, next } = n;
  if (!c) {
    let b = false;
    const g = (u, k) => b = Boolean(f(u, k)) || b;
    walk(o, parent, g, opts);
    return b;
  }
  const t = resolve(o, parent);
  if (!isArray(t)) return false;
  return t.map((e, i) => {
    if (q[c] && !q[c].test({ [c]: e })) return false;
    return next ? applyUpdate(e, next, q, f, opts) : f(t, i);
  }).some(Boolean);
};
function walkExpression(expr, arrayFilter, options, callback) {
  const res = [];
  for (const [selector, val] of Object.entries(expr)) {
    const [node, vars] = tokenizePath(selector);
    if (!vars.length) {
      if (callback(val, node, {})) res.push(node.parent);
    } else {
      const conditions = {};
      arrayFilter.forEach((o) => {
        Object.keys(o).forEach((k) => {
          vars.forEach((w) => {
            if (k === w || k.startsWith(w + ".")) {
              conditions[w] = conditions[w] || {};
              Object.assign(conditions[w], { [k]: o[k] });
            }
          });
        });
      });
      const queries = {};
      for (const [k, condition] of Object.entries(conditions)) {
        queries[k] = new Query(condition, options.queryOptions);
      }
      if (callback(val, node, queries)) res.push(node.parent);
    }
  }
  return res;
}

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/addToSet.js
var $addToSet = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const args = { $each: [val] };
    if (isObject(val) && has(val, "$each")) {
      Object.assign(args, val);
    }
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        const prev = o[k] || (o[k] = []);
        const common = intersection([prev, args.$each]);
        if (common.length === args.$each.length) return false;
        o[k] = clone(options.cloneMode, unique(prev.concat(args.$each)));
        return true;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/bit.js
var BIT_OPS = /* @__PURE__ */ new Set(["and", "or", "xor"]);
var $bit = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const op = Object.keys(val);
    assert(
      op.length === 1 && BIT_OPS.has(op[0]),
      `Invalid bit operator '${op[0]}'. Must be one of 'and', 'or', or 'xor'.`
    );
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        let n = o[k];
        const v = val[op[0]];
        if (n !== void 0 && !(isNumber(n) && isNumber(v))) return false;
        n = n || 0;
        switch (op[0]) {
          case "and":
            o[k] = n & v;
            break;
          case "or":
            o[k] = n | v;
            break;
          case "xor":
            o[k] = n ^ v;
            break;
        }
        return o[k] !== n;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/currentDate.js
var $currentDate = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  const now = Date.now();
  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        o[k] = now;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/inc.js
var $inc = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    if (!node.child) {
      const n = resolve(obj, node.parent);
      assert(
        n === void 0 || isNumber(n),
        `cannot apply $inc to a value of non-numeric type`
      );
    }
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        o[k] = (o[k] || (o[k] = 0)) + val;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/max.js
var $max = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        if (o[k] !== void 0 && compare(o[k], val) > -1) return false;
        o[k] = val;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/min.js
var $min = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        if (o[k] !== void 0 && compare(o[k], val) < 1) return false;
        o[k] = val;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/mul.js
var $mul = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        const prev = o[k];
        o[k] = o[k] === void 0 ? 0 : o[k] * val;
        return o[k] !== prev;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/pop.js
var $pop = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(obj, node, queries, (o, k) => {
      const arr = o[k];
      assert(
        isArray(arr),
        `path '${node.selector}' contains an element of non-array type.`
      );
      if (!arr.length) return false;
      if (val === -1) {
        arr.splice(0, 1);
      } else {
        arr.pop();
      }
      return true;
    });
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/pull.js
var $pull = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const wrap = !isObject(val) || Object.keys(val).some(isOperator);
    const query = new Query(
      wrap ? { k: val } : val,
      options.queryOptions
    );
    const pred = wrap ? (v) => query.test({ k: v }) : (v) => query.test(v);
    return applyUpdate(obj, node, queries, (o, k) => {
      const prev = o[k];
      const curr = new Array();
      const found = prev.map((v) => {
        const b = pred(v);
        if (!b) curr.push(v);
        return b;
      }).some(Boolean);
      if (!found) return false;
      o[k] = curr;
      return true;
    });
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/pullAll.js
var $pullAll = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  const pullExpr = {};
  Object.entries(expr).forEach(([k, v]) => {
    pullExpr[k] = { $in: v };
  });
  return $pull(obj, pullExpr, arrayFilters, options);
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/push.js
var MODIFIERS = ["$each", "$slice", "$sort", "$position"];
var $push2 = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const args = {
      $each: [val]
    };
    if (isObject(val) && MODIFIERS.some((m) => has(val, m))) {
      Object.assign(args, val);
    }
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        const arr = o[k] || (o[k] = []);
        const prev = arr.slice(0, args.$slice || arr.length);
        const oldsize = arr.length;
        const pos = isNumber(args.$position) ? args.$position : arr.length;
        arr.splice(pos, 0, ...clone(options.cloneMode, args.$each));
        if (args.$sort) {
          const sortKey = isObject(args.$sort) ? Object.keys(args.$sort || {}).pop() : "";
          const order = !sortKey ? args.$sort : args.$sort[sortKey];
          const f = !sortKey ? (a) => a : (a) => resolve(a, sortKey);
          arr.sort((a, b) => order * compare(f(a), f(b)));
        }
        if (isNumber(args.$slice)) {
          if (args.$slice < 0) arr.splice(0, arr.length + args.$slice);
          else arr.splice(args.$slice);
        }
        return oldsize != arr.length || !isEqual2(prev, arr);
      },
      { descendArray: true, buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/set.js
var $set = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        if (isEqual2(o[k], val)) return false;
        o[k] = clone(options.cloneMode, val);
        return true;
      },
      { buildGraph: true }
    );
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/rename.js
var $rename = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  const res = [];
  const changed = walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(obj, node, queries, (o, k) => {
      if (!has(o, k)) return false;
      res.push(...$set(obj, { [val]: o[k] }, arrayFilters, options));
      delete o[k];
      return true;
    });
  });
  return Array.from(new Set(changed.concat(res)));
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/operators/update/unset.js
var $unset = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {
    return applyUpdate(obj, node, queries, (o, k) => {
      if (!has(o, k)) return false;
      if (isArray(o)) {
        o[k] = null;
      } else {
        delete o[k];
      }
      return true;
    });
  });
};

// node_modules/.pnpm/mingo@6.6.1/node_modules/mingo/dist/esm/updater.js
function createUpdater(defaultOptions) {
  defaultOptions = defaultOptions ?? UPDATE_OPTIONS;
  return (obj, expr, arrayFilters = [], condition = {}, options = defaultOptions) => {
    const entry = Object.entries(expr);
    assert(
      entry.length === 1,
      "Update expression must contain only one operator."
    );
    const [op, args] = entry[0];
    assert(
      has(update_exports, op),
      `Update operator '${op}' is not supported.`
    );
    const mutate = update_exports[op];
    if (Object.keys(condition).length) {
      const q = new Query(condition, options.queryOptions);
      if (!q.test(obj)) return [];
    }
    return mutate(obj, args, arrayFilters, options);
  };
}
var update = createUpdater();

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index18.mjs
function match(item, selector) {
  const query = new Query(selector);
  return query.test(item);
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index19.mjs
function clone2(value) {
  if (typeof value === "function")
    throw new Error("Cloning functions is not supported");
  if (value === null || typeof value !== "object")
    return value;
  if (value instanceof Date)
    return new Date(value);
  if (Array.isArray(value))
    return value.map((item) => clone2(item));
  if (value instanceof Map) {
    const result2 = /* @__PURE__ */ new Map();
    value.forEach((currentValue, key) => {
      result2.set(key, clone2(currentValue));
    });
    return result2;
  }
  if (value instanceof Set) {
    const result2 = /* @__PURE__ */ new Set();
    value.forEach((currentValue) => {
      result2.add(clone2(currentValue));
    });
    return result2;
  }
  if (value instanceof RegExp)
    return new RegExp(value);
  const result = {};
  for (const key in value) {
    if (Object.hasOwnProperty.call(value, key)) {
      result[key] = clone2(value[key]);
    }
  }
  return result;
}
function deepClone(object) {
  if (typeof structuredClone === "function")
    return structuredClone(object);
  return clone2(object);
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index11.mjs
function modify(item, modifier) {
  const hasOperators = Object.keys(modifier).some((key) => key.startsWith("$"));
  if (!hasOperators)
    return modifier;
  const clonedItem = deepClone(item);
  update(clonedItem, modifier);
  return clonedItem;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index12.mjs
function randomId() {
  return Math.floor(Math.random() * 1e17).toString(16);
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index20.mjs
function serializeValue(value) {
  if (value == null)
    return null;
  if (typeof value === "string")
    return value;
  if (typeof value === "number")
    return value.toString();
  if (typeof value === "boolean")
    return value.toString();
  if (value instanceof Date)
    return value.toISOString();
  return JSON.stringify(value);
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index21.mjs
function createSignal(reactivityAdapter, initialValue, isEqual3 = Object.is) {
  let value = initialValue;
  const dependency = reactivityAdapter == null ? void 0 : reactivityAdapter.create();
  const isInReactiveScope2 = () => {
    if (!(reactivityAdapter == null ? void 0 : reactivityAdapter.isInScope))
      return true;
    return reactivityAdapter.isInScope();
  };
  const signal = {
    get() {
      if (dependency && isInReactiveScope2())
        dependency.depend();
      return value;
    },
    set(newValue) {
      if (isEqual3(value, newValue))
        return;
      value = newValue;
      if (dependency)
        dependency.notify();
    }
  };
  return signal;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index27.mjs
function intersection2(...arrays) {
  if (arrays.length === 0)
    return [];
  return [...new Set(arrays.reduce((a, b) => a.filter((c) => b.includes(c))))];
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index22.mjs
function getMergedIndexInfo(indexProviders, selector) {
  return indexProviders.reduce((memo, indexProvider) => {
    const info = indexProvider.query(selector);
    if (!info.matched)
      return memo;
    const optimizedSelector = info.keepSelector ? memo.optimizedSelector : Object.fromEntries(Object.entries(memo.optimizedSelector).filter(([key]) => !info.fields.includes(key)));
    return {
      matched: true,
      positions: [...new Set(memo.matched ? intersection2(memo.positions, info.positions) : info.positions)],
      optimizedSelector
    };
  }, {
    matched: false,
    positions: [],
    optimizedSelector: { ...selector }
  });
}
function getIndexInfo(indexProviders, selector) {
  if (selector == null || Object.keys(selector).length <= 0) {
    return { matched: false, positions: [], optimizedSelector: selector };
  }
  const { $and: $and3, $or: $or3, ...rest } = selector;
  const flatInfo = getMergedIndexInfo(indexProviders, rest);
  let { matched, positions } = flatInfo;
  const newSelector = flatInfo.optimizedSelector;
  if (Array.isArray($and3)) {
    const $andNew = [];
    for (const sel of $and3) {
      const { matched: selMatched, positions: selPositions, optimizedSelector } = getIndexInfo(indexProviders, sel);
      if (selMatched) {
        positions = matched ? intersection2(positions, selPositions) : selPositions;
        matched = true;
        if (Object.keys(optimizedSelector).length > 0) {
          $andNew.push(optimizedSelector);
        }
      } else {
        $andNew.push(sel);
      }
    }
    if ($andNew.length > 0)
      newSelector.$and = $andNew;
  }
  if (Array.isArray($or3)) {
    const $orNew = [];
    for (const sel of $or3) {
      const { matched: selMatched, positions: selPositions, optimizedSelector } = getIndexInfo(indexProviders, sel);
      if (selMatched) {
        positions = [.../* @__PURE__ */ new Set([...positions, ...selPositions])];
        matched = true;
        if (Object.keys(optimizedSelector).length > 0) {
          $orNew.push(optimizedSelector);
        }
      } else {
        $orNew.push(sel);
      }
    }
    if ($orNew.length > 0)
      newSelector.$or = $orNew;
  }
  return {
    matched,
    positions: positions || [],
    optimizedSelector: newSelector
  };
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index6.mjs
function createIndexProvider(definition) {
  return definition;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index29.mjs
var expressionKeys = /* @__PURE__ */ new Set([
  "$eq",
  "$gt",
  "$gte",
  "$lt",
  "$lte",
  "$in",
  "$nin",
  "$ne",
  "$exists",
  "$not",
  "$expr",
  "$jsonSchema",
  "$mod",
  "$regex",
  "$options",
  "$text",
  "$where",
  "$all",
  "$elemMatch",
  "$size",
  "$bitsAllClear",
  "$bitsAllSet",
  "$bitsAnyClear",
  "$bitsAnySet"
]);
function isFieldExpression(expression) {
  if (typeof expression !== "object" || expression == null) {
    return false;
  }
  const keys = Object.keys(expression);
  if (keys.length === 0) {
    return false;
  }
  const hasInvalidKeys = keys.some((key) => !expressionKeys.has(key));
  if (hasInvalidKeys)
    return false;
  const hasValidKeys = keys.every((key) => expressionKeys.has(key));
  return hasValidKeys;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index28.mjs
function getMatchingKeys(field, selector) {
  const result = { include: null, exclude: null };
  const fieldSelector = selector[field];
  if (fieldSelector instanceof RegExp)
    return result;
  if (fieldSelector == null)
    return result;
  if (isFieldExpression(fieldSelector)) {
    if (fieldSelector.$ne != null) {
      result.exclude = [serializeValue(fieldSelector.$ne)];
      return result;
    }
    if (Array.isArray(fieldSelector.$in) && fieldSelector.$in.length > 0) {
      result.include = fieldSelector.$in.map(serializeValue);
      return result;
    }
    if (Array.isArray(fieldSelector.$nin) && fieldSelector.$nin.length > 0) {
      result.exclude = fieldSelector.$nin.map(serializeValue);
      return result;
    }
    return { include: null, exclude: null };
  }
  result.include = [serializeValue(fieldSelector)];
  return result;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index14.mjs
function createExternalIndex(field, index) {
  return createIndexProvider({
    query(selector) {
      if (!Object.hasOwnProperty.call(selector, field)) {
        return { matched: false };
      }
      const fieldSelector = selector[field];
      const filteresForNull = fieldSelector == null || fieldSelector.$exists === false;
      const keys = filteresForNull ? { include: null, exclude: [...index.keys()].filter((key) => key != null) } : getMatchingKeys(field, selector);
      if (keys.include == null && keys.exclude == null)
        return { matched: false };
      let includedPositions = [];
      if (keys.include == null) {
        for (const set2 of index.values()) {
          for (const pos of set2) {
            includedPositions.push(pos);
          }
        }
      } else {
        for (const key of keys.include) {
          const posSet = index.get(key);
          if (posSet) {
            for (const pos of posSet) {
              includedPositions.push(pos);
            }
          }
        }
      }
      if (keys.exclude != null) {
        const excludeSet = /* @__PURE__ */ new Set();
        for (const key of keys.exclude) {
          const posSet = index.get(key);
          if (posSet) {
            for (const pos of posSet) {
              excludeSet.add(pos);
            }
          }
        }
        includedPositions = includedPositions.filter((pos) => !excludeSet.has(pos));
      }
      return {
        matched: true,
        positions: includedPositions,
        fields: [field],
        keepSelector: filteresForNull
      };
    },
    rebuild() {
    }
  });
}
function createIndex(field) {
  const index = /* @__PURE__ */ new Map();
  return {
    ...createExternalIndex(field, index),
    rebuild(items) {
      index.clear();
      items.forEach((item, i) => {
        const value = serializeValue(get(item, field));
        const current = index.get(value) || /* @__PURE__ */ new Set();
        current.add(i);
        index.set(value, current);
      });
    }
  };
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index3.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
function hasPendingUpdates(pendingUpdates) {
  return pendingUpdates.added.length > 0 || pendingUpdates.modified.length > 0 || pendingUpdates.removed.length > 0;
}
function applyUpdates(currentItems, { added, modified, removed }) {
  const items = [...currentItems];
  added.forEach((item) => {
    items.push(item);
  });
  modified.forEach((item) => {
    const index = items.findIndex(({ id }) => id === item.id);
    if (index === -1)
      return;
    items[index] = item;
  });
  removed.forEach((item) => {
    const index = items.findIndex(({ id }) => id === item.id);
    if (index === -1)
      return;
    items.splice(index, 1);
  });
  return items;
}
var _Collection = class _Collection2 extends EventEmitter {
  /**
   * Initializes a new instance of the `Collection` class with optional configuration.
   * Sets up memory, persistence, reactivity, and indices as specified in the options.
   * @template T - The type of the items stored in the collection.
   * @template I - The type of the unique identifier for the items.
   * @template U - The transformed item type after applying transformations (default is T).
   * @param options - Optional configuration for the collection.
   * @param options.name - An optional name for the collection.
   * @param options.memory - The in-memory adapter for storing items.
   * @param options.reactivity - The reactivity adapter for observing changes in the collection.
   * @param options.transform - A transformation function to apply to items when retrieving them.
   * @param options.persistence - The persistence adapter for saving and loading items.
   * @param options.indices - An array of index providers for optimized querying.
   * @param options.enableDebugMode - A boolean to enable or disable debug mode.
   * @param options.fieldTracking - A boolean to enable or disable field tracking by default.
   */
  constructor(options) {
    super();
    __publicField4(this, "name");
    __publicField4(this, "options");
    __publicField4(this, "persistenceAdapter", null);
    __publicField4(this, "isPullingSignal");
    __publicField4(this, "isPushingSignal");
    __publicField4(this, "indexProviders", []);
    __publicField4(this, "indicesOutdated", false);
    __publicField4(this, "idIndex", /* @__PURE__ */ new Map());
    __publicField4(this, "debugMode");
    __publicField4(this, "batchOperationInProgress", false);
    __publicField4(this, "isDisposed", false);
    __publicField4(this, "postBatchCallbacks", /* @__PURE__ */ new Set());
    __publicField4(this, "fieldTracking", false);
    __publicField4(this, "persistenceReadyPromise");
    _Collection2.collections.push(this);
    this.name = (options == null ? void 0 : options.name) ?? `${this.constructor.name}-${randomId()}`;
    this.options = {
      memory: [],
      ...options
    };
    this.fieldTracking = this.options.fieldTracking ?? _Collection2.fieldTracking;
    this.debugMode = this.options.enableDebugMode ?? _Collection2.debugMode;
    this.indexProviders = [
      createExternalIndex("id", this.idIndex),
      ...this.options.indices || []
    ];
    this.rebuildIndices();
    this.isPullingSignal = createSignal(this.options.reactivity, !!(options == null ? void 0 : options.persistence));
    this.isPushingSignal = createSignal(this.options.reactivity, false);
    this.on("persistence.pullStarted", () => {
      this.isPullingSignal.set(true);
    });
    this.on("persistence.pullCompleted", () => {
      this.isPullingSignal.set(false);
    });
    this.on("persistence.pushStarted", () => {
      this.isPushingSignal.set(true);
    });
    this.on("persistence.pushCompleted", () => {
      this.isPushingSignal.set(false);
    });
    this.persistenceAdapter = this.options.persistence ?? null;
    if (this.persistenceAdapter) {
      let ongoingSaves = 0;
      let isInitialized = false;
      const pendingUpdates = { added: [], modified: [], removed: [] };
      const loadPersistentData = async (data) => {
        if (!this.persistenceAdapter)
          throw new Error("Persistence adapter not found");
        this.emit("persistence.pullStarted");
        const { items, changes } = data ?? await this.persistenceAdapter.load();
        if (items) {
          if (ongoingSaves > 0)
            return;
          this.memory().splice(0, this.memoryArray().length, ...items);
          this.idIndex.clear();
          this.memory().map((item, index) => {
            this.idIndex.set(serializeValue(item.id), /* @__PURE__ */ new Set([index]));
          });
        } else if (changes) {
          changes.added.forEach((item) => {
            const index = this.memory().findIndex((document) => document.id === item.id);
            if (index !== -1) {
              this.memory().splice(index, 1, item);
              return;
            }
            this.memory().push(item);
            const itemIndex = this.memory().findIndex((document) => document === item);
            this.idIndex.set(serializeValue(item.id), /* @__PURE__ */ new Set([itemIndex]));
          });
          changes.modified.forEach((item) => {
            const index = this.memory().findIndex((document) => document.id === item.id);
            if (index === -1)
              throw new Error("Cannot resolve index for item");
            this.memory().splice(index, 1, item);
          });
          changes.removed.forEach((item) => {
            const index = this.memory().findIndex((document) => document.id === item.id);
            if (index === -1)
              throw new Error("Cannot resolve index for item");
            this.memory().splice(index, 1);
          });
        }
        this.rebuildIndices();
        this.emit("persistence.received");
        setTimeout(() => this.emit("persistence.pullCompleted"), 0);
      };
      const saveQueue = {
        added: [],
        modified: [],
        removed: []
      };
      let isFlushing = false;
      const flushQueue = () => {
        if (!this.persistenceAdapter)
          throw new Error("Persistence adapter not found");
        if (ongoingSaves <= 0)
          this.emit("persistence.pushStarted");
        if (isFlushing)
          return;
        if (!hasPendingUpdates(saveQueue))
          return;
        isFlushing = true;
        ongoingSaves += 1;
        const currentItems = this.memoryArray();
        const changes = { ...saveQueue };
        saveQueue.added = [];
        saveQueue.modified = [];
        saveQueue.removed = [];
        this.persistenceAdapter.save(currentItems, changes).then(() => {
          this.emit("persistence.transmitted");
        }).catch((error) => {
          this.emit("persistence.error", error instanceof Error ? error : new Error(error));
        }).finally(() => {
          ongoingSaves -= 1;
          isFlushing = false;
          flushQueue();
          if (ongoingSaves <= 0)
            this.emit("persistence.pushCompleted");
        });
      };
      this.on("added", (item) => {
        if (!isInitialized) {
          pendingUpdates.added.push(item);
          return;
        }
        saveQueue.added.push(item);
        flushQueue();
      });
      this.on("changed", (item) => {
        if (!isInitialized) {
          pendingUpdates.modified.push(item);
          return;
        }
        saveQueue.modified.push(item);
        flushQueue();
      });
      this.on("removed", (item) => {
        if (!isInitialized) {
          pendingUpdates.removed.push(item);
          return;
        }
        saveQueue.removed.push(item);
        flushQueue();
      });
      this.persistenceAdapter.register((data) => loadPersistentData(data)).then(async () => {
        if (!this.persistenceAdapter)
          throw new Error("Persistence adapter not found");
        let currentItems = this.memoryArray();
        await loadPersistentData();
        while (hasPendingUpdates(pendingUpdates)) {
          const added = pendingUpdates.added.splice(0);
          const modified = pendingUpdates.modified.splice(0);
          const removed = pendingUpdates.removed.splice(0);
          currentItems = applyUpdates(this.memoryArray(), { added, modified, removed });
          await this.persistenceAdapter.save(currentItems, { added, modified, removed }).then(() => {
            this.emit("persistence.transmitted");
          });
        }
        await loadPersistentData();
        isInitialized = true;
        setTimeout(() => this.emit("persistence.init"), 0);
      }).catch((error) => {
        this.emit("persistence.error", error instanceof Error ? error : new Error(error));
      });
    }
    this.persistenceReadyPromise = new Promise((resolve2, reject) => {
      if (!this.persistenceAdapter)
        return resolve2();
      this.once("persistence.init", resolve2);
      this.once("persistence.error", reject);
    });
    _Collection2.onCreationCallbacks.forEach((callback) => callback(this));
  }
  static getCollections() {
    return _Collection2.collections;
  }
  static onCreation(callback) {
    _Collection2.onCreationCallbacks.push(callback);
  }
  static onDispose(callback) {
    _Collection2.onDisposeCallbacks.push(callback);
  }
  /**
   * Executes a batch operation, allowing multiple modifications to the collection
   * while deferring index rebuilding until all operations in the batch are completed.
   * This improves performance by avoiding repetitive index recalculations and
   * provides atomicity for the batch of operations.
   * @param callback - The batch operation to execute.
   */
  static batch(callback) {
    _Collection2.batchOperationInProgress = true;
    _Collection2.collections.reduce((memo, collection) => () => collection.batch(() => memo()), callback)();
    _Collection2.batchOperationInProgress = false;
  }
  /**
   * Checks whether the collection is currently performing a pull operation
   * ⚡️ this function is reactive!
   * (loading data from the persistence adapter).
   * @returns A boolean indicating if the collection is in the process of pulling data.
   */
  isPulling() {
    return this.isPullingSignal.get() ?? false;
  }
  /**
   * Checks whether the collection is currently performing a push operation
   * ⚡️ this function is reactive!
   * (saving data to the persistence adapter).
   * @returns A boolean indicating if the collection is in the process of pushing data.
   */
  isPushing() {
    return this.isPushingSignal.get() ?? false;
  }
  /**
   * Checks whether the collection is currently performing either a pull or push operation,
   * ⚡️ this function is reactive!
   * indicating that it is loading or saving data.
   * @returns A boolean indicating if the collection is in the process of loading or saving data.
   */
  isLoading() {
    const isPulling = this.isPulling();
    const isPushing = this.isPushing();
    return isPulling || isPushing;
  }
  /**
   * Retrieves the current debug mode status of the collection.
   * @returns A boolean indicating whether debug mode is enabled for the collection.
   */
  getDebugMode() {
    return this.debugMode;
  }
  /**
   * Enables or disables debug mode for the collection.
   * When debug mode is enabled, additional debugging information and events are emitted.
   * @param enable - A boolean indicating whether to enable (`true`) or disable (`false`) debug mode.
   */
  setDebugMode(enable) {
    this.debugMode = enable;
  }
  /**
   * Enables or disables field tracking for the collection.
   * @param enable - A boolean indicating whether to enable (`true`) or disable (`false`) field tracking.
   */
  setFieldTracking(enable) {
    this.fieldTracking = enable;
  }
  /**
   * Resolves when the persistence adapter finished initializing
   * and the collection is ready to be used.
   * @returns A promise that resolves when the collection is ready.
   * @example
   * ```ts
   * const collection = new Collection({
   *   persistence: // ...
   * })
   * await collection.isReady()
   *
   * collection.insert({ name: 'Item 1' })
   */
  async isReady() {
    return this.persistenceReadyPromise;
  }
  profile(fn, measureFunction) {
    if (!this.debugMode)
      return fn();
    const startTime = performance.now();
    const result = fn();
    const endTime = performance.now();
    measureFunction(endTime - startTime);
    return result;
  }
  executeInDebugMode(fn) {
    if (!this.debugMode)
      return;
    const callstack = new Error().stack || "";
    fn(callstack);
  }
  rebuildIndices() {
    this.indicesOutdated = true;
    if (this.batchOperationInProgress)
      return;
    this.rebuildAllIndices();
  }
  rebuildAllIndices() {
    this.idIndex.clear();
    this.memory().map((item, index) => {
      this.idIndex.set(serializeValue(item.id), /* @__PURE__ */ new Set([index]));
    });
    this.indexProviders.forEach((index) => index.rebuild(this.memoryArray()));
    this.indicesOutdated = false;
  }
  getIndexInfo(selector) {
    if (selector != null && Object.keys(selector).length === 1 && "id" in selector && typeof selector.id !== "object") {
      return {
        matched: true,
        positions: [...this.idIndex.get(serializeValue(selector.id)) || []],
        optimizedSelector: {}
      };
    }
    if (selector == null) {
      return {
        matched: false,
        positions: [],
        optimizedSelector: {}
      };
    }
    if (this.indicesOutdated) {
      return {
        matched: false,
        positions: [],
        optimizedSelector: selector
      };
    }
    return getIndexInfo(this.indexProviders, selector);
  }
  getItemAndIndex(selector) {
    const memory = this.memoryArray();
    const indexInfo = this.getIndexInfo(selector);
    const items = indexInfo.matched ? indexInfo.positions.map((index2) => memory[index2]) : memory;
    const item = items.find((document) => match(document, selector));
    const foundInIndex = indexInfo.matched && indexInfo.positions.find((itemIndex) => memory[itemIndex] === item);
    const index = foundInIndex || memory.findIndex((document) => document === item);
    if (item == null)
      return { item: null, index: -1 };
    if (index === -1)
      throw new Error("Cannot resolve index for item");
    return { item, index };
  }
  deleteFromIdIndex(id, index) {
    this.idIndex.delete(serializeValue(id));
    if (!this.batchOperationInProgress)
      return;
    this.idIndex.forEach(([currenIndex], key) => {
      if (currenIndex > index) {
        this.idIndex.set(key, /* @__PURE__ */ new Set([currenIndex - 1]));
      }
    });
  }
  memory() {
    return this.options.memory;
  }
  memoryArray() {
    return this.memory().map((item) => item);
  }
  transform(item) {
    if (!this.options.transform)
      return item;
    return this.options.transform(item);
  }
  getItems(selector) {
    return this.profile(() => {
      const indexInfo = this.getIndexInfo(selector);
      const matchItems = (item) => {
        if (indexInfo.optimizedSelector == null)
          return true;
        if (Object.keys(indexInfo.optimizedSelector).length <= 0)
          return true;
        const matches = match(item, indexInfo.optimizedSelector);
        return matches;
      };
      this.emit("getItems", selector);
      const memory = this.memoryArray();
      if (!indexInfo.matched) {
        if (isEqual(selector, {}))
          return memory;
        return memory.filter(matchItems);
      }
      const items = indexInfo.positions.map((index) => memory[index]);
      if (isEqual(indexInfo.optimizedSelector, {}))
        return items;
      return items.filter(matchItems);
    }, (measuredTime) => this.executeInDebugMode((callstack) => this.emit("_debug.getItems", callstack, selector, measuredTime)));
  }
  /**
   * Disposes the collection, unregisters persistence adapters, clears memory, and
   * cleans up all resources used by the collection.
   * @returns A promise that resolves when the collection is disposed.
   */
  async dispose() {
    var _a;
    if ((_a = this.persistenceAdapter) == null ? void 0 : _a.unregister)
      await this.persistenceAdapter.unregister();
    this.persistenceAdapter = null;
    this.memory().map(() => this.memory().pop());
    this.idIndex.clear();
    this.indexProviders = [];
    this.isDisposed = true;
    this.removeAllListeners();
    _Collection2.collections = _Collection2.collections.filter((collection) => collection !== this);
    _Collection2.onDisposeCallbacks.forEach((callback) => callback(this));
  }
  /**
   * Finds multiple items in the collection based on a selector and optional options.
   * Returns a cursor for reactive data queries.
   * @template O - The options type for the find operation.
   * @param [selector] - The criteria to select items.
   * @param [options] - Options for the find operation, such as limit and sort.
   * @returns A cursor to fetch and observe the matching items.
   */
  find(selector, options) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (selector !== void 0 && (!selector || typeof selector !== "object"))
      throw new Error("Invalid selector");
    const cursor = new Cursor(() => this.getItems(selector), {
      reactive: this.options.reactivity,
      fieldTracking: this.fieldTracking,
      ...options,
      transform: this.transform.bind(this),
      bindEvents: (requery) => {
        const handleRequery = () => {
          if (this.batchOperationInProgress) {
            this.postBatchCallbacks.add(requery);
            return;
          }
          requery();
        };
        this.addListener("persistence.received", handleRequery);
        this.addListener("added", handleRequery);
        this.addListener("changed", handleRequery);
        this.addListener("removed", handleRequery);
        this.emit("observer.created", selector, options);
        return () => {
          this.removeListener("persistence.received", handleRequery);
          this.removeListener("added", handleRequery);
          this.removeListener("changed", handleRequery);
          this.removeListener("removed", handleRequery);
          this.emit("observer.disposed", selector, options);
        };
      }
    });
    this.emit("find", selector, options, cursor);
    this.executeInDebugMode((callstack) => this.emit("_debug.find", callstack, selector, options, cursor));
    return cursor;
  }
  /**
   * Finds a single item in the collection based on a selector and optional options.
   * ⚡️ this function is reactive!
   * Returns the found item or undefined if no item matches.
   * @template O - The options type for the find operation.
   * @param selector - The criteria to select the item.
   * @param [options] - Options for the find operation, such as projection.
   * @returns The found item or `undefined`.
   */
  findOne(selector, options) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    const cursor = this.find(selector, {
      limit: 1,
      ...options
    });
    const returnValue = cursor.fetch()[0] || void 0;
    this.emit("findOne", selector, options, returnValue);
    this.executeInDebugMode((callstack) => this.emit("_debug.findOne", callstack, selector, options, returnValue));
    return returnValue;
  }
  /**
   * Performs a batch operation, deferring index rebuilds and allowing multiple
   * modifications to be made atomically. Executes any post-batch callbacks afterwards.
   * @param callback - The batch operation to execute.
   */
  batch(callback) {
    this.batchOperationInProgress = true;
    callback();
    this.batchOperationInProgress = false;
    this.rebuildAllIndices();
    this.postBatchCallbacks.forEach((callback_) => callback_());
    this.postBatchCallbacks.clear();
  }
  /**
   * Inserts a single item into the collection. Generates a unique ID if not provided.
   * @param item - The item to insert.
   * @returns The ID of the inserted item.
   * @throws {Error} If the collection is disposed or the item has an invalid ID.
   */
  insert(item) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!item)
      throw new Error("Invalid item");
    const primaryKeyGenerator = this.options.primaryKeyGenerator ?? randomId;
    const newItem = { id: primaryKeyGenerator(item), ...item };
    this.emit("validate", newItem);
    if (this.idIndex.has(serializeValue(newItem.id)))
      throw new Error("Item with same id already exists");
    this.memory().push(newItem);
    const itemIndex = this.memory().findIndex((document) => document === newItem);
    this.idIndex.set(serializeValue(newItem.id), /* @__PURE__ */ new Set([itemIndex]));
    this.rebuildIndices();
    this.emit("added", newItem);
    this.emit("insert", newItem);
    this.executeInDebugMode((callstack) => this.emit("_debug.insert", callstack, newItem));
    return newItem.id;
  }
  /**
   * Inserts multiple items into the collection. Generates unique IDs for items if not provided.
   * @param items - The items to insert.
   * @returns An array of IDs of the inserted items.
   * @throws {Error} If the collection is disposed or the items are invalid.
   */
  insertMany(items) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!items)
      throw new Error("Invalid items");
    if (items.length === 0) {
      return [];
    }
    const ids = [];
    this.batch(() => {
      items.forEach((item) => {
        ids.push(this.insert(item));
      });
    });
    return ids;
  }
  /**
   * Updates a single item in the collection that matches the given selector.
   * @param selector - The criteria to select the item to update.
   * @param modifier - The modifications to apply to the item.
   * @param [options] - Optional settings for the update operation.
   * @param [options.upsert] - If `true`, creates a new item if no item matches the selector.
   * @returns The number of items updated (0 or 1).
   * @throws {Error} If the collection is disposed or invalid arguments are provided.
   */
  updateOne(selector, modifier, options) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!selector)
      throw new Error("Invalid selector");
    if (!modifier)
      throw new Error("Invalid modifier");
    const { $setOnInsert, ...restModifier } = modifier;
    const { item, index } = this.getItemAndIndex(selector);
    if (item == null) {
      if (options == null ? void 0 : options.upsert) {
        const newItem = modify({}, {
          ...restModifier,
          $set: {
            ...$setOnInsert,
            ...restModifier.$set
          }
        });
        if (newItem.id != null && this.getItemAndIndex({ id: newItem.id }).item != null) {
          throw new Error("Item with same id already exists");
        }
        this.insert(newItem);
      }
    } else {
      const modifiedItem = modify(deepClone(item), restModifier);
      if (item.id !== modifiedItem.id && this.getItemAndIndex({ id: modifiedItem.id }).item != null) {
        throw new Error("Item with same id already exists");
      }
      this.emit("validate", modifiedItem);
      this.memory().splice(index, 1, modifiedItem);
      this.rebuildIndices();
      this.emit("changed", modifiedItem, restModifier);
    }
    this.emit("updateOne", selector, modifier);
    this.executeInDebugMode((callstack) => this.emit("_debug.updateOne", callstack, selector, modifier));
    if (item == null && !(options == null ? void 0 : options.upsert))
      return 0;
    return 1;
  }
  /**
   * Updates multiple items in the collection that match the given selector.
   * @param selector - The criteria to select the items to update.
   * @param modifier - The modifications to apply to the items.
   * @param [options] - Optional settings for the update operation.
   * @param [options.upsert] - If `true`, creates new items if no items match the selector.
   * @returns The number of items updated.
   * @throws {Error} If the collection is disposed or invalid arguments are provided.
   */
  updateMany(selector, modifier, options) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!selector)
      throw new Error("Invalid selector");
    if (!modifier)
      throw new Error("Invalid modifier");
    const { $setOnInsert, ...restModifier } = modifier;
    const items = this.getItems(selector);
    if (items.length === 0 && (options == null ? void 0 : options.upsert)) {
      const newItem = modify({}, {
        ...restModifier,
        $set: {
          ...$setOnInsert,
          ...restModifier.$set
        }
      });
      if (newItem.id != null && this.getItemAndIndex({ id: newItem.id }).item != null) {
        throw new Error("Item with same id already exists");
      }
      this.insert(newItem);
    }
    const changes = items.map((item) => {
      const { index } = this.getItemAndIndex({ id: item.id });
      if (index === -1)
        throw new Error(`Cannot resolve index for item with id '${item.id}'`);
      const modifiedItem = modify(deepClone(item), restModifier);
      if (item.id !== modifiedItem.id && this.getItemAndIndex({ id: modifiedItem.id }).item != null) {
        throw new Error(`Item with same id '${modifiedItem.id}' already exists`);
      }
      this.emit("validate", modifiedItem);
      return {
        item: modifiedItem,
        index
      };
    });
    changes.forEach(({ item, index }) => {
      this.memory().splice(index, 1, item);
    });
    this.rebuildIndices();
    changes.forEach(({ item }) => {
      this.emit("changed", item, restModifier);
    });
    this.emit("updateMany", selector, modifier);
    this.executeInDebugMode((callstack) => this.emit("_debug.updateMany", callstack, selector, modifier));
    return changes.length === 0 && (options == null ? void 0 : options.upsert) ? 1 : changes.length;
  }
  /**
   * Replaces a single item in the collection that matches the given selector.
   * @param selector - The criteria to select the item to replace.
   * @param replacement - The item to replace the selected item with.
   * @param [options] - Optional settings for the replace operation.
   * @param [options.upsert] - If `true`, creates a new item if no item matches the selector.
   * @returns The number of items replaced (0 or 1).
   * @throws {Error} If the collection is disposed or invalid arguments are provided.
   */
  replaceOne(selector, replacement, options) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!selector)
      throw new Error("Invalid selector");
    const { item, index } = this.getItemAndIndex(selector);
    if (item == null) {
      if (options == null ? void 0 : options.upsert) {
        if (replacement.id != null && this.getItemAndIndex({ id: replacement.id }).item != null) {
          throw new Error("Item with same id already exists");
        }
        this.insert(replacement);
      }
    } else {
      if (item.id !== replacement.id && this.getItemAndIndex({ id: replacement.id }).item != null) {
        throw new Error("Item with same id already exists");
      }
      const modifiedItem = { id: item.id, ...replacement };
      this.emit("validate", modifiedItem);
      this.memory().splice(index, 1, modifiedItem);
      this.rebuildIndices();
      this.emit("changed", modifiedItem, replacement);
    }
    this.emit("replaceOne", selector, replacement);
    this.executeInDebugMode((callstack) => this.emit("_debug.replaceOne", callstack, selector, replacement));
    if (item == null && !(options == null ? void 0 : options.upsert))
      return 0;
    return 1;
  }
  /**
   * Removes a single item from the collection that matches the given selector.
   * @param selector - The criteria to select the item to remove.
   * @returns The number of items removed (0 or 1).
   * @throws {Error} If the collection is disposed or invalid arguments are provided.
   */
  removeOne(selector) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!selector)
      throw new Error("Invalid selector");
    const { item, index } = this.getItemAndIndex(selector);
    if (item != null) {
      this.memory().splice(index, 1);
      this.deleteFromIdIndex(item.id, index);
      this.rebuildIndices();
      this.emit("removed", item);
    }
    this.emit("removeOne", selector);
    this.executeInDebugMode((callstack) => this.emit("_debug.removeOne", callstack, selector));
    return item == null ? 0 : 1;
  }
  /**
   * Removes multiple items from the collection that match the given selector.
   * @param selector - The criteria to select the items to remove.
   * @returns The number of items removed.
   * @throws {Error} If the collection is disposed or invalid arguments are provided.
   */
  removeMany(selector) {
    if (this.isDisposed)
      throw new Error("Collection is disposed");
    if (!selector)
      throw new Error("Invalid selector");
    const items = this.getItems(selector);
    items.forEach((item) => {
      const index = this.memory().findIndex((document) => document === item);
      if (index === -1)
        throw new Error("Cannot resolve index for item");
      this.memory().splice(index, 1);
      this.deleteFromIdIndex(item.id, index);
      this.rebuildIndices();
    });
    items.forEach((item) => {
      this.emit("removed", item);
    });
    this.emit("removeMany", selector);
    this.executeInDebugMode((callstack) => this.emit("_debug.removeMany", callstack, selector));
    return items.length;
  }
};
__publicField4(_Collection, "collections", []);
__publicField4(_Collection, "debugMode", false);
__publicField4(_Collection, "batchOperationInProgress", false);
__publicField4(_Collection, "fieldTracking", false);
__publicField4(_Collection, "onCreationCallbacks", []);
__publicField4(_Collection, "onDisposeCallbacks", []);
__publicField4(_Collection, "enableDebugMode", () => {
  _Collection.debugMode = true;
  _Collection.collections.forEach((collection) => {
    collection.setDebugMode(true);
  });
});
__publicField4(_Collection, "setFieldTracking", (enable) => {
  _Collection.fieldTracking = enable;
  _Collection.collections.forEach((collection) => {
    collection.setFieldTracking(enable);
  });
});
var Collection = _Collection;

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index8.mjs
function createPersistenceAdapter(definition) {
  return definition;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index5.mjs
function createTemporaryFallbackExecutor(firstResolvingPromiseFunction, secondResolvingPromiseFunction, options) {
  const cacheTimeout = options == null ? void 0 : options.cacheTimeout;
  let isResolved = false;
  let resolvedValue = null;
  let timeout = null;
  let secondaryPromise = null;
  return (...args) => {
    if (secondaryPromise == null) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      secondaryPromise = secondResolvingPromiseFunction(...args).then((result) => {
        {
          timeout = setTimeout(() => {
            isResolved = false;
            resolvedValue = null;
            secondaryPromise = null;
          }, cacheTimeout);
        }
        isResolved = true;
        resolvedValue = result;
        if (options == null ? void 0 : options.onResolve)
          options.onResolve(resolvedValue);
        return result;
      });
    } else if (isResolved) {
      return secondaryPromise;
    }
    return firstResolvingPromiseFunction(...args);
  };
}
function combinePersistenceAdapters(slowAdapter, fastAdapter) {
  let handleChange = null;
  const readExecutor = createTemporaryFallbackExecutor(() => fastAdapter.load(), () => slowAdapter.load(), {
    cacheTimeout: 100,
    onResolve: (result) => {
      var _a, _b, _c;
      if (handleChange)
        void handleChange();
      void fastAdapter.save(result.items || [], {
        added: ((_a = result.changes) == null ? void 0 : _a.added) || [],
        modified: ((_b = result.changes) == null ? void 0 : _b.modified) || [],
        removed: ((_c = result.changes) == null ? void 0 : _c.removed) || []
      });
    }
  });
  return createPersistenceAdapter({
    async register(onChange) {
      handleChange = onChange;
      await Promise.all([slowAdapter.register(onChange), fastAdapter.register(onChange)]);
    },
    async load() {
      const promise = readExecutor();
      return promise;
    },
    async save(items, changes) {
      await Promise.all([
        fastAdapter.save(items, changes),
        slowAdapter.save(items, changes)
      ]);
    }
  });
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index23.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
function createReplicationAdapter(options) {
  return createPersistenceAdapter({
    async register(onChange) {
      if (!options.registerRemoteChange)
        return;
      await options.registerRemoteChange(onChange);
    },
    load: () => options.pull(),
    save: (items, changes) => {
      if (!options.push)
        throw new Error("Pushing is not configured for this collection. Try to pass a `push` function to the collection options.");
      return options.push(changes, items);
    }
  });
}
var ReplicatedCollection = class extends Collection {
  /**
   * Creates a new instance of the `ReplicatedCollection` class.
   * Sets up the replication adapter, combining it with an optional persistence adapter, and
   * initializes signals for tracking remote pull and push operations.
   * @param options - The configuration options for the replicated collection.
   * @param options.pull - A function to fetch data from the remote source.
   * @param options.push - An optional function to send changes and items to the remote source.
   * @param options.registerRemoteChange - An optional function to register a listener for remote changes.
   * @param options.persistence - An optional persistence adapter to combine with replication.
   * @param options.reactivity - A reactivity adapter for observing changes in the collection.
   * @param options.transform - A transformation function to apply to items when retrieving them.
   * @param options.indices - An array of index providers for optimized querying.
   * @param options.enableDebugMode - A boolean to enable or disable debug mode.
   */
  constructor(options) {
    const replicationAdapter = createReplicationAdapter({
      registerRemoteChange: options.registerRemoteChange,
      pull: async () => {
        this.isPullingRemoteSignal.set(true);
        try {
          return await options.pull();
        } finally {
          this.isPullingRemoteSignal.set(false);
        }
      },
      push: options.push ? async (changes, items) => {
        if (!options.push)
          throw new Error("Pushing is not configured for this collection. Try to pass a `push` function to the collection options.");
        this.isPushingRemoteSignal.set(true);
        try {
          await options.push(changes, items);
        } finally {
          this.isPushingRemoteSignal.set(false);
        }
      } : void 0
    });
    const persistenceAdapter = (options == null ? void 0 : options.persistence) ? combinePersistenceAdapters(replicationAdapter, options.persistence) : replicationAdapter;
    super({
      ...options,
      persistence: persistenceAdapter
    });
    __publicField5(this, "isPullingRemoteSignal");
    __publicField5(this, "isPushingRemoteSignal");
    this.isPullingRemoteSignal = createSignal(options.reactivity, false);
    this.isPushingRemoteSignal = createSignal(options.reactivity, false);
  }
  /**
   * Checks whether the collection is currently performing any loading operation,
   * including pulling or pushing data from/to the remote source, or standard
   * persistence adapter operations.
   * ⚡️ this function is reactive!
   * @returns A boolean indicating if the collection is currently loading or synchronizing.
   */
  isLoading() {
    const isPullingRemote = this.isPullingRemoteSignal.get();
    const isPushingRemote = this.isPushingRemoteSignal.get();
    const isLoading = super.isLoading();
    return isPullingRemote || isPushingRemote || isLoading;
  }
};

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index4.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
var AutoFetchCollection = class extends ReplicatedCollection {
  /**
   * @param options {Object} - Options for the collection.
   * @param options.fetchQueryItems {Function} - A function that fetches items from the server. It takes the selector as an argument and returns a promise that resolves to an object with an `items` property.
   * @param options.purgeDelay {Number} - The delay in milliseconds before purging an item from the cache.
   */
  constructor(options) {
    let triggerRemoteChange;
    super({
      ...options,
      pull: () => Promise.resolve({
        items: [...this.itemsCache.values()].reduce((memo, items) => {
          const newItems = [...memo];
          items.forEach((item) => {
            const index = newItems.findIndex((i) => i.id === item.id);
            if (index === -1) {
              newItems.push(item);
              return;
            }
            newItems[index] = this.mergeItems(newItems[index], item);
          });
          return newItems;
        }, [])
      }),
      registerRemoteChange: async (onChange) => {
        triggerRemoteChange = onChange;
      }
    });
    __publicField6(this, "activeObservers", /* @__PURE__ */ new Map());
    __publicField6(this, "observerTimeouts", /* @__PURE__ */ new Map());
    __publicField6(this, "purgeDelay");
    __publicField6(this, "idQueryCache", /* @__PURE__ */ new Map());
    __publicField6(this, "itemsCache", /* @__PURE__ */ new Map());
    __publicField6(this, "fetchQueryItems");
    __publicField6(this, "triggerReload", null);
    __publicField6(this, "reactivityAdapter", null);
    __publicField6(this, "loadingSignals", /* @__PURE__ */ new Map());
    __publicField6(this, "isFetchingSignal");
    __publicField6(this, "mergeItems");
    this.mergeItems = options.mergeItems ?? ((itemA, itemB) => ({ ...itemA, ...itemB }));
    this.purgeDelay = options.purgeDelay ?? 1e4;
    this.isFetchingSignal = createSignal(options.reactivity, false);
    if (!triggerRemoteChange)
      throw new Error("No triggerRemoteChange method found. Looks like your persistence adapter was not registered");
    this.triggerReload = triggerRemoteChange;
    this.reactivityAdapter = options.reactivity ?? null;
    this.fetchQueryItems = options.fetchQueryItems;
    this.on("observer.created", (selector) => this.handleObserverCreation(selector ?? {}));
    this.on("observer.disposed", (selector) => setTimeout(() => this.handleObserverDisposal(selector ?? {}), 100));
    if (options.registerRemoteChange) {
      void options.registerRemoteChange(() => this.forceRefetch());
    }
  }
  /**
   * Registers a query manually that items should be fetched for it
   * @param selector {Object} Selector of the query
   */
  registerQuery(selector) {
    this.handleObserverCreation(selector);
  }
  /**
   * Unregisters a query manually that items are not fetched anymore for it
   * @param selector {Object} Selector of the query
   */
  unregisterQuery(selector) {
    this.handleObserverDisposal(selector);
  }
  getKeyForSelector(selector) {
    return JSON.stringify(selector);
  }
  async forceRefetch() {
    return Promise.all([...this.activeObservers.values()].map(({ selector }) => this.fetchSelector(selector))).then(() => {
    });
  }
  fetchSelector(selector) {
    this.isFetchingSignal.set(true);
    return this.fetchQueryItems(selector).then((response) => {
      if (!response.items)
        throw new Error("AutoFetchCollection currently only works with a full item response");
      this.itemsCache.set(this.getKeyForSelector(selector), response.items);
      response.items.forEach((item) => {
        const queries = this.idQueryCache.get(item.id) ?? [];
        queries.push(selector);
        this.idQueryCache.set(item.id, queries);
      });
      this.setLoading(selector, true);
      this.once("persistence.received", () => {
        this.setLoading(selector, false);
      });
      if (!this.triggerReload)
        throw new Error("No triggerReload method found. Looks like your persistence adapter was not registered");
      void this.triggerReload();
    }).catch((error) => {
      this.emit("persistence.error", error);
    }).finally(() => {
      this.isFetchingSignal.set(false);
    });
  }
  handleObserverCreation(selector) {
    var _a;
    const activeObservers = ((_a = this.activeObservers.get(this.getKeyForSelector(selector))) == null ? void 0 : _a.count) ?? 0;
    this.activeObservers.set(this.getKeyForSelector(selector), {
      selector,
      count: activeObservers + 1
    });
    const timeout = this.observerTimeouts.get(this.getKeyForSelector(selector));
    if (timeout)
      clearTimeout(timeout);
    if (activeObservers === 0)
      void this.fetchSelector(selector);
  }
  handleObserverDisposal(selector) {
    var _a;
    const currentObservers = ((_a = this.activeObservers.get(this.getKeyForSelector(selector))) == null ? void 0 : _a.count) ?? 0;
    const activeObservers = currentObservers - 1;
    if (activeObservers > 0) {
      this.activeObservers.set(this.getKeyForSelector(selector), {
        selector,
        count: activeObservers
      });
      return;
    }
    const timeout = this.observerTimeouts.get(this.getKeyForSelector(selector));
    if (timeout)
      clearTimeout(timeout);
    const removeObserver = () => {
      this.activeObservers.delete(this.getKeyForSelector(selector));
      this.itemsCache.delete(this.getKeyForSelector(selector));
      if (!this.triggerReload)
        throw new Error("No triggerReload method found. Looks like your persistence adapter was not registered");
      void this.triggerReload();
    };
    if (this.purgeDelay === 0) {
      removeObserver();
      return;
    }
    this.observerTimeouts.set(this.getKeyForSelector(selector), setTimeout(removeObserver, this.purgeDelay));
  }
  ensureSignal(selector) {
    if (!this.reactivityAdapter)
      throw new Error("No reactivity adapter found");
    if (!this.loadingSignals.has(this.getKeyForSelector(selector))) {
      this.loadingSignals.set(this.getKeyForSelector(selector), createSignal(this.reactivityAdapter, false));
    }
    return this.loadingSignals.get(this.getKeyForSelector(selector));
  }
  setLoading(selector, value) {
    const signal = this.ensureSignal(selector);
    signal.set(value);
  }
  /**
   * Indicates wether a query is currently been loaded
   * ⚡️ this function is reactive!
   * @param selector {Object} Selector of the query
   * @returns The loading state
   */
  isLoading(selector) {
    const isPushing = this.isPushing();
    if (!selector) {
      return this.isFetchingSignal.get() || isPushing;
    }
    const signal = this.ensureSignal(selector);
    return signal.get() || isPushing;
  }
};

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index7.mjs
function createMemoryAdapter(definition) {
  return definition;
}

// node_modules/.pnpm/@signaldb+core@1.6.0/node_modules/@signaldb/core/dist/index9.mjs
function createReactivityAdapter(definition) {
  return definition;
}

export {
  isEqual,
  Cursor,
  EventEmitter,
  modify,
  randomId,
  createIndexProvider,
  createIndex,
  Collection,
  createPersistenceAdapter,
  combinePersistenceAdapters,
  AutoFetchCollection,
  createMemoryAdapter,
  createReactivityAdapter
};
/*! Bundled license information:

@signaldb/core/dist/index19.mjs:
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-AIGFJJZW.js.map
