This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  components/
    character_cards/
      CharacterAvatar.vue
      Index.vue
      ModalImport.vue
      Translate.vue
    chat_screen/
      ChatScreen.vue
      EditMessageModal.vue
      ExtractorCharacterModal.vue
      MessageButtons.vue
    common/
      LLMProviderSelect.vue
      LoadingScreen.vue
      SaveButton.vue
    llm_models/
      LLMIndex.vue
      LLMOptionsModal.vue
      Modal.vue
    profile/
      ProfileList.vue
    DeleteConfirm.vue
    MainLayout.vue
    NavConfig.vue
    PresetConfig.vue
  composables/
    useDeleteConfirm.ts
  db/
    index.ts
    monkey.ts
  newDb/
    Character.ts
    index.ts
  stores/
    app.ts
    dialogue.ts
    modal.ts
    resources.ts
    screen.ts
  types/
    character.d.ts
  utils/
    character-parser.ts
    common.ts
    gm-helper.ts
    llm.ts
    msg-process.ts
    prompt-utils.ts
    resource-to-blob-url.ts
    response-parser.ts
  App.vue
  constants.ts
  i18n.ts
  main.ts
  style.css
  tailwind.css
  TESTING-GUIDE.md
  vite-env.d.ts
.gitignore
components.d.ts
grok3-suggestion.md
LICENSE
package.json
preset-narratium.md
README.md
repomix-output-Narratium-Narratium.ai.xml
signaldb-create-persistent-adapter.md
test-streaming.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/character_cards/CharacterAvatar.vue">
<template>
  <div 
    class="relative overflow-hidden"
    :class="{ 'rounded-full': isCircle }"
  >
    <img 
      :src="imageUrl" 
      alt="Avatar"
      class="w-full h-full object-cover"
    />
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, watch, onBeforeUnmount } from 'vue';
import { APP_LOGO } from '@/constants';
export default defineComponent({
  name: 'CharacterAvatar',
  props: {
    src: {
      type: File,
      required: false,
      default: null,
    },
    isCircle: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const imageUrl = ref<string>(APP_LOGO);

    const updateImageUrl = (file: File | null) => {
      // Revoke the old object URL if it's a blob URL
      if (imageUrl.value && imageUrl.value.startsWith('blob:')) {
        URL.revokeObjectURL(imageUrl.value);
      }

      if (file instanceof File) {
        imageUrl.value = URL.createObjectURL(file);
      } else {
        imageUrl.value = APP_LOGO;
      }
    };

    watch(
      () => props.src,
      (newFile) => {
        updateImageUrl(newFile);
      },
      { immediate: true }
    );

    onBeforeUnmount(() => {
      if (imageUrl.value && imageUrl.value.startsWith('blob:')) {
        URL.revokeObjectURL(imageUrl.value);
      }
    });

    return {
      imageUrl
    };
  }
});
</script>
</file>

<file path="src/components/character_cards/Index.vue">
<template>
  <div class="space-y-6">
    <!-- Header -->
    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
      <div>
        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">
          Characters
        </h1>
        <p class="text-gray-600 dark:text-gray-400">
          Manage your roleplay characters
        </p>
      </div>
      <div class="flex gap-2">
        <Button icon="pi pi-file-arrow-up" @click="useModal.openModal(MODALS.CHARACTER_IMPORT)" severity="info"
          size="small" label="Import Character" />
      </div>
    </div>
    <!--Body-->
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
      <Card v-for="characterCard in characterCards" :key="characterCard.id" class="w-full">
        <template #header>
          <CharacterAvatar :src="characterCard.getImageFile()" class="w-full" />
        </template>
        <template #title>
          {{ (characterCard.data as any)?.name || 'Unknown' }}
        </template>
        <template #subtitle>
          <div class="flex items-center gap-1 text-yellow-500">
            <i class="pi pi-sparkles"></i>
            <span>{{ textTruncate((characterCard.data as any)?.personality || (characterCard.data as any)?.firstMes ||
              characterCard.getGreeting() || '', 100, true) }}</span>
          </div>
        </template>
        <template #footer>
          <div class="flex gap-3 mt-1 justify-end">
            <Button icon="pi pi-comment" severity="secondary" outlined rounded aria-label="Chat" @click="handleToChat(characterCard.id)"/>
            <Button icon="pi pi-language" severity="secondary" outlined rounded
              @click="handleCharacterEdit(characterCard.id)" aria-label="Edit" />
            <Button icon="pi pi-arrow-circle-down" severity="success" rounded
              @click="handleCharacterExport(characterCard.id)" aria-label="Export" />
            <Button icon="pi pi-trash" severity="danger" rounded @click="handleDelete(characterCard)"
              aria-label="Delete" />
          </div>
        </template>
      </Card>
    </div>

    <CharacterImport @character-imported="handleCharacterImported" />
  </div>
</template>

<script setup lang="ts">
import Button from 'primevue/button';
import { useScreenStore } from '@/stores/screen';
import { useModalStore } from '@/stores/modal';
import { MODALS, SCREENS } from '@/constants';
import CharacterImport from '@/components/character_cards/ModalImport.vue';
import CharacterAvatar from '@/components/character_cards/CharacterAvatar.vue';
import Card from 'primevue/card';
import { ref, watchEffect } from 'vue';
import { textTruncate } from '@/utils/common';
import { writeCharacterToPng } from '@/utils/character-parser';
import { useDeleteConfirm } from '@/composables/useDeleteConfirm'
import { Character } from '@/newDb/Character';
import { db, CharacterCard, Dialogue, UserProfile } from '@/db';
import { useDialogueStore } from '@/stores/dialogue';
import dayjs from 'dayjs';
import { adaptText } from '@/utils/msg-process';
const useScreen = useScreenStore();
const useModal = useModalStore();
const dialogueStore = useDialogueStore();

const { confirmDelete } = useDeleteConfirm();

const characterCards = ref<CharacterCard[]>([]);

async function handleDelete(card: CharacterCard) {
  confirmDelete(card, {
    message: `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a nh√¢n v·∫≠t "${(card.data as any)?.name}"?`,
    header: 'X√≥a nh√¢n v·∫≠t',
    onConfirm: async () => {
      db.CharacterCards.removeOne({ id: card.id });
      db.Storage.removeOne({ id: card.id });
      db.Dialogues.removeOne({ id: card.id });
      db.DialogueMessages.removeMany({ dialogueId: card.id });
      // await loadCharacterCards();
    }
  })
}

// X·ª≠ l√Ω d·ªØ li·ªáu nh√¢n v·∫≠t khi nh·∫≠n ƒë∆∞·ª£c t·ª´ component ModalImport
const handleCharacterImported = async (parsedData: any, imageFile: File) => {
  const newData = new Character(parsedData)
  const id = db.CharacterCards.insert({
    data: newData.data,
    isUseTranslated: false,
    createdAt: Date.now()
  })
  // console.log(id)
  db.Storage.insert({ id: id, file: imageFile, type: 'image' });
};

const handleCharacterEdit = (id: string) => {
  useScreen.setScreen(SCREENS.CHARACTER_TRANSLATE, { id })
}

const handleCharacterExport = async (id: string) => {
  const character = db.CharacterCards.findOne({ id }) as CharacterCard;
  if (character) {
    character.getData();
    const data = character.data as any;
    // console.log('export data: ', data);
    const orginalImage = character.getImageFile();
    let jsonString = JSON.stringify(data, null, 2);
    const keysNeedReplace = [
      {
        find: 'firstMessage',
        replace: 'first_mes',
      }, {
        find: 'alternateGreetings',
        replace: 'alternate_greetings',
      }, {
        find: 'messageExamples',
        replace: 'mes_example',
      }, {
        find: 'creatorNotes',
        replace: 'creator_notes',
      }, {
        find: 'worldBook',
        replace: 'character_book',
      }
    ]
    keysNeedReplace.forEach((item) => {
      jsonString = jsonString.replace(new RegExp(item.find, 'g'), item.replace);
    })
    const newImageBlob = await writeCharacterToPng(orginalImage as File, jsonString);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(newImageBlob);
    const backupAt = dayjs().format('DD-MM-YYYY HH:mm:ss').toString();
    a.download = `${data.name}-${character.isUseTranslated ? 'translated' : 'original'}-backup-${backupAt}.png`;
    a.click();
    URL.revokeObjectURL(a.href);
  }
}

const handleToChat = (characterId: string) => {
  // // 1. Ki·ªÉm tra xem cu·ªôc h·ªôi tho·∫°i (Dialogue) ƒë√£ t·ªìn t·∫°i ch∆∞a
  // const existingDialogue = db.Dialogues.findOne({ id: characterId }) as Dialogue | null;
  
  // // 2. N·∫øu ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªôt b·∫£n ghi Dialogue m·ªõi
  // if (!existingDialogue) {
  //   console.log(`No dialogue found for character ${characterId}. Creating a new one.`);

  //   // L·∫•y model LLM m·∫∑c ƒë·ªãnh ƒë·ªÉ thi·∫øt l·∫≠p cho cu·ªôc h·ªôi tho·∫°i m·ªõi
  //   // const defaultLLMModel = db.LLMModels.findOne({ isDefault: true }) as LLMModel | null;

  //   const newDialouge = db.Dialogues.insert({
  //     id: characterId,
  //     createdAt: Date.now(),
  //     // B·∫Øt ƒë·∫ßu t·ª´ node g·ªëc, ch∆∞a c√≥ tin nh·∫Øn n√†o
  //     currentNodeId: 'root', 
  //     // Thi·∫øt l·∫≠p c√°c t√πy ch·ªçn LLM m·∫∑c ƒë·ªãnh cho cu·ªôc h·ªôi tho·∫°i n√†y
  //     llmOptions: {
  //       temperature: 0.7,
  //       maxTokens: 1000,
  //       contextWindow: 4000,
  //       // (T√πy ch·ªçn) B·∫°n c√≥ th·ªÉ l∆∞u c·∫£ modelId n·∫øu mu·ªën
  //       // modelId: defaultLLMModel?.id, 
  //     }
  //   });
  //   const characterCard = db.CharacterCards.findOne({ id: characterId }) as CharacterCard;
  //   characterCard.getData();
  //   let firstGreeting = characterCard.getGreeting() as string;
  //   firstGreeting = adaptText(firstGreeting);
  //   const newMessage = db.DialogueMessages.insert({
  //     id: crypto.randomUUID(),
  //     dialogueId: newDialouge.id,
  //     parentId: 'root',
  //     userInput: '',
  //     assistantResponse: firstGreeting,
  //     status: 'completed',
  //     createdAt: Date.now(),
  //   })
  //   console.log('newMessage: ', newMessage);
  // } else {
  //   console.log(`Found existing dialogue for character ${characterId}.`);
  // }
    dialogueStore.loadDialogue(characterId);
  // 3. Chuy·ªÉn ng∆∞·ªùi d√πng ƒë·∫øn m√†n h√¨nh chat
  // M√†n h√¨nh chat (ChatScreen.vue) s·∫Ω ch·ªãu tr√°ch nhi·ªám t·∫£i d·ªØ li·ªáu h·ªôi tho·∫°i t·ª´ DB,
  // v√† hi·ªÉn th·ªã l·ªùi ch√†o n·∫øu ƒë√≥ l√† l·∫ßn ƒë·∫ßu ti√™n (t·ª©c l√† kh√¥ng c√≥ tin nh·∫Øn n√†o kh√°c ngo√†i g·ªëc).
  useScreen.setScreen(SCREENS.CHAT, { id: characterId });
}

watchEffect((onCleanup) => {
  const cursor = db.CharacterCards.find({}, {
    sort: { createdAt: -1 },
  })
  characterCards.value = (cursor.fetch() as CharacterCard[]).map((item) => {
    item.getData();
    return item;
  })
  // const first = characterCards.value[0] as CharacterCard;
  // console.log(first.getImageFile());
  onCleanup(() => cursor.cleanup())
})

// onMounted(async () => {
//   await loadCharacterCards();
// });
</script>
</file>

<file path="src/components/character_cards/ModalImport.vue">
<template>
  <Dialog
    :visible="useModal.isModalOpen(MODALS.CHARACTER_IMPORT)"
    modal
    header="Import Character"
    :class="'character-import-dialog'"
    @update:visible="(value) => !value && useModal.closeModal()"
    :closable="true"
     :style="{ width: '50vw' }"
    :breakpoints="{ '1199px': '75vw', '575px': '90vw' }"
    @hide="cancelDialog"
  >
    <div class="file-upload-container">
      <label for="character-card-upload" class="file-upload-area">
        <div class="flex items-center justify-center flex-col">
          <i class="pi pi-cloud-upload" style="font-size: 3rem;"></i>
          <p>{{ msg1 }}</p>
          <p class="text-sm text-gray-500 mt-2">
            {{ msg2 }}
          </p>
        </div>
        <input 
          type="file" 
          id="character-card-upload" 
          accept=".png" 
          @change="onFileSelect" 
          class="hidden-input"
        />
      </label>
    </div>

    <template #footer>
      <Button
        label="Cancel"
        severity="secondary"
        @click="useModal.closeModal()"
      />
      <Button 
        label="Import" 
        @click="importOnly"
        :loading="loadingImport"
        :disabled="!selectedFile"
      />
    </template>
  </Dialog>
</template>

<script setup lang="ts">
import Dialog from 'primevue/dialog';
import Button from 'primevue/button';
import { MODALS} from '@/constants';
import { onMounted, defineEmits, ref } from 'vue';
import { parseCharacterCard } from '@/utils/character-parser';
import { useModalStore } from '@/stores/modal';
import { fileSizeHuman } from '@/utils/common';

// ƒê·ªãnh nghƒ©a c√°c s·ª± ki·ªán emit
const emit = defineEmits<{
  'character-imported': [characterData: any, imageFile: File]
}>();

const useModal = useModalStore();
const msg1 = ref('');
const msg2 = ref('');
const loadingImport = ref(false);

const cancelDialog = () => {
  // Reset messages when dialog is canceled
  // console.log('Cancel dialog');
  loadingImport.value = false;
  msg1.value = 'Drag file here or click to select';
  msg2.value = 'Only SillyTavern PNG character card files are supported';
};
// L∆∞u tr·ªØ file ƒë√£ ch·ªçn
let selectedFile: File | null = null;

const onFileSelect = async (event: Event) => {
  const input = event.target as HTMLInputElement;
  selectedFile = input.files?.[0] || null;
  if (!selectedFile) return;
  msg1.value = selectedFile.name;
  msg2.value = fileSizeHuman(selectedFile.size);
  // Hi·ªÉn th·ªã t√™n file ƒë√£ ch·ªçn n·∫øu c·∫ßn
  console.log("Selected file:", selectedFile.name);
};

// X·ª≠ l√Ω khi nh·∫•n n√∫t Import
const importOnly = async () => {
  if (!selectedFile) return;
  
  try {
    loadingImport.value = true;
    const parsedData = await parseCharacterCard(selectedFile);
    

    // Emit s·ª± ki·ªán v·ªõi d·ªØ li·ªáu character ƒë√£ parse
    emit('character-imported', parsedData, selectedFile);
    // ƒê√≥ng modal sau khi import th√†nh c√¥ng
    useModal.closeModal();
  } catch (error) {
    console.error("Error parsing character card:", error);
    // TODO: Show error message to user
  }
  finally {
    // Reset messages after import
    cancelDialog();
  }
};



// X·ª≠ l√Ω khi nh·∫•n n√∫t Import & Edit
// TODO: Implement this function when edit functionality is ready

// X·ª≠ l√Ω k√©o th·∫£ file
const setupDragAndDrop = () => {
  const dropArea = document.querySelector('.file-upload-area');
  const fileInput = document.getElementById('character-card-upload') as HTMLInputElement;
  
  if (!dropArea || !fileInput) return;
  
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, (e: Event) => {
      e.preventDefault();
      e.stopPropagation();
    }, false);
  });
  
  ['dragenter', 'dragover'].forEach(eventName => {
    dropArea.addEventListener(eventName, () => {
      dropArea.classList.add('highlight');
    }, false);
  });
  
  ['dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, () => {
      dropArea.classList.remove('highlight');
    }, false);
  });
  
  dropArea.addEventListener('drop', (e: Event) => {
    const dragEvent = e as DragEvent;
    const dt = dragEvent.dataTransfer;
    if (dt?.files.length) {
      fileInput.files = dt.files;
      const changeEvent = new Event('change', { bubbles: true });
      fileInput.dispatchEvent(changeEvent);
    }
  }, false);
};

// Thi·∫øt l·∫≠p k√©o th·∫£ sau khi component ƒë∆∞·ª£c mount
onMounted(() => {
  cancelDialog();
  setupDragAndDrop();
});
</script>

<style scoped>
.character-import-dialog {
  width: 90vw;
  max-width: 550px;
}

.file-upload-container {
  width: 100%;
  margin-bottom: 1rem;
}

.file-upload-area {
  display: block;
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
}

.file-upload-area:hover, .file-upload-area.highlight {
  border-color: #666;
  background-color: rgba(0, 0, 0, 0.05);
}

.hidden-input {
  display: none;
}

@media (max-width: 768px) {
  .character-import-dialog {
    width: 95vw;
  }
  
  .file-upload-area {
    padding: 1.5rem;
  }
}

@media (max-width: 480px) {
  .file-upload-area {
    padding: 1rem;
  }
}
</style>
</file>

<file path="src/components/character_cards/Translate.vue">
<template>
  <div class="space-y-6">
    <div class="flex items-center justify-between mb-4">
      <h1 class="text-2xl font-bold">Translate Character</h1>
      <Button
        label="Character List"
        icon="pi pi-arrow-left"
        @click="screenStore.setScreen(SCREENS.CHARACTER_LIST)"
      />
    </div>

    <Accordion :active-index="1">
      <AccordionTab header="General Info">
        <div class="card">
          <div class="flex flex-wrap items-center gap-6 p-4">
            <CharacterAvatar v-if="character.getImageFile()" :src="character.getImageFile()" :is-circle="false" class="w-32" />
            <div class="flex items-center gap-2">
              <label for="use-translated">Use Translated Data:</label>
              <ToggleSwitch id="use-translated" v-model="character.isUseTranslated" />
            </div>
            <SaveButton ref="saveButton1" @click="handleGeneralInfoSave" class="ml-auto" />
          </div>
        </div>
      </AccordionTab>
      <AccordionTab header="Translate">
        <div class="card">
          <div class="mb-4">
              <label for="field-select" class="block text-sm font-medium text-gray-700 mb-2">Select Property to Edit</label>
              <Select id="field-select" v-model="selectedField" :options="keyItems" placeholder="Select a property" class="w-full md:w-1/4" />
          </div>

          <div v-if="selectedField" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <!-- Original Data -->
              <div class="space-y-4">
                  <h2 class="text-xl font-semibold">Original</h2>
                  <Textarea v-model="originalValue" rows="10" class="w-full font-mono" />
                  <div class="flex gap-2">
                      <SaveButton ref="saveButton2" @click="handleSave('original')" />
                      <Button severity="help" label="Translate" icon="pi pi-language" @click="handleTranslate" :loading="isTranslating" :disabled="!isReadyTranslate" />
                      <LLMProviderSelect severity="warn" :button-props="{icon: 'pi pi-android'}" />
                  </div>
              </div>

              <!-- Translated Data -->
              <div class="space-y-4">
                  <h2 class="text-xl font-semibold">Translated</h2>
                  <Textarea v-model="translatedValue" rows="10" class="w-full font-mono" />
                  <div class="flex gap-2">
                      <SaveButton ref="saveButton3" @click="handleSave('translated')" />
                      <Button label="Clear" icon="pi pi-trash" severity="danger" @click="handleClear" />
                  </div>
              </div>
          </div>
        </div>
      </AccordionTab>
    </Accordion>
  </div>
</template>

<script lang="ts" setup>
import { ref, onMounted, computed, watch } from 'vue';
import Button from 'primevue/button';
import Textarea from 'primevue/textarea';
import Select from 'primevue/select';
import Accordion from 'primevue/accordion';
import AccordionTab from 'primevue/accordiontab';
import ToggleSwitch from 'primevue/toggleswitch';
import CharacterAvatar from './CharacterAvatar.vue';
import { useScreenStore } from '@/stores/screen';
import { useResourcesStore } from '@/stores/resources';
import { SCREENS } from '@/constants';
import { db, CharacterCard, LLMModel } from '@/db';
import type { CharacterCardData } from '@/types/character';
import SaveButton from '@/components/common/SaveButton.vue';
import LLMProviderSelect from '@/components/common/LLMProviderSelect.vue';
import { storeToRefs } from 'pinia';
import { sendOpenAiRequestStream, OpenAIOptions } from '@/utils/llm';

const screenStore = useScreenStore();
const resourcesStore = useResourcesStore()

const character = ref<CharacterCard>(new CharacterCard({}));
const selectedField = ref<keyof CharacterCardData | null>(null);
const isTranslating = ref(false);

const originalValue = ref('');
const translatedValue = ref('');
const {translatePrompt} = storeToRefs(resourcesStore);
const defaultLLMModel = ref<LLMModel>();
const saveButton1 = ref<InstanceType<typeof SaveButton> | null>(null);
const saveButton2 = ref<InstanceType<typeof SaveButton> | null>(null);
const saveButton3 = ref<InstanceType<typeof SaveButton> | null>(null);
const isReadyTranslate = computed(() => {
  return translatePrompt.value !== '' && (defaultLLMModel.value && defaultLLMModel.value.id !== '');
})

const keyItems = computed(() => {
  if (!character.value.data) return [];
  const keysSkip = ['tags'];
  const flattenedKeys: string[] = [];

  Object.keys(character.value.data).forEach(key => {
    if (keysSkip.includes(key)) return;

    const value = character.value.data[key as keyof CharacterCardData];

    if (Array.isArray(value)) {
      value.forEach((_, index) => {
        flattenedKeys.push(`${key}|${index}`);
      });
    } else if (value !== null && value !== undefined && value !== '') {
      flattenedKeys.push(key);
    }
  });

  return flattenedKeys;
});

watch(selectedField, (newField) => {
    if (!newField) return;

    let original: any;
    let translated: any;

    if (newField.includes('|')) {
        const [key, indexStr] = newField.split('|');
        const index = parseInt(indexStr, 10);
        original = character.value.data[key as keyof CharacterCardData]?.[index];
        translated = character.value.dataTranslated?.[key as keyof CharacterCardData]?.[index];
    } else {
        original = character.value.data[newField as keyof CharacterCardData];
        translated = character.value.dataTranslated?.[newField as keyof CharacterCardData];
    }

    originalValue.value = typeof original === 'object' ? JSON.stringify(original, null, 2) : String(original || '');
    translatedValue.value = typeof translated === 'object' ? JSON.stringify(translated, null, 2) : String(translated || '');
});

onMounted(async () => {
  const characterId = screenStore.screenPayload?.id as string;
  if (characterId) {
    const card = db.CharacterCards.findOne({id: characterId}) as CharacterCard;
    if (card) {
      character.value = card;
      if (!character.value.dataTranslated) {
        character.value.dataTranslated = {};
      }
    }
  }

  const defaultModel = db.LLMModels.findOne({isDefault: true}) as LLMModel;
  if (defaultModel) {
    defaultLLMModel.value = defaultModel;
  }
});

const handleTranslate = async () => {
  try {
    if (!selectedField.value || !defaultLLMModel.value) return;
    isTranslating.value = true;
    // await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate API call
    const options: OpenAIOptions = {
      baseURL: defaultLLMModel.value?.baseUrl as string,
      apiKey: defaultLLMModel.value?.apiKey || '',
      data: {
        model: defaultLLMModel.value?.modelName || '',
        messages: [
          {
            role: 'system',
            content: translatePrompt.value
          },
          {
            role: 'user',
            content: originalValue.value
          }
        ],
        stream: true
      }
    };
    // Replace with actual translation logic
    // translatedValue.value = `${originalValue.value} (Translated)`;
    await sendOpenAiRequestStream(options, (chunk: string) => {
      // console.log(chunk);
      translatedValue.value += chunk;
    });
    isTranslating.value = false;
  } catch (error) {
    console.error('Translation error:', error);
  } finally {
    isTranslating.value = false;
  }
};

const handleSave = async (type: 'original' | 'translated') => {
    if (!selectedField.value) return;

    const field = selectedField.value;
    const characterId = character.value.id;
    let valueToSave: any = type === 'original' ? originalValue.value : translatedValue.value;

    try {
        // Remove markdown code block if present
        let cleanValue = valueToSave.trim();
        if (cleanValue.startsWith('```json\n')) {
            cleanValue = cleanValue.substring('```json\n'.length);
            if (cleanValue.endsWith('```')) {
                cleanValue = cleanValue.substring(0, cleanValue.length - 3);
            }
        }
        // Try to parse if it's a JSON string
        valueToSave = JSON.parse(cleanValue);
    } catch (e) {
        // Not a valid JSON, save as string
        console.warn('Failed to parse JSON:', e);
    }

    const updateNestedValue = (obj: any, path: string, value: any) => {
        if (path.includes('|')) {
            const [key, indexStr] = path.split('|');
            const index = parseInt(indexStr, 10);
            if (!obj[key]) obj[key] = [];
            obj[key][index] = value;
        } else {
            obj[path] = value;
        }
    };

    if (type === 'original') {
        const updatedData = JSON.parse(JSON.stringify(character.value.data));
        updateNestedValue(updatedData, field, valueToSave);

        await db.CharacterCards.updateOne(
            { id: characterId },
            { $set: { data: updatedData } }
        );
        
        updateNestedValue(character.value.data, field, valueToSave);
        saveButton2.value?.showSuccess();
    } else {
        const updatedTranslated = JSON.parse(JSON.stringify(character.value.dataTranslated || {}));
        updateNestedValue(updatedTranslated, field, valueToSave);

        db.CharacterCards.updateOne(
        { id: characterId },
        { $set: { dataTranslated: updatedTranslated } }
      );
        
        if (!character.value.dataTranslated) character.value.dataTranslated = {};
        updateNestedValue(character.value.dataTranslated, field, valueToSave);
        saveButton3.value?.showSuccess();
    }
};

const handleGeneralInfoSave = async () => {
    // Extract primitive values to avoid DataCloneError
    const characterId = character.value.id;
    const isUseTranslated = Boolean(character.value.isUseTranslated);

    await db.CharacterCards.updateOne(
      { id: characterId },
      { $set: { isUseTranslated } }
    );
    
    saveButton1.value?.showSuccess();
};

const handleClear = () => {
    translatedValue.value = '';
};
</script>

<style scoped>
@reference "@/style.css";
.card {
    @apply p-6 bg-white rounded-lg shadow;
}
</style>
</file>

<file path="src/components/chat_screen/ChatScreen.vue">
<template>
    <div class="flex flex-col h-screen bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 font-sans w-full">
        <!-- Header -->
        <header
            class="flex-shrink-0 p-2 sm:p-4 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm sticky top-0 z-10">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                <div class="flex items-center self-start sm:self-center space-x-3 w-full">
                    <CharacterAvatar v-if="imageFile" :src="imageFile" :is-circle="true" class="w-12 h-12" />
                    <div>
                        <h1 class="text-xl font-bold text-gray-900 dark:text-white">{{ currentCharacter?.data?.name }}
                        </h1>
                        <div class="flex items-center justify-between">
                            <div class="flex justify-between w-full">
                                <div class="flex items-center space-x-1">
                                    <LLMOptionsModal v-if="dialogueStore.currentDialogue?.llmOptions"
                                        :init="dialogueStore.currentLLMOptions[dialogueStore.currentDialogue?.id]"
                                        @save="handleChangeLLMOptions" />
                                </div>

                                <div class="flex items-center space-x-1">
                                    <Button v-tooltip.bottom="'X√≥a cu·ªôc tr√≤ chuy·ªán'" icon="pi pi-trash"
                                        severity="danger" text rounded size="small" @click="handleRemoveDialogue" />
                                </div>
                                <div class="flex items-center space-x-1">
                                    <Button v-tooltip.bottom="'Tr√≠ch xu·∫•t nh√¢n v·∫≠t'" icon="pi pi-users"
                                        severity="help" text rounded size="small" @click="modalStore.openModal(MODALS.EXTRACTOR_CHARACTER)" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </header>

        <!-- Chat/Story Area -->
        <main ref="chatContainer" class="flex-1 p-4 sm:p-6 overflow-y-auto">
            <div class="prose prose-invert max-w-none">
                <!-- V·∫•n ƒë·ªÅ 1: Lu√¥n hi·ªÉn th·ªã l·ªùi ch√†o ƒë·∫ßu ti√™n
                <div v-if="firstGreeting" class="flex justify-start mb-4">
                    <div
                        class="p-3 sm:p-4 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-900 dark:text-gray-200 max-w-lg shadow-md">
                        <p v-html="firstGreeting" class="whitespace-pre-wrap"></p>
                    </div>
                </div> -->

                <!-- L·∫∑p qua c√°c node trong nh√°nh hi·ªán t·∫°i -->
                <div v-for="node in currentMessagesForDisplay" :key="node.id" class="space-y-4 mb-4">
                    <!-- User message bubble -->
                    <div v-if="node.userInput" class="flex justify-end">
                        <div
                            class="p-3 sm:p-4 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 max-w-lg shadow-md message-bubble">
                            <p class="whitespace-pre-wrap" v-html="formatMessage(node.userInput)"></p>
                            <MessageButtons :role="'user'" :messageId="node.id"
                                :latestMessageId="dialogueStore.currentDialogue?.currentNodeId" :status="node.status"
                                @button-click="handleMessageButtonClick" />
                        </div>
                    </div>

                    <!-- Assistant message bubble -->
                    <div v-if="node.assistantResponse" class="flex justify-start">
                        <div
                            class="p-3 sm:p-4 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 max-w-lg shadow-md message-bubble">
                            <p v-html="formatMessage(node.assistantResponse)" class="whitespace-pre-wrap"></p>
                            <MessageButtons :role="'assistant'" :messageId="node.id"
                                :latestMessageId="dialogueStore.currentDialogue?.currentNodeId" :status="node.status"
                                @button-click="handleMessageButtonClick" />
                        </div>
                    </div>
                </div>



                <div v-if="isSending">
                    <!-- V·∫•n ƒë·ªÅ 2: Hi·ªÉn th·ªã l·∫°i userInput khi ƒëang regenerate -->
                    <!-- <div v-if="regeneratingInput" class="flex justify-end group relative mb-4">
                        <div class="p-3 sm:p-4 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 max-w-lg shadow-md message-bubble">
                            <p class="whitespace-pre-wrap">{{ regeneratingInput }}</p>
                        </div>
                    </div> -->
                    <!-- Hi·ªÉn th·ªã ph·∫£n h·ªìi ƒëang stream c·ªßa LLM -->
                    <div class="flex justify-start">
                        <div
                            class="p-3 sm:p-4 rounded-lg mb-4 max-w-lg bg-gray-200 dark:bg-gray-700 text-gray-900 dark:text-gray-200 shadow-md">
                            <!-- Hi·ªáu ·ª©ng loading -->

                            <div v-if="!llmResponse" class="flex items-center space-x-2">
                                <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse"></div>
                                <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse"
                                    style="animation-delay: 0.2s;">
                                </div>
                                <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse"
                                    style="animation-delay: 0.4s;">
                                </div>
                            </div>
                            <p v-else v-html="formatMessage(llmResponse)" class="whitespace-pre-wrap"></p>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer
            class="flex-shrink-0 p-2 sm:p-4 border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 sticky bottom-0">
            <div class="flex items-center space-x-2 sm:space-x-4">
                <Textarea v-model="userInput" placeholder="Type a message..." autoResize rows="1"
                    class="flex-1 bg-gray-100 dark:bg-gray-800 border-gray-300 dark:border-gray-600 rounded-md p-2 focus:ring-purple-500 focus:border-purple-500"
                    @keydown.enter.exact.prevent="handleSendMessage" />
                <SplitButton :disabled="isSending || suggestedPromptItems.length <= 0 && !userInput.trim()"
                    @click="handleSendMessage" v-tooltip.top="'Send'" icon="pi pi-send" :loading="isSending"
                    :model="suggestedPromptItems" />
            </div>
            <div class="flex items-center justify-center space-x-2 mt-4">
                <SelectButton v-model="selectedMoreMode" :options="moreModeItems" optionLabel="value" dataKey="value"
                    aria-labelledby="H∆∞·ªõng d·∫´n ph·∫£n h·ªìi" size="small">
                    <template #option="slotProps">
                        <i :class="slotProps.option.icon"></i>
                    </template>
                </SelectButton>
            </div>
        </footer>
        <EditMessageModal @save-message="handleEditMessageModal" />
        <ExtractorCharacterModal 
            :characterId="currentCharacter?.id || ''"
        />
    </div>
</template>

<script setup lang="ts">
import { ref, watch, onMounted, computed, nextTick } from 'vue';
import { storeToRefs } from 'pinia';
import Button from 'primevue/button';
import Textarea from 'primevue/textarea';
import CharacterAvatar from '@/components/character_cards/CharacterAvatar.vue';
import MessageButtons from './MessageButtons.vue';
import EditMessageModal from './EditMessageModal.vue';
import ExtractorCharacterModal from './ExtractorCharacterModal.vue';
import { useScreenStore } from '@/stores/screen';
import { useResourcesStore } from '@/stores/resources';
import { useDialogueStore } from '@/stores/dialogue';
import { useModalStore } from '@/stores/modal';
import { CharacterCard, db, LLMModel, UserProfile } from '@/db';
import { formatMessageContent } from '@/utils/msg-process';
import { buildFinalPrompt } from '@/utils/prompt-utils';
import { OpenAIOptions, sendOpenAiRequestStream } from '@/utils/llm';
import { SCREENS, MODALS } from '@/constants';
import { useDeleteConfirm } from '@/composables/useDeleteConfirm';
import LLMOptionsModal from '@/components/llm_models/LLMOptionsModal.vue';
import { parseLLMResponse } from '@/utils/response-parser';

const screenStore = useScreenStore();
const resourcesStore = useResourcesStore();
const dialogueStore = useDialogueStore();
const modalStore = useModalStore();

const { screenPayload } = storeToRefs(screenStore);
const { currentMessagesForDisplay, chatHistoryForPrompt } = storeToRefs(dialogueStore);

const currentCharacter = ref<CharacterCard | null>(null);
const currentUser = ref<UserProfile | null>(null);
const currentLLMModel = ref<LLMModel | null>(null);
const selectedMoreMode = ref<{ icon: string, value: string }>();
const moreModeItems = ref([
    { icon: 'pi pi-arrow-right', value: 'H√£y ph√°t tri·ªÉn c·ªët truy·ªán ti·∫øp theo, l√†m cho c√¢u chuy·ªán th√∫ v·ªã v√† h·∫•p d·∫´n h∆°n' },
    { icon: 'pi pi-book', value: 'G√≥c nh√¨n Ti·ªÉu thuy·∫øt' },
    { icon: 'pi pi-user-plus', value: 'G√≥c nh√¨n Nh√¢n v·∫≠t ch√≠nh' },
    { icon: 'pi pi-video', value: 'Vui l√≤ng th√™m m√¥ t·∫£ c·∫£nh v·∫≠t v√† chi ti·∫øt m√¥i tr∆∞·ªùng ƒë·ªÉ tƒÉng c∆∞·ªùng kh√¥ng kh√≠ c√¢u chuy·ªán.' },
]);
// const suggestedPrompts = ref<string[]>([]); // Th√™m ref ƒë·ªÉ l∆∞u g·ª£i √Ω

const suggestedPromptItems = computed(() => {
    const suggestedPrompts = dialogueStore.suggestedPrompts[currentCharacter.value?.id || ''];
    return suggestedPrompts ? suggestedPrompts.map((prompt, index) => ({
        label: prompt,
        command: () => {
            userInput.value = prompt;
            handleSendMessage();
        }
    })) : [];
});

const userInput = ref('');
const llmResponse = ref('');
const isSending = ref(false);
const imageFile = ref<File | null>(null);
const chatContainer = ref<HTMLElement | null>(null);
const firstGreeting = ref<string | null>(null);
const { confirmDelete } = useDeleteConfirm();
const regeneratingInput = ref<string | null>(null);

const formatMessage = (content: string): string => formatMessageContent(content);

const scrollToBottom = () => {
    nextTick(() => {
        if (chatContainer.value) {
            chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
        }
    });
};

const handleExtractorCharacterModal = (extractorName: string) => {
    if(extractorName.length == 0) return;
    // thay th·∫ø {{character_name_to_extract}} th√†nh extractorName
    
}

const handleChangeLLMOptions = (llmOptions: any) => {
    if (!currentCharacter.value) return;
    dialogueStore.updateLLMOptions(currentCharacter.value.id, llmOptions);
}

const handleRemoveDialogue = () => {
    if (!currentCharacter.value) return;
    const info = {
        id: currentCharacter.value.id,
        name: currentCharacter.value.data?.name || 'Unknown',
    };
    confirmDelete(info, {
        message: `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô cu·ªôc tr√≤ chuy·ªán v·ªõi "${info.name}" kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`,
        header: 'X√≥a cu·ªôc tr√≤ chuy·ªán',
        onConfirm: (info) => {
            db.DialogueMessages.removeMany({ dialogueId: info.id });
            db.Dialogues.removeOne({ id: info.id });
            dialogueStore.suggestedPrompts[info.id] = [];
            // dialogueStore.loadDialogue(info.id); // T·∫£i l·∫°i ƒë·ªÉ reset state
            screenStore.setScreen(SCREENS.CHARACTER_LIST);
        }
    });
};

const sendRequestToLLM = async (promptMessage: string) => {
    try {
        currentLLMModel.value = db.LLMModels.findOne({ isDefault: true }) as LLMModel | null;
        if (!currentLLMModel.value || !currentCharacter.value) return '';
        const llmOptions = dialogueStore.currentLLMOptions[currentCharacter.value.id];
        const { systemPrompt, userPrompt } = buildFinalPrompt(
            currentCharacter.value,
            chatHistoryForPrompt.value as string,
            promptMessage,
            { name: currentUser.value?.name || 'Anonymous' },
            {
                multiModePrompt: resourcesStore.multiModePrompt,
                multiModeChainOfThoughtPrompt: resourcesStore.multiModeChainOfThoughtPrompt,
                outputStructureSoftGuidePrompt: resourcesStore.outputStructureSoftGuidePrompt,
                outputFormatPrompt: resourcesStore.outputFormatPrompt,
            },
            selectedMoreMode.value?.value,
            llmOptions?.responseLength
        );

        isSending.value = true;
        llmResponse.value = '';
        regeneratingInput.value = promptMessage;
        // console.info('Sending request to LLM with System Prompt \n:', systemPrompt);
        console.info('Sending request to LLM with User Prompt \n:', userPrompt);

        const options: OpenAIOptions = {
            baseURL: currentLLMModel.value.baseUrl,
            apiKey: currentLLMModel.value.apiKey,
            data: {
                model: currentLLMModel.value.modelName,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                stream: true,
                temperature: llmOptions?.temperature || 0.8,
                top_p: llmOptions?.top_p || 0.9,
            }
        };

        await sendOpenAiRequestStream(options, (chunk: string) => {
            llmResponse.value += chunk;
            scrollToBottom();
        });

        const finalResponse = llmResponse.value;

        return finalResponse;
    } catch (error) {

    } finally {
        regeneratingInput.value = null;
        llmResponse.value = '';
        isSending.value = false;
    }
}

// Th√™m helper function n√†y v√†o script setup
const handleAIResponse = (aiResponseRaw: string, nodeId: string) => {
    if (!aiResponseRaw) {
        dialogueStore.markAsFailed(nodeId);
        return;
    }

    const parsed = parseLLMResponse(aiResponseRaw);
    console.info('AI response:', parsed);

    // // C·∫≠p nh·∫≠t UI v·ªõi c√°c g·ª£i √Ω m·ªõi
    // suggestedPrompts.value = parsed.nextPrompts;
    // C·∫≠p nh·∫≠t g·ª£i √Ω cho character hi·ªán t·∫°i
    dialogueStore.suggestedPrompts[currentCharacter.value?.id || ''] = parsed.nextPrompts;

    // Ch·ªâ l∆∞u n·ªôi dung ch√≠nh v√†o c√¢y h·ªôi tho·∫°i
    if (parsed.mainContent) {
        dialogueStore.updateAIResponse(nodeId, parsed.mainContent);
    } else {
        dialogueStore.markAsFailed(nodeId);
    }
};

// C·∫≠p nh·∫≠t handleSendMessage
const handleSendMessage = async () => {
    if (isSending.value || !userInput.value.trim()) return;

    const newUserInput = userInput.value;
    userInput.value = ''; // Clear input field immediately

    // üÜï B∆Ø·ªöC 1: Th√™m user input v·ªõi status pending ngay l·∫≠p t·ª©c
    const pendingNodeId = dialogueStore.addInput(newUserInput);

    if (!pendingNodeId) {
        console.error('‚ùå Failed to add user input');
        return;
    }

    try {
        // üÜï B∆Ø·ªöC 2: G·ª≠i request ƒë·∫øn AI
        const aiResponseRaw = await sendRequestToLLM(newUserInput);
        if (aiResponseRaw) {
            handleAIResponse(aiResponseRaw, pendingNodeId);
        }
    } catch (error) {
        console.error('‚ùå AI request failed:', error);
        dialogueStore.markAsFailed(pendingNodeId);
    }
};

//C·∫≠p nh·∫≠t handleEditMessageModal
function handleEditMessageModal(messageId: string, content: string, isAssistant: boolean) {
    dialogueStore.updateMessage(messageId, content, isAssistant);
}

// C·∫≠p nh·∫≠t handleMessageButtonClick
async function handleMessageButtonClick({ buttonName, role, messageId }: { buttonName: string, role: string, messageId: string }) {
    if (dialogueStore.currentDialogue?.currentNodeId !== messageId) {
        return;
    }

    if (buttonName === 'edit') {
        const currentMessage = db.DialogueMessages.findOne({ id: messageId });
        if (currentMessage) {
            modalStore.openModal(MODALS.EDIT_MESSAGE, {
                id: currentMessage.id,
                content: role === 'assistant' ? currentMessage.assistantResponse : currentMessage.userInput,
                isAssistant: role === 'assistant',
            })
        }
    }

    if (buttonName === 'delete') {
        if (role === 'assistant') {
            dialogueStore.retryMessage(messageId);
        } else {
            dialogueStore.regenerate();
        }
    }

    if (buttonName === 'replay') {
        const userInput = dialogueStore.retryMessage(messageId);
        if (userInput) {
            try {
                const aiResponseRaw = await sendRequestToLLM(userInput);
                if (aiResponseRaw) {
                    handleAIResponse(aiResponseRaw, messageId);
                }
            } catch (error) {
                console.error('‚ùå Retry failed:', error);
                dialogueStore.markAsFailed(messageId);
            }
        }
    }
}

watch(currentMessagesForDisplay, () => {
    scrollToBottom();
}, { deep: true });

onMounted(async () => {
    setTimeout(() => {
        const characterId = screenPayload.value?.id as string;
        if (characterId) {
            dialogueStore.loadDialogue(characterId);

            currentCharacter.value = db.CharacterCards.findOne({ id: characterId }) as CharacterCard | null;
            if (currentCharacter.value) {
                imageFile.value = currentCharacter.value.getImageFile() || null;
                currentCharacter.value.getData();
                const greeting = currentCharacter.value.getGreeting();
                if (greeting) {
                    firstGreeting.value = formatMessageContent(greeting);
                }
            }

            currentUser.value = db.UserProfiles.findOne({}) as UserProfile | null;
        }
    }, 100);
});
</script>

<style scoped>
.prose {
    line-height: 1.75;
}

.prose p {
    margin-bottom: 0;
}

/* üÜï CSS M·ªöI CHO BUBBLE V√Ä BUTTONS */

/* Container c·ªßa bubble c·∫ßn c√≥ position relative */
.message-bubble {
    position: relative;
    /* Th√™m padding-bottom ƒë·ªÉ ch·ªØ kh√¥ng b·ªã c√°c n√∫t che m·∫•t */
    padding-bottom: 10px !important;
    /* Kho·∫£ng 2.25rem */
}
</style>
</file>

<file path="src/components/chat_screen/EditMessageModal.vue">
<template>
  <Dialog 
    :visible="useModal.isModalOpen(MODALS.EDIT_MESSAGE)" 
    @update:visible="(value) => { if (!value) closeModal() }" 
    @hide="closeModal"
    modal 
    header="Edit Message" 
    :style="{ width: '50vw' }"
    :breakpoints="{ '1199px': '75vw', '575px': '90vw' }"
  >
    <div class="flex flex-col gap-4 p-4">
      <textarea 
        v-model="messageContent"
        class="w-full h-64 p-3 border border-gray-300 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
        placeholder="Enter your message here..."
      ></textarea>
    </div>
    
    <template #footer>
      <div class="flex gap-2 justify-between w-full">
        <Button 
          label="Clear" 
          severity="secondary" 
          @click="clearMessage"
        />
        <SaveButton @click="handleSave" ref="saveButtonRef" />
      </div>
    </template>
  </Dialog>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue'
import { storeToRefs } from 'pinia'
import Dialog from 'primevue/dialog'
import Button from 'primevue/button'
import SaveButton from '@/components/common/SaveButton.vue'
import { useModalStore } from '@/stores/modal';
import { MODALS } from '@/constants';

const useModal = useModalStore()
const { modalData } = storeToRefs(useModal)
const saveButtonRef = ref()

const messageContent = ref('')
const isAssistant = ref(false)

// Watch for modalData changes to populate textarea
watch(() => modalData.value, (newData) => {
  isAssistant.value = newData?.isAssistant || false
  if (newData && newData.content) {
    messageContent.value = newData.content
  } else {
    messageContent.value = ''
  }
}, { immediate: true })

// Define emits to communicate with parent
const emit = defineEmits<{
  saveMessage: [messageId: string, content: string, isAssistant: boolean]
}>()

function clearMessage() {
  messageContent.value = ''
}

function closeModal() {
  messageContent.value = ''
  useModal.closeModal()
}

function handleSave() {
  const messageId = modalData.value?.id
  emit('saveMessage', messageId, messageContent.value, isAssistant.value)
  
  // Show success state on save button
  if (saveButtonRef.value) {
    saveButtonRef.value.showSuccess()
  }
  closeModal()
}
</script>

<style scoped>
/* Custom styles if needed */
</style>
</file>

<file path="src/components/chat_screen/ExtractorCharacterModal.vue">
<template>
  <Dialog
    :visible="useModal.isModalOpen(MODALS.EXTRACTOR_CHARACTER)"
    @update:visible="(value) => { if (!value) closeModal() }"
    @hide="closeModal"
    modal
    header="Extractor Character"
    :style="{ width: '50vw' }"
    :breakpoints="{ '1199px': '75vw', '575px': '95vw' }"
  >
    <div class="flex flex-col gap-4">
      <div>
        <label for="extractor-name" class="block text-sm font-medium text-gray-700 mb-1">Extractor Name</label>
        <InputText id="extractor-name" v-model="extractorName" class="w-full" />
      </div>
      <Button label="Extractor" :loading="isExtracting" :disabled="!extractorName || !characterId" icon="pi pi-question-circle" class="w-full" @click="onExtract" />
      <Fieldset legend="Result">
        <div class="flex flex-col gap-3">
          <div>
            <label for="result-select" class="block text-sm font-medium text-gray-700 mb-1">Select Property</label>
            <Select id="result-select" v-model="selectedField" :options="selectOptions" placeholder="Select a property" class="w-full md:w-1/3" />
          </div>
          <Textarea v-model="resultText" rows="8" class="w-full font-mono" />
        </div>
      </Fieldset>
    </div>
    <template #footer>
      <div class="flex justify-between w-full gap-2">
        <Button label="Cancel" severity="secondary" @click="closeModal" />
        <SaveButton @click="handleSave" />
      </div>
    </template>
  </Dialog>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { storeToRefs } from 'pinia';
import Dialog from 'primevue/dialog';
import Button from 'primevue/button';
import InputText from 'primevue/inputtext';
import Select from 'primevue/select';
import Textarea from 'primevue/textarea';
import Fieldset from 'primevue/fieldset';
import SaveButton from '@/components/common/SaveButton.vue';
import { MODALS } from '@/constants';
import { useModalStore } from '@/stores/modal';
import { CharacterCard, db, LLMModel } from '@/db';
import { useResourcesStore } from '@/stores/resources';
import { OpenAIOptions, sendOpenAiRequestStream } from '@/utils/llm';
import { useDialogueStore } from '@/stores/dialogue';

const useModal = useModalStore();
const { modalData } = storeToRefs(useModal);
const dialogueStore = useDialogueStore();
const { chatHistoryForPrompt } = storeToRefs(dialogueStore);
const extractorName = ref('');
const selectedField = ref(null);
const selectOptions = ref([]); // [{ label: 'Property 1', value: 'property1' }, ...]
const resultText = ref('');
const isExtracting = ref(false);
const resourcesStore = useResourcesStore();

const emit = defineEmits<{
  'save-character': (character: CharacterCard) => void;
}>();


const props = defineProps({
  characterId: { type: String, required: true },
});

async function onExtract() {
  try {
    if(!props.characterId) return;
    if(extractorName.value.length == 0) return;
    const llmModel = db.LLMModels.findOne({ isDefault: true }) as LLMModel;
    if(!llmModel) return;
    if(chatHistoryForPrompt.value.length == 0) return;
    isExtracting.value = true;
    
    let extractorPrompt = resourcesStore.extractorCharacterPrompt.replace(/{{character_name_to_extract}}/g, extractorName.value);
    extractorPrompt = extractorPrompt.replace(/{{history_chat}}/g, chatHistoryForPrompt.value);
    console.log(extractorPrompt);
    const options: OpenAIOptions = {
            baseURL: llmModel.baseUrl,
            apiKey: llmModel.apiKey,
            data: {
                model: llmModel.modelName,
                messages: [
                    { role: 'user', content: extractorPrompt },
                ],
                stream: true,
                temperature: 0.2,
                top_p: 0.1,
            }
        };
        resultText.value = '';
        await sendOpenAiRequestStream(options, (chunk: string) => {
            resultText.value += chunk;
        });
        isExtracting.value = false;
  } catch (error) {
    console.error(error);
  } finally{
    isExtracting.value = false;
  }
}
function handleSave() {
  closeModal();
}
function closeModal() {
  extractorName.value = '';
  selectedField.value = null;
  resultText.value = '';
  useModal.closeModal();
}
</script>
</file>

<file path="src/components/chat_screen/MessageButtons.vue">
<!-- src/components/chat_screen/MessageButtons.vue -->
<template>
  <div class="flex justify-end">
    <!-- N√∫t Pencil -->
    <Button
      icon="pi pi-pencil"
      severity="secondary"
      text rounded size="small"
      @click="emitClick('edit')"
      v-tooltip.top="'Ch·ªânh s·ª≠a'"
      :disabled="isDisabled"
    />
    
    <!-- N√∫t Replay (ch·ªâ cho assistant) -->
    <Button
      icon="pi pi-replay"
      severity="secondary"
      text rounded size="small"
      @click="emitClick('replay')"
      v-tooltip.top="'T·∫°o l·∫°i'"
      :disabled="isDisabled"
    />
    
    <!-- N√∫t Delete -->
    <Button
      icon="pi pi-trash"
      severity="danger"
      text rounded size="small"
      @click="emitClick('delete')"
      v-tooltip.top="'Xo√°'"
      :disabled="isDisabled"
    />
  </div>
</template>

<script setup lang="ts">
import { defineProps, defineEmits, computed } from 'vue'
import Button from 'primevue/button';

// onMounted(() => {
//   console.log(props)
// })

const props = defineProps({
  role: { type: String, required: true },
  messageId: { type: [String, Number], required: true },
  latestMessageId: { type: [String, Number], required: false },
  status: { type: String, required: false, default: 'completed' },
})

const isDisabled = computed(() => {
    return props.messageId !== props.latestMessageId
})

const emit = defineEmits(['button-click'])
function emitClick(buttonName: string) {
  emit('button-click', { buttonName, role: props.role, messageId: props.messageId })
}
</script>

<style scoped>
/* X√≥a h·∫øt CSS c≈©, ch√∫ng ta d√πng PrimeVue v√† Tailwind */
</style>
</file>

<file path="src/components/common/LLMProviderSelect.vue">
<template>
  <SplitButton v-if="!noDisplaySelected" :label="selectedName" :buttonProps="buttonProps" :model="llm_providers" size="small"></SplitButton>
  <SplitButton v-else :buttonProps="buttonProps" :model="llm_providers" size="small"></SplitButton>
</template>

<script setup lang="ts">
import { db, LLMModel } from "@/db";  
import { ref, onMounted, watch } from "vue";

const props = defineProps({
  modelValue: {
    type: String,
    default: null,
  },
  noDisplaySelected: {
    type: Boolean,
    default: true,
  },
  buttonProps: {
    type: Object,
    default: () => ({}),
  }
});

const emit = defineEmits(['update:modelValue']);
const selectedName = ref('');

const selectedProviderId = ref(props.modelValue);
const llm_providers = ref(<{ label: string | undefined; icon: string; command: () => void; }[]>[]);

watch(selectedProviderId, (newValue) => {
  emit('update:modelValue', newValue);
});

watch(() => props.modelValue, (newValue) => {
  selectedProviderId.value = newValue;
});

function loadData() {
  llm_providers.value = (db.LLMModels.find({}, {

    fields: { id: 1, name: 1, isDefault: 1 }
  }).fetch() as Partial<LLMModel>[]).map((provider) => ({
    label: provider.name,
    icon: provider.isDefault ? 'pi pi-check' : '',
    command: () => {
      sessionStorage.setItem('selectedLLMModelId', provider.id || '');
      emit('update:modelValue', provider.id);
      db.LLMModels.updateOne({ id: provider.id }, {
        $set: {
          isDefault: true,
        }
      });
      db.LLMModels.updateMany({ id: { $ne: provider.id } }, {
        $set: {
          isDefault: false,
        }
      });
      loadData()
    }
  }));
  if(!props.noDisplaySelected){
    selectedName.value = llm_providers.value.find((provider) => provider.icon === 'pi pi-check')?.label || '';
  }
}

onMounted(async () => {
  setTimeout(() => {
    loadData();
  }, 100);
})
</script>
</file>

<file path="src/components/common/LoadingScreen.vue">
<template>
  <div class="flex items-center justify-center h-screen w-screen bg-gray-900 text-white">
    <div class="flex flex-col items-center">
      <svg class="animate-spin -ml-1 mr-3 h-10 w-10 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <span class="mt-4 text-lg">Loading...</span>
    </div>
  </div>
</template>

<script setup lang="ts">
// No script logic needed for this simple component
</script>
</file>

<file path="src/components/common/SaveButton.vue">
<template>
  <Button
    :label="label"
    :icon="icon"
    :variant="variant"
    severity="success"
    @click="handleClick"
  />
</template>

<script lang="ts" setup>
import { ref } from 'vue';
import Button from 'primevue/button';

const emit = defineEmits(['click']);

const defaultState = {
  label: 'Save',
  icon: 'pi pi-save',
  variant: 'outlined' as const,
};

const successState = {
  label: 'Saved!',
  icon: 'pi pi-check',
  variant: undefined,
};

const label = ref(defaultState.label);
const icon = ref(defaultState.icon);
const variant = ref<string | undefined>(defaultState.variant);
let timeoutId: number | undefined;

const showSuccess = () => {
  if (timeoutId) {
    clearTimeout(timeoutId);
  }

  label.value = successState.label;
  icon.value = successState.icon;
  variant.value = successState.variant;

  timeoutId = window.setTimeout(() => {
    label.value = defaultState.label;
    icon.value = defaultState.icon;
    variant.value = defaultState.variant;
    timeoutId = undefined;
  }, 2000);
};

const handleClick = (event: MouseEvent) => {
  emit('click', event);
};

defineExpose({
  showSuccess,
});
</script>
</file>

<file path="src/components/llm_models/LLMIndex.vue">
<script setup lang="ts">
import { ref, onMounted, watchEffect } from 'vue'
import Button from 'primevue/button'
import ProgressSpinner from 'primevue/progressspinner'
import Menu from 'primevue/menu'
import ToggleSwitch from 'primevue/toggleswitch'
import { useI18n } from 'vue-i18n'
import ModalLLM from './Modal.vue'
import { useModalStore } from '@/stores/modal'
import { MODALS } from '@/constants'
import { useDeleteConfirm } from '@/composables/useDeleteConfirm'
import { db, LLMModel } from '@/db'
import Dexie from 'dexie'

const { t } = useI18n()

const useModal = useModalStore()
const { confirmDelete } = useDeleteConfirm()


const loading = ref(false)
const llm_models = ref<LLMModel[]>([])
const menus = ref<any[]>([])

interface MenuItem {
  label: string
  icon: string
  command: () => void
  disabled?: boolean
  class?: string
}

const menuItems = ref<MenuItem[]>([])

const selectedModel = ref<LLMModel | null>(null)

const toggleMenu = (event: Event, model: LLMModel, index: number) => {
  selectedModel.value = model
  // Update menuItems with current model
  menuItems.value = [
    {
      label: 'Edit',
      icon: 'pi pi-pencil',
      command: () => {
        if (selectedModel.value) {
          useModal.openModal(MODALS.LLM_MODEL, selectedModel.value)
        }
      }
    },
    {
      label: 'Delete',
      icon: 'pi pi-trash',
      disabled: model.isDefault,
      class: 'delete-menu-item',
      command: () => {
        if (selectedModel.value && !selectedModel.value.isDefault) {
          confirmDelete(selectedModel.value, {
            message: `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a model "${selectedModel.value.name}"?`,
            header: 'X√≥a LLM Model',
            onConfirm: deleteModel
          })
        }
      }
    }
  ]
  if (menus.value[index]) {
    menus.value[index].toggle(event)
  }
}


// Load models on component mount
onMounted(async () => {
  // await loadModels();
})

// async function loadModels() {
//   try {
//     loading.value = true
//     // Simulate API call - replace with actual API call
//     llm_models.value = await db.LLMModels.find().fetch()
//   } catch (error) {
//     console.error('Error loading models:', error)
//   } finally {
//     loading.value = false
//   }
// }

async function saveModel(modelData: Omit<LLMModel, 'id'>) {
  try {
    const newModel = {
      // id: crypto.randomUUID(),
      ...modelData,
      createdAt: Date.now(),
    }
    db.LLMModels.insert(newModel)
    // // Save to database
    // await db.llmModels.put(newModel)
    // // If this model is set as default, update all other models to not be default
    // await toggleDefault(newModel)



    return true
  } catch (error) {
    console.error('Error saving model:', error)
    return false
  }
}

async function toggleDefault(_model: LLMModel, isForce: boolean = false) {
  try {
    if(_model.isDefault || isForce){
      if(isForce){
        db.LLMModels.updateOne({id: _model.id}, {
          $set: {
            isDefault: true
          }
        })
      }
      db.LLMModels.updateMany({id: {$ne: _model.id}}, {
        $set: {
          isDefault: false
        }
      })
    }else{
      if(db.LLMModels.find({isDefault: true}).count() === 0){
        const firstModel = db.LLMModels.findOne({}, {
         sort: {createdAt: -1}
        }) as LLMModel
        db.LLMModels.updateOne({id: firstModel.id}, {
          $set: {
            isDefault: true
          }
        })
      }
    }
    // console.log(_model, isForce)
    // await db.transaction('rw', db.llmModels, async () => {
    //   if (_model.isDefault || isForce) {
    //     if(isForce){
    //       await db.llmModels.update(_model.id, { isDefault: true })
    //     }
    //     await db.llmModels.where('id').notEqual(_model.id).modify({ isDefault: false })
    //   } else {
    //     const allModels = await db.llmModels.toArray()
    //     if (!allModels.find((m) => m.isDefault === true)) {
    //       const firstModel = allModels[0];
    //       await db.llmModels.where('id').equals(firstModel.id).modify({ isDefault: true })
    //     }
    //   }
    //   await loadModels()
    // })
    
    // Reload models to update the list
    
    console.log("Transaction committed")
  } catch (error) {
    if (error instanceof Dexie.ModifyError) {
      console.error(error.failures.length + " items failed to modify")
    } else {
      console.error("Generic error: " + error)
    }
    console.error('Error toggling default:', error)
  }
}

async function deleteModel(model: LLMModel) {
  try {
    db.LLMModels.removeOne({id: model.id})
    // await loadModels()
    console.log('Model deleted successfully:', model.name)
  } catch (error) {
    console.error('Error deleting model:', error)
  }
}

async function updateModel(modelData: LLMModel) {
  try {
    // Update the model
    // await db.llmModels.update(modelData.id, modelData)

    // If this model is set as default, update all other models to not be default
    // await toggleDefault(modelData)
    db.LLMModels.updateOne({id: modelData.id}, {
      $set: modelData
    })
    console.log('Model updated successfully:', modelData.name)
  } catch (error) {
    console.error('Error updating model:', error)
  }
}

watchEffect((onCleanup) => {
  const cursor = db.LLMModels.find()
  llm_models.value = cursor.fetch()
  onCleanup(() => cursor.cleanup())
})

// Provide functions to child components
defineExpose({
  saveModel,
  updateModel
})
</script>

<template>
  <div class="space-y-6">
    <!-- Header -->
    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
      <div>
        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">
          {{ t('llm_models.index.title') }}
        </h1>
      </div>
      <div class="flex gap-2">
        <Button @click="useModal.openModal(MODALS.LLM_MODEL)" severity="info" size="small">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
          </svg>
          {{ t('llm_models.index.add') }}
        </Button>
        <Button severity="secondary" size="small">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10">
            </path>
          </svg>
          Import
        </Button>
      </div>
    </div>

    <!--LLM Models Content -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
      <!-- Loading State -->
      <div v-if="loading" class="flex justify-center items-center py-12">
        <ProgressSpinner style="width: 50px; height: 50px" strokeWidth="8" />
      </div>

      <!-- Empty State -->
      <div v-else-if="llm_models.length === 0" class="text-center py-12">
        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        </svg>
        <h3 class="mt-2 text-sm font-medium text-gray-900 dark:text-white">{{ t('message.empty') }}</h3>
      </div>

      <!-- Card view -->
      <div class="p-4 grid grid-cols-1 md:grid-cols-3 gap-4">
        <div v-for="(model, index) in llm_models" :key="model.id"
          class="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
          <div class="flex justify-between items-start mb-3">
            <div class="flex-1">
              <h3 class="font-medium text-gray-900 dark:text-white">{{ model.name }}</h3>
              <p class="text-sm text-gray-500 dark:text-gray-400">{{ model.modelName }}</p>
              <div class="mt-1">
                <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium"
                  :class="model.llmProvider === 'openai' ? 'bg-blue-100 text-blue-800' : 'bg-green-100 text-green-800'">
                  {{ model.llmProvider }}
                </span>
              </div>
            </div>
            <Menu :ref="(el: any) => menus[index] = el" :model="menuItems" :popup="true">
              <template #item="{ item, props }">
                <a v-ripple v-bind="props.action" :class="item.class">
                  <span :class="item.icon" />
                  <span class="ml-2">{{ item.label }}</span>
                </a>
              </template>
            </Menu>
            <Button @click="(event: any) => toggleMenu(event, model, index)" severity="secondary" size="small" text>
              <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                <path
                  d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" />
              </svg>
            </Button>
          </div>
          <div class="flex items-center justify-between">
            <span class="text-sm text-gray-600 dark:text-gray-300">Default Model</span>
            <ToggleSwitch :model-value="model.isDefault"
              @update:model-value="toggleDefault(model, true)" />
          </div>
        </div>
      </div>
    </div>

    <!-- Add/Edit Model Modal -->
    <ModalLLM @saveModel="saveModel" @updateModel="updateModel" />
  </div>
</template>

<style scoped>
/* Custom styles for disabled ToggleSwitch to keep green color when default */
:deep(.p-toggleswitch.p-disabled .p-toggleswitch-slider) {
  background-color: #22c55e !important;
  /* Keep green color */
}

:deep(.p-toggleswitch.p-disabled .p-toggleswitch-slider:before) {
  background-color: white !important;
}

/* Custom styles for Delete menu item */
.delete-menu-item {
  color: #ef4444 !important;
  border-radius: 4px !important;
}

.delete-menu-item:hover:not(.p-disabled) {
  background-color: #fef2f2 !important;
  border-color: #dc2626 !important;
}

.delete-menu-item.p-disabled {
  opacity: 0.5 !important;
  cursor: not-allowed !important;
  border: 1px solid #d1d5db !important;
  color: #9ca3af !important;
  background-color: #f9fafb !important;
}
</style>
</file>

<file path="src/components/llm_models/LLMOptionsModal.vue">
<template>
  <div>
    <Button icon="pi pi-android" :class="['p-button-rounded p-button-text', props.classExt]" @click="visible = true" @hide="resetOptions" />

    <Dialog v-model:visible="visible" modal header="LLM Options" :style="{ width: '50vw' }"
      :breakpoints="{ '1199px': '75vw', '575px': '90vw' }">
      <form class="space-y-4">
        <div class="space-y-4">
          <div class="field">
            <label for="model" class="block">Model</label>
            <LLMProviderSelect severity="help" class="w-full" :noDisplaySelected="false" />
          </div>

          <div class="field">
            <label for="top_p" class="block">Top P: {{ options.top_p }}</label>
            <Slider id="top_p" v-model="options.top_p" :min="0" :max="1" :step="0.01" class="w-full" />
          </div>

          <div class="field">
            <label for="temperature" class="block">Temperature: {{ options.temperature }}</label>
            <Slider id="temperature" v-model="options.temperature" :min="0" :max="2" :step="0.01" class="w-full" />
          </div>

          <div class="field">
            <label for="maxTokens" class="block">Max Tokens: {{ options.maxTokens }}</label>
            <Slider id="maxTokens" v-model="options.maxTokens" :min="1000" :max="4096" :step="100" class="w-full" />
          </div>

          <div class="field">
            <label for="contextWindow" class="block">Context Window: {{ options.contextWindow }}</label>
            <Slider id="contextWindow" v-model="options.contextWindow" :min="1000" :max="8192" :step="100" class="w-full" />
          </div>

          <div class="field">
            <label for="responseLength" class="block">Response Length: {{ options.responseLength }}</label>
            <Slider id="responseLength" v-model="options.responseLength" :min="300" :max="3000" :step="100" class="w-full" />
          </div>
        </div>

        <div class="flex justify-end gap-2 mt-6">
          <Button label="Reset" severity="secondary" size="small" @click="resetOptions" />
          <SaveButton size="small" @click="handleSave" />
        </div>
      </form>
    </Dialog>
  </div>
</template>

<script lang="ts" setup>
import { ref, watch } from 'vue';
import Button from 'primevue/button';
import Dialog from 'primevue/dialog';
import Slider from 'primevue/slider';
import SaveButton from '@/components/common/SaveButton.vue';
import LLMProviderSelect from '@/components/common/LLMProviderSelect.vue';
import { LLMOptions } from '@/db';

const props = defineProps<{
  init: LLMOptions;
  classExt?: string;
}>();

const emit = defineEmits<{
  (e: 'save', options: LLMOptions): void;
}>();

const visible = ref(false);
const options = ref<LLMOptions>({ ...props.init });

watch(
  () => props.init,
  (newInit) => {
    options.value = { ...newInit };
  },
  { deep: true }
);

const resetOptions = () => {
  options.value = { ...props.init };
};

const handleSave = () => {
  emit('save', options.value);
  visible.value = false;
};
</script>
</file>

<file path="src/components/llm_models/Modal.vue">
<script setup lang="ts">
import { ref, watch, onMounted, computed, nextTick } from 'vue'
import { storeToRefs } from 'pinia'
import Dialog from 'primevue/dialog'
import Button from 'primevue/button'
import InputText from 'primevue/inputtext'
import Select from 'primevue/select'
import Password from 'primevue/password'
import AutoComplete from 'primevue/autocomplete'
import IftaLabel from 'primevue/iftalabel'
import ToggleSwitch from 'primevue/toggleswitch'
import { LLMModel } from '@/newDb'
import { useModalStore } from '@/stores/modal'
import { useResourcesStore } from '@/stores/resources'
import { sendOpenAiRequestSync } from '@/utils/llm'
import { MODALS } from '@/constants'

// const MODAL_NAME = MODALS.LLM_MODEL

// No props needed - using modalData from store

const useModal = useModalStore()
const resourcesStore = useResourcesStore()
const { llmProviders_NameAndBaseUrl } = storeToRefs(resourcesStore)
const { modalData } = storeToRefs(useModal)
const loadingVerify = ref(false)
const loadingSave = ref(false)
const id = ref<string | null>(null)
const name = ref('')
const llmProvider = ref('')
const baseUrl = ref('')
const modelName = ref('')
const apiKey = ref('')
const selectedProvider = ref({
  name: '',
  baseUrl: '',
  models: [] as string[]
})
const filteredModels = ref<string[]>([])
const isVerified = ref(false)
const isDefault = ref(false)
const isSettingFromModal = ref(false)



// Set default provider and baseUrl on mount
onMounted(() => {
  setInitialProvider()
})
// Watch for llmProvider changes to auto-fill baseUrl and update selectedProvider
watch(llmProvider, (newProvider) => {
  if (isSettingFromModal.value) return // Skip if setting from modal data

  if (newProvider && llmProviders_NameAndBaseUrl.value) {
    const foundProvider = llmProviders_NameAndBaseUrl.value.find(provider => provider.name === newProvider)
    selectedProvider.value = foundProvider ?? { name: '', baseUrl: '', models: [] }
    if (selectedProvider.value) {
      baseUrl.value = selectedProvider.value.baseUrl
    }
    // Always reset modelName and apiKey when provider changes for new records
    modelName.value = ''
    apiKey.value = ''
  }
  updateName()
})
// Computed property to determine if this is edit mode
const isEditMode = computed(() => id.value !== null)

// Function to set initial provider and base URL
const setInitialProvider = () => {
  if (llmProviders_NameAndBaseUrl.value && llmProviders_NameAndBaseUrl.value.length > 0) {
    const firstProvider = llmProviders_NameAndBaseUrl.value[0]
    llmProvider.value = firstProvider.name
    baseUrl.value = firstProvider.baseUrl
    selectedProvider.value = firstProvider
    updateName()
  }
}

// Watch for modalData changes to populate form
watch(() => modalData.value, (newEditData) => {
  if (newEditData) {
    // Edit mode - populate form with existing data
    isSettingFromModal.value = true // Set flag to prevent other watchers from interfering

    id.value = newEditData.id
    name.value = newEditData.name
    llmProvider.value = newEditData.llmProvider
        // Set selectedProvider
    if (llmProviders_NameAndBaseUrl.value) {
      const foundProvider = llmProviders_NameAndBaseUrl.value.find(provider => provider.name === newEditData.llmProvider)
      selectedProvider.value = foundProvider ?? { name: '', baseUrl: '', models: [] }
    }
    baseUrl.value = newEditData.baseUrl
    modelName.value = newEditData.modelName
    apiKey.value = newEditData.apiKey
    isDefault.value = newEditData.isDefault
    nextTick(() => {
      isSettingFromModal.value = false // Reset flag after all fields are set
    })
  } else {
    // Add mode - reset form and set defaults
    resetForm()
  }
}, { immediate: true })

// Function to update name based on provider and modelName
const updateName = () => {
  if (llmProvider.value && modelName.value) {
    name.value = `${llmProvider.value}/${modelName.value}`
  } else if (llmProvider.value) {
    name.value = llmProvider.value
  } else {
    name.value = ''
  }
}



// Watch for modelName changes to update name
watch(modelName, () => {
  updateName()
})

// Search function for AutoComplete
const searchModels = (event: any) => {
  if (!event.query.trim().length) {
    filteredModels.value = [...selectedProvider.value.models]
  } else {
    filteredModels.value = selectedProvider.value.models.filter((model: string) => {
      return model.toLowerCase().includes(event.query.toLowerCase())
    })
  }
}

async function verifyConnection() {
  if (!apiKey.value || !modelName.value || !baseUrl.value) {
    return false
  }
  loadingVerify.value = true
  isVerified.value = false
  const options = {
    baseURL: baseUrl.value,
    apiKey: apiKey.value,
    data: {
      model: modelName.value,
      messages: [
        { role: 'system', content: "You are a helpful assistant. Reply with 'Connection successful' to confirm the connection works." },
        { role: 'user', content: `Test connection - ${Date.now()}` }
      ],
      stream: false,
    }
  }
  try {
    const response = await sendOpenAiRequestSync(options)
    if (response) {
      isVerified.value = true
    }
  } catch (error) {

    return false
  } finally {
    loadingVerify.value = false
  }
}

function resetForm() {
  id.value = null
  name.value = ''
  llmProvider.value = ''
  baseUrl.value = ''
  modelName.value = ''
  apiKey.value = ''
  isDefault.value = false
  isVerified.value = false
  selectedProvider.value = { name: '', baseUrl: '', models: [] }
  filteredModels.value = []
}

function closeModal() {
  resetForm()
  useModal.closeModal()
}

// Define emits to communicate with parent
const emit = defineEmits<{
  saveModel: [modelData: Omit<LLMModel, 'id'>]
  updateModel: [modelData: LLMModel]
}>()

async function saveModel() {
  try {
    loadingSave.value = true

    if (isEditMode.value && id.value !== null) {
      // Edit mode - emit updateModel with id
      const modelData = {
        id: id.value as string,
        name: name.value,
        llmProvider: llmProvider.value,
        modelName: modelName.value,
        baseUrl: baseUrl.value,
        apiKey: apiKey.value,
        isDefault: isDefault.value,
        createdAt: Date.now()
      }
      emit('updateModel', modelData)
    } else {
      // Add mode - emit saveModel without id
      const modelData = {
        name: name.value,
        llmProvider: llmProvider.value,
        modelName: modelName.value,
        baseUrl: baseUrl.value,
        apiKey: apiKey.value,
        isDefault: isDefault.value,
        createdAt: Date.now()
      }
      emit('saveModel', modelData)
    }

    useModal.closeModal()
  } catch (error) {

  } finally {
    loadingSave.value = false
  }
}
</script>

<template>
  <Dialog :visible="useModal.isModalOpen(MODALS.LLM_MODEL)" @update:visible="(value) => { if (!value) closeModal() }" @hide="closeModal"
    modal :header="isEditMode ? 'Edit LLM Model' : 'Add New LLM Model'" :style="{ width: '50vw' }"
    :breakpoints="{ '1199px': '75vw', '575px': '90vw' }">
    <div class="flex flex-col gap-4 p-4">
      <IftaLabel>
        <Select v-model="llmProvider" :options="llmProviders_NameAndBaseUrl" optionLabel="name" optionValue="name"
          inputId="llmProvider" class="w-full" />
        <label for="llmProvider">LLM Provider</label>
      </IftaLabel>

      <IftaLabel>
        <InputText v-model="baseUrl" inputId="baseUrl" class="w-full" />
        <label for="baseUrl">Base URL</label>
      </IftaLabel>

      <IftaLabel>
        <AutoComplete v-model="modelName" :suggestions="filteredModels" @complete="searchModels" inputId="modelName"
          class="w-full" dropdown />
        <label for="modelName">Model Name</label>
      </IftaLabel>

      <IftaLabel>
        <Password toggleMask v-model="apiKey" :feedback="false" inputId="apiKey" class="w-full" inputClass="w-full" />
        <label for="apiKey">API Key</label>
      </IftaLabel>

      <IftaLabel>
        <InputText v-model="name" inputId="name" class="w-full" />
        <label for="name">Name</label>
      </IftaLabel>

      <div class="flex items-center gap-2">
        <ToggleSwitch v-model="isDefault" inputId="isDefault" />
        <label for="isDefault" class="text-sm font-medium">As Default</label>
      </div>
    </div>
    <template #footer>
      <div class="flex gap-2 justify-end">
        <Button @click="verifyConnection" severity="secondary" class="min-w-32">
          <i v-if="loadingVerify" class="pi pi-spin pi-spinner mr-2"></i>
          Verify Connection
        </Button>
        <Button @click="saveModel" severity="info" :disabled="!isVerified" class="min-w-24">
          <i v-if="loadingSave" class="pi pi-spin pi-spinner mr-2"></i>
          {{ isEditMode ? 'Update' : 'Save' }}
        </Button>
      </div>
    </template>
  </Dialog>
</template>
</file>

<file path="src/components/profile/ProfileList.vue">
<template>
  <div class="space-y-6">
    <!-- Header -->
    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
      <div>
        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">
          Profiles
        </h1>
        <p class="text-gray-600 dark:text-gray-400">
          Manage your chat profiles
        </p>
      </div>
      <div class="flex gap-2">
        <Button icon="pi pi-plus" severity="info"
          size="small" label="New Profile" />
      </div>
    </div>
    <!--Body-->
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
      <Card v-for="profile in profiles" :key="profile.id" class="w-full">
        <template #title>
          {{ profile.name || 'Unknown' }}
        </template>
        <template #subtitle>
          <div class="flex items-center gap-1 text-yellow-500">
            <i class="pi pi-user"></i>
            <span>{{ profile.persona }}</span>
          </div>
        </template>
        <template #footer>
          <div class="flex gap-3 mt-1 justify-end">
            <Button icon="pi pi-pencil" severity="secondary" outlined rounded aria-label="Edit" />
            <Button icon="pi pi-trash" severity="danger" rounded aria-label="Delete" />
          </div>
        </template>
      </Card>
    </div>
  </div>
</template>

<script setup lang="ts">
import Button from 'primevue/button';
import Card from 'primevue/card';
import { ref } from 'vue';

// Mock data for profiles
const profiles = ref([
  {
    id: '1',
    name: 'Default Profile',
    persona: 'A helpful assistant.'
  },
  {
    id: '2',
    name: 'Creative Writer',
    persona: 'A creative writer for stories and poems.'
  },
  {
    id: '3',
    name: 'Technical Expert',
    persona: 'An expert in technical topics.'
  }
]);
</script>
</file>

<file path="src/components/DeleteConfirm.vue">
<template>
    <ConfirmDialog></ConfirmDialog>
    <div class="card flex flex-wrap gap-2 justify-center">
        <Button @click="handleConfirm()" label="Delete" severity="danger" outlined></Button>
    </div>
</template>

<script setup>
import { useConfirm } from "primevue/useconfirm";

const confirm = useConfirm();

const handleConfirm = () => {
    confirm.require({
        message: 'Do you want to delete this record?',
        header: 'Danger Zone',
        icon: 'pi pi-info-circle',
        rejectLabel: 'Cancel',
        rejectProps: {
            label: 'Cancel',
            severity: 'secondary',
            outlined: true
        },
        acceptProps: {
            label: 'Delete',
            severity: 'danger'
        },
        accept: () => {
            emit('confirm');
        },
        reject: () => {
            emit('reject');
        }
    });
};
</script>
</file>

<file path="src/components/MainLayout.vue">
<template>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-900">
    <!-- Navigation -->
    <nav class="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
      <!-- Logo and text on the left -->
      <div class="flex items-center gap-2">
        <img :src="APP_LOGO" alt="Mianix logo" class="h-8 w-8" />
        <span class="font-semibold text-lg text-gray-900 dark:text-white">Mianix</span>
      </div>
      
      <!-- NavConfig on the right -->
      <div class="flex items-center">
        <NavConfig />
      </div>
    </nav>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-6">
      <component :is="screenStore.currentComponent" />
    </main>
  </div>
</template>

<script setup lang="ts">
import { useScreenStore } from '@/stores/screen';
import { APP_LOGO } from '@/constants';
import NavConfig from './NavConfig.vue';
const screenStore = useScreenStore();
</script>
</file>

<file path="src/components/NavConfig.vue">
<template>
    <Menu ref="menu" :model="menuItems" :popup="true" class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg" v-if="menuItems.length > 0">
        <template #item="{ item }">
            <a v-ripple class="flex items-center px-4 py-3 text-sm cursor-pointer text-gray-700 dark:text-gray-200 hover:bg-blue-50 dark:hover:bg-blue-900/20 hover:text-blue-600 dark:hover:text-blue-400 transition-all duration-200 rounded-md mx-1 my-0.5">
                {{ item.label }}
            </a>
        </template>
    </Menu>
    <Button @click="toggle" severity="secondary" text>
        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd"
                d="M7.84 1.804A1 1 0 018.82 1h2.36a1 1 0 01.98.804l.331 1.652a6.993 6.993 0 011.929 1.115l1.598-.54a1 1 0 011.186.447l1.18 2.044a1 1 0 01-.205 1.251l-1.267 1.113a7.047 7.047 0 010 2.228l1.267 1.113a1 1 0 01.205 1.251l-1.18 2.044a1 1 0 01-1.186.447l-1.598-.54a6.993 6.993 0 01-1.929 1.115l-.33 1.652a1 1 0 01-.98.804H8.82a1 1 0 01-.98-.804l-.331-1.652a6.993 6.993 0 01-1.929-1.115l-1.598.54a1 1 0 01-1.186-.447l-1.18-2.044a1 1 0 01.205-1.251l1.267-1.114a7.05 7.05 0 010-2.227L1.821 7.773a1 1 0 01-.205-1.251l1.18-2.044a1 1 0 011.186-.447l1.598.54A6.993 6.993 0 017.51 3.456l.33-1.652zM10 13a3 3 0 100-6 3 3 0 000 6z"
                clip-rule="evenodd" />
        </svg>
    </Button>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useScreenStore } from '@/stores/screen';
import { useI18n } from 'vue-i18n';
import Menu from 'primevue/menu';
import Button from 'primevue/button';
import { SCREENS } from '@/constants';

const { t } = useI18n();
const screenStore = useScreenStore();
const menu = ref();

const toggle = (event: Event) => {
    menu.value.toggle(event);
};

const menuItems = [
    {
        label: t('nav.profiles'),
        command: () => screenStore.setScreen(SCREENS.PROFILE_LIST),
    },
    {
        label: t('nav.characters'),
        command: () => screenStore.setScreen(SCREENS.CHARACTER_LIST),
    },
    {
        label: t('nav.llm_models'),
        command: () => screenStore.setScreen(SCREENS.MODELS_LIST),
    },
    {
        label: t('nav.presets'),
        command: () => screenStore.setScreen(SCREENS.PRESETS_CONFIG),
    },
];
</script>
</file>

<file path="src/components/PresetConfig.vue">
<template>
  <div class="space-y-6">
    <!-- Header -->
    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
      <div>
        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">
          Preset Configuration
        </h1>
        <p class="text-gray-600 dark:text-gray-400">
          Manage your prompt presets and configurations
        </p>
      </div>
      <div class="flex gap-2">
        <Button @click="openAddModal" severity="info" size="small">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
          </svg>
          Add Preset
        </Button>
        <Button @click="importCharacter" severity="secondary" size="small">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"></path>
          </svg>
          Import
        </Button>
      </div>
    </div>

  </div>
</template>

<script setup lang="ts">
import Button from 'primevue/button';

const openAddModal = () => {
  // TODO: Implement add modal functionality
  alert('Add preset functionality will be implemented soon!');
};

const importCharacter = () => {
  // TODO: Implement character import functionality
  alert('Import functionality will be implemented soon!');
};
</script>
</file>

<file path="src/composables/useDeleteConfirm.ts">
import { ref } from 'vue'
import { useConfirm } from 'primevue/useconfirm'

export function useDeleteConfirm() {
  const confirm = useConfirm()
  const selectedItem = ref(null)

  const confirmDelete = (item: any, options?: {
    message?: string
    header?: string
    onConfirm?: (item: any) => void
  }) => {
    selectedItem.value = item
    
    confirm.require({
      message: options?.message || `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a "${item.name}"?`,
      header: options?.header || 'X√°c nh·∫≠n x√≥a',
      icon: 'pi pi-exclamation-triangle',
      rejectLabel: 'H·ªßy',
      acceptLabel: 'X√≥a',
      rejectProps: {
        label: 'H·ªßy',
        severity: 'secondary',
        outlined: true
      },
      acceptProps: {
        label: 'X√≥a',
        severity: 'danger'
      },
      accept: () => {
        if (options?.onConfirm) {
          options.onConfirm(selectedItem.value)
        }
      }
    })
  }

  return {
    selectedItem,
    confirmDelete
  }
}
</file>

<file path="src/db/index.ts">
import { Collection } from "@signaldb/core";
import createIndexedDBAdapter from "@signaldb/indexeddb";
import vueReactivityAdapter from "@signaldb/vue";
import createMonkeyAdapter from "./monkey";
import { CharacterCardData } from "@/types/character";
import { mergeObjects } from "@/utils/common";

export type LLMModel = {
  id: string;
  name: string;
  apiKey: string;
  baseUrl: string;
  modelName: string;
  llmProvider: string;
  isDefault: boolean;
  createdAt: number;
};

export type CharacterCardType = {
  id: string;
  data: Partial<CharacterCardData>;
  dataTranslated?: Partial<CharacterCardData>;
  isUseTranslated: boolean;
  createdAt: number;
};

export type StorageType = {
  id: string;
  file: File;
  type: "image" | "audio";
};

export class CharacterCard {
  id: string;
  data: Partial<CharacterCardData>;
  dataTranslated?: Partial<CharacterCardData>;
  isUseTranslated: boolean;
  createdAt: number;
  constructor(data: any) {
    this.id = data.id;
    this.data = data.data;
    this.dataTranslated = data.dataTranslated || {};
    this.isUseTranslated = data.isUseTranslated || false;
    this.createdAt = data.createdAt || Date.now();
    // Storage.insert({ id: this.id, file: data.imageFile, type: "image" });
  }
  getData() {
    if (this.isUseTranslated) {
      this.data = mergeObjects(this.data, this.dataTranslated || {});
    }
  }
  getGreeting(): string {
    if (
      this.data.alternateGreetings &&
      this.data.alternateGreetings.length > 0
    ) {
      const randomIndex = Math.floor(
        Math.random() * this.data.alternateGreetings.length
      );
      return this.data.alternateGreetings[randomIndex];
    }
    return this.data.firstMessage ?? "";
  }
  public getImageFile(): File | undefined {
    return Storage.findOne({
      type: "image",
      id: this.id,
    })?.file;
  }
}

export interface ParsedResponse {
  regexResult?: string;
  nextPrompts?: string[];
  compressedContent?: string;
}

export type DialogueMessageType = {
  parsedContent?: ParsedResponse;
  id: string;
  dialogueId: string;
  parentId: string | null;
  userInput: string;
  assistantResponse: string;
  status?: "pending" | "completed" | "failed"; // <-- TH√äM FIELD M·ªöI
  createdAt: number;
};
export type DialogType = {
  id: string;
  createdAt: number;
  currentNodeId: string; // <-- TH√äM V√ÄO: ID c·ªßa node hi·ªán t·∫°i trong c√¢y
  llmOptions: LLMOptions;
};
export interface LLMOptions {
  temperature?: number;
  maxTokens?: number;
  streaming?: boolean;
  contextWindow?: number;
  top_p?: number;
  responseLength?: number;
}

export type UserProfileType = {
  id: string;
  name: string; // T√™n hi·ªÉn th·ªã, s·∫Ω thay th·∫ø {{user}}

  // C√°c thu·ªôc t√≠nh m√¥ t·∫£ ƒë·ªÉ ƒë∆∞a v√†o prompt
  appearance?: string; // "M·ªôt ng∆∞·ªùi ƒë√†n √¥ng cao l·ªõn v·ªõi m√°i t√≥c ƒëen v√† ƒë√¥i m·∫Øt n√¢u."
  personality?: string; // "T√≠nh c√°ch tr·∫ßm l·∫∑ng, hay quan s√°t, nh∆∞ng r·∫•t quy·∫øt ƒëo√°n."
  background?: string; // "L√† m·ªôt c·ª±u binh, ƒëang t√¨m ki·∫øm s·ª± b√¨nh y√™n ·ªü th√†nh ph·ªë n√†y."

  // C√°c thu·ªôc t√≠nh tr·∫°ng th√°i ƒë·ªông
  currentStatus?: string; // "ƒêang c·∫£m th·∫•y m·ªát m·ªèi sau m·ªôt ng√†y d√†i."
  inventory?: string[]; // ["M·ªôt chi·∫øc ch√¨a kh√≥a c≈©", "B·ª©c ·∫£nh m·ªù"]
  createdAt: number;
};

export class DialogueMessage {
  parsedContent?: ParsedResponse;
  id: string;
  dialogueId: string;
  parentId: string | null;
  userInput: string;
  assistantResponse: string;
  status?: "pending" | "completed" | "failed"; // <-- TH√äM PROPERTY
  createdAt: number;

  constructor(data: DialogueMessageType) {
    this.parsedContent = data.parsedContent;
    this.id = data.id;
    this.dialogueId = data.dialogueId;
    this.parentId = data.parentId;
    this.userInput = data.userInput;
    this.assistantResponse = data.assistantResponse;
    this.status = data.status || "pending"; // <-- TH√äM V√ÄO CONSTRUCTOR
    this.createdAt = data.createdAt;
  }
}

export class Dialogue {
  id: string;
  createdAt: number;
  currentNodeId: string; // <-- TH√äM V√ÄO: ID c·ªßa node hi·ªán t·∫°i trong c√¢y
  llmOptions: LLMOptions;
  constructor(data: DialogType) {
    this.id = data.id;
    this.createdAt = data.createdAt;
    // this.messages = data.messages || [];
    this.llmOptions = data.llmOptions;
    this.currentNodeId = data.currentNodeId || "root";
  }
}

export class UserProfile {
  id: string;
  name: string;
  appearance?: string;
  personality?: string;
  background?: string;
  currentStatus?: string;
  inventory?: string[];
  createdAt: number;
  constructor(data: UserProfileType) {
    this.id = data.id;
    this.name = data.name;
    this.appearance = data.appearance;
    this.personality = data.personality;
    this.background = data.background;
    this.currentStatus = data.currentStatus;
    this.inventory = data.inventory;
    this.createdAt = data.createdAt;
  }
}

const UserProfiles = new Collection<UserProfileType>({
  name: "User_Profiles",
  reactivity: vueReactivityAdapter,
  persistence: createMonkeyAdapter("User_Profiles"),
  primaryKeyGenerator: () => crypto.randomUUID(),
  transform: (item) => new UserProfile(item),
});

const DialogueMessages = new Collection<DialogueMessageType>({
  name: "Dialogue_Messages",
  reactivity: vueReactivityAdapter,
  persistence: createIndexedDBAdapter("Dialogue_Messages"),
  primaryKeyGenerator: () => crypto.randomUUID(),
  transform: (item) => new DialogueMessage(item),
});

const Dialogues = new Collection<DialogType>({
  name: "Dialogues",
  reactivity: vueReactivityAdapter,
  persistence: createIndexedDBAdapter("Dialogues"),
  // primaryKeyGenerator: () => crypto.randomUUID(),
  transform: (item) => new Dialogue(item),
});

const Storage = new Collection<StorageType>({
  name: "Storage",
  reactivity: vueReactivityAdapter,
  persistence: createIndexedDBAdapter("Storage"),
  // primaryKeyGenerator: () => crypto.randomUUID(),
});
const CharacterCards = new Collection<CharacterCardType>({
  reactivity: vueReactivityAdapter,
  persistence: createMonkeyAdapter("Character_Cards"),
  primaryKeyGenerator: () => crypto.randomUUID(),
  transform: (item) => new CharacterCard(item),
});
const LLMModels = new Collection<LLMModel>({
  name: "LLM_Models",
  reactivity: vueReactivityAdapter,
  persistence: createMonkeyAdapter("LLM_Models"),
  primaryKeyGenerator: () => crypto.randomUUID(),
});

if (UserProfiles.find().count() === 0) {
  UserProfiles.insert({
    id: crypto.randomUUID(),
    name: "Roger",
    appearance: "M·ªôt ng∆∞·ªùi ƒë√†n √¥ng cao l·ªõn v·ªõi m√°i t√≥c ƒëen v√† ƒë√¥i m·∫Øt n√¢u.",
    personality: "T√≠nh c√°ch tr·∫ßm l·∫∑ng, hay quan s√°t, nh∆∞ng r·∫•t quy·∫øt ƒëo√°n.",
    background: "L√† m·ªôt c·ª±u binh, ƒëang t√¨m ki·∫øm s·ª± b√¨nh y√™n ·ªü th√†nh ph·ªë n√†y.",
    currentStatus: "ƒêang c·∫£m th·∫•y m·ªát m·ªèi sau m·ªôt ng√†y d√†i.",
    inventory: ["M·ªôt chi·∫øc ch√¨a kh√≥a c≈©", "B·ª©c ·∫£nh m·ªù"],
    createdAt: Date.now(),
  });
}

export const db = {
  CharacterCards,
  LLMModels,
  Storage,
  DialogueMessages,
  Dialogues,
  UserProfiles,
};
</file>

<file path="src/db/monkey.ts">
import { GM } from '$';
import { createPersistenceAdapter } from '@signaldb/core'

/**
 * Creates a persistence adapter for managing a SignalDB collection backed by Greasemonkey's storage.
 * This adapter uses GM.getValue and GM.setValue for data persistence.
 * @template T - The type of the items in the collection.
 * @param collectionName - The name of the collection, used as the key for storage.
 * @returns A SignalDB persistence adapter for managing data in Greasemonkey's storage.
 */
export default function createMonkeyAdapter<T extends { id: I }, I>(
  collectionName: string,
) {
  return createPersistenceAdapter<T, I>({
    async register() {
      // No-op. We don't need to watch for external changes in this simple adapter.
    },
    async load() {
      const serializedItems = await GM.getValue(collectionName, '[]')
      const items = JSON.parse(serializedItems as string) as T[]
      return { items }
    },
    async save(items) {
      const serializedItems = JSON.stringify(items)
      await GM.setValue(collectionName, serializedItems)
    },
  })

}
</file>

<file path="src/newDb/Character.ts">
// file: src/core/Character.ts

import type {
  CharacterCardData,
  RawSillyTavernData,
  WorldBookEntry,
} from "@/types/character";

/**
 * Class Character ƒë·∫°i di·ªán cho m·ªôt nh√¢n v·∫≠t trong ·ª©ng d·ª•ng.
 * Nhi·ªám v·ª• ch√≠nh l√† nh·∫≠n d·ªØ li·ªáu th√¥ t·ª´ character card v√† chu·∫©n h√≥a n√≥
 * th√†nh m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu nh·∫•t qu√°n (CharacterData) ƒë·ªÉ to√†n b·ªô ·ª©ng d·ª•ng s·ª≠ d·ª•ng.
 * Class n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ x·ª≠ l√Ω nhi·ªÅu bi·∫øn th·ªÉ c·ªßa ƒë·ªãnh d·∫°ng SillyTavern card.
 */
export class Character {
  public readonly data: CharacterCardData;

  constructor(
    rawData: RawSillyTavernData
  ) {
    if (!rawData) {
      throw new Error(
        "Character ID and raw data are required to create a Character instance."
      );
    }

    this.data = this.normalize(rawData);
  }

  /**
   * Ph∆∞∆°ng th·ª©c ch√≠nh ƒë·ªÉ chu·∫©n h√≥a d·ªØ li·ªáu t·ª´ th√¥ sang c·∫•u tr√∫c CharacterData.
   * ƒê√¢y l√† n∆°i x·ª≠ l√Ω c√°c c·∫•u tr√∫c d·ªØ li·ªáu kh√¥ng nh·∫•t qu√°n.
   * @param characterId - ID duy nh·∫•t cho nh√¢n v·∫≠t.
   * @param imageFile - File ch·ª©a avatar.
   * @param rawData - D·ªØ li·ªáu th√¥ ƒë·ªçc t·ª´ card.
   * @returns M·ªôt object CharacterData ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a.
   */
  /**
   * Helper method to sanitize and fix common JSON formatting issues
   * @param jsonString - The potentially malformed JSON string
   * @returns A sanitized JSON string that's more likely to be parsed successfully
   */
  private sanitizeJson(jsonString: string): string {
    let result = jsonString.trim();

    // Remove comments
    result = result.replace(/\/\/[^\n]*/g, '');
    result = result.replace(/\/\*[\s\S]*?\*\//g, '');

    // Replace single quotes with double quotes
    result = result.replace(/'/g, '"');

    // Add quotes to unquoted keys
    result = result.replace(/([{,])\s*([a-zA-Z0-9_]+)\s*:/g, '$1"$2":');

    // Add quotes to unquoted values, being careful not to quote numbers, booleans, or null
    result = result.replace(/:\s*([^"]{[\],}, \n\r\t]+)/g, (match, p1) => {
      if (p1 === 'null' || p1 === 'true' || p1 === 'false' || !isNaN(parseFloat(p1))) {
        return `: ${p1}`;
      }
      return `: "${p1}"`;
    });

    // Remove trailing commas
    result = result.replace(/,(\s*[}\]])/g, '$1');

    // Add missing commas between properties
    result = result.replace(/"(\s*\n\s*)"/g, '",$1"');

    return result;
  }

  private normalize(
    // characterId: string,
    // imageFile: File,
    rawData: RawSillyTavernData
  ): CharacterCardData {
    // ∆Øu ti√™n l·∫•y d·ªØ li·ªáu t·ª´ object 'data' l·ªìng nhau, n·∫øu kh√¥ng c√≥ th√¨ l·∫•y t·ª´ c·∫•p cao nh·∫•t.
    const source = rawData.data || (rawData as any);
    const topLevelSource = rawData as any;

    // 1. Tr√≠ch xu·∫•t th√¥ng tin t·ª´ c√°c tr∆∞·ªùng chu·∫©n tr∆∞·ªõc
    let description = source.description || topLevelSource.description || "";
    let personality = source.personality || topLevelSource.personality || "";
    const creatorNotes =
      source.creator_notes || topLevelSource.creatorcomment || "";

    // 2. Chu·∫©n h√≥a World Book
    const worldBookEntries = this.normalizeWorldBook(source.character_book);

    // 3. X·ª≠ l√Ω c√°c card "b·∫•t th∆∞·ªùng" nh·ªìi JSON v√†o content ho·∫∑c c√°c tr∆∞·ªùng kh√°c
    // C·ªë g·∫Øng t√¨m v√† ph√¢n t√≠ch c√∫ ph√°p JSON trong World Book content
    const entryWithJson = worldBookEntries.find((e) =>
      e.content.trim().startsWith("{")
    );
    if (entryWithJson) {
      try {
        // Sanitize the JSON content before parsing
        const jsonContent = this.sanitizeJson(entryWithJson.content);
        let embeddedJson;
        try {
          embeddedJson = JSON.parse(jsonContent);
        } catch (parseError) {
          console.warn(
            "JSON parsing failed even after sanitization:",
            parseError
          );
          console.debug(
            "Sanitized content that failed to parse:",
            jsonContent.substring(0, 300) + "..."
          );

          // Last resort: try to extract a valid JSON object using regex
          try {
            const jsonObjectMatch = jsonContent.match(/\{[^\{\}]*\}/g);
            if (jsonObjectMatch && jsonObjectMatch.length > 0) {
              console.debug(
                "Attempting to parse extracted JSON object:",
                jsonObjectMatch[0]
              );
              embeddedJson = JSON.parse(jsonObjectMatch[0]);
            } else {
              // Skip this entry if extraction fails, continue with normal processing
              embeddedJson = null; // Set to null to indicate extraction failed
              embeddedJson = null; // Set to null and skip further JSON processing
            }
          } catch (extractError) {
            console.warn("Failed to extract valid JSON:", extractError);
            // Skip this entry if all parsing attempts fail, continue with normal processing
            embeddedJson = null; // Set to null and skip further JSON processing
          }
        }
        // Skip processing if JSON extraction failed
        if (embeddedJson === null) {
          // Do nothing, continue with normal processing
        } else {
          // Card "Haru Saki" c√≥ c·∫•u tr√∫c `haru_profile`
          const embeddedProfile = embeddedJson.haru_profile || embeddedJson;

          // N·ªëi th√¥ng tin ƒë√£ gi·∫£i n√©n v√†o c√°c tr∆∞·ªùng ch√≠nh
          if (
            embeddedProfile.backstory &&
            Array.isArray(embeddedProfile.backstory)
          ) {
            const backstoryText = embeddedProfile.backstory.join("\n");
            description =
              `${description}\n\n**Backstory:**\n${backstoryText}`.trim();
          }

          if (embeddedProfile.traits?.personality) {
            let personalityText = "";
            for (const key in embeddedProfile.traits.personality) {
              const traits = embeddedProfile.traits.personality[key];
              if (Array.isArray(traits) && traits.length > 0) {
                personalityText += `\nAs ${key}: ${traits.join(", ")}.`;
              }
            }
            personality = `${personality}${personalityText}`.trim();
          }
        }
      } catch (e) {
        console.warn("Could not parse JSON content from world book entry.", e);
        // Log the problematic content for debugging
        console.debug(
          "Problematic JSON content:",
          entryWithJson.content.substring(0, 300) + "..."
        );
      }
    }

    // M·ªôt s·ªë card nh·ªìi JSON v√†o th·∫≥ng tr∆∞·ªùng description
    if (description.trim().startsWith("{")) {
      try {
        // Sanitize the JSON content before parsing
        const jsonContent = this.sanitizeJson(description);
        let embeddedJsonInDesc;
        try {
          embeddedJsonInDesc = JSON.parse(jsonContent);
        } catch (parseError) {
          console.warn(
            "JSON parsing in description failed even after sanitization:",
            parseError
          );
          console.debug(
            "Sanitized description that failed to parse:",
            jsonContent.substring(0, 300) + "..."
          );

          // Last resort: try to extract a valid JSON object using regex
          try {
            const jsonObjectMatch = jsonContent.match(/\{[^\{\}]*\}/g);
            if (jsonObjectMatch && jsonObjectMatch.length > 0) {
              console.debug(
                "Attempting to parse extracted JSON object from description:",
                jsonObjectMatch[0]
              );
              embeddedJsonInDesc = JSON.parse(jsonObjectMatch[0]);
            } else {
              // Skip JSON extraction if it fails, continue with normal processing
              embeddedJsonInDesc = null; // Set to null to indicate extraction failed
              embeddedJsonInDesc = null; // Set to null and continue normal processing
            }
          } catch (extractError) {
            console.warn(
              "Failed to extract valid JSON from description:",
              extractError
            );
            // Skip this processing if all parsing attempts fail, continue with normal processing
          }
        }
        // Skip processing if JSON extraction failed
        if (embeddedJsonInDesc === null) {
          // Do nothing, continue with normal processing
        } else {
          // Gi·∫£ s·ª≠ c√≥ c·∫•u tr√∫c roleplay_instruction nh∆∞ trong v√≠ d·ª• c·ªßa b·∫°n
          if (embeddedJsonInDesc && embeddedJsonInDesc.roleplay_instruction) {
            // B·∫°n c√≥ th·ªÉ ch·ªçn gi·ªØ l·∫°i ho·∫∑c lo·∫°i b·ªè n√≥. ·ªû ƒë√¢y ta lo·∫°i b·ªè ƒë·ªÉ gi·ªØ description s·∫°ch s·∫Ω.
            description = creatorNotes; // Thay th·∫ø b·∫±ng creator_notes v√¨ n√≥ ch·ª©a m√¥ t·∫£ d·ªÖ ƒë·ªçc h∆°n
          }
        }
      } catch (e) {
        /* B·ªè qua l·ªói parsing, gi·ªØ nguy√™n description */
        console.debug("Could not parse JSON in description:", e);
      }
    }

    // 4. X√¢y d·ª±ng object CharacterData cu·ªëi c√πng
    const normalizedData: CharacterCardData = {
    //   id: characterId,
    //   imageFile: imageFile,

      name: source.name || topLevelSource.name || "Unnamed Character",
      description: description.trim(),
      personality: personality.trim(),
      scenario: source.scenario || topLevelSource.scenario || "",

      firstMessage: source.first_mes || topLevelSource.first_mes || "",
      alternateGreetings: source.alternate_greetings || [],
      messageExamples: source.mes_example || topLevelSource.mes_example || "",

      creatorNotes: creatorNotes,
      tags: source.tags || [],
      creator: source.creator || "",

      worldBook: worldBookEntries,
    };

    return normalizedData;
  }

  /**
   * Chu·∫©n h√≥a d·ªØ li·ªáu World Book t·ª´ c√°c ƒë·ªãnh d·∫°ng kh√°c nhau (array ho·∫∑c object).
   * @param characterBook - Object character_book t·ª´ d·ªØ li·ªáu th√¥.
   * @returns M·ªôt m·∫£ng c√°c WorldBookEntry ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a.
   */
  private normalizeWorldBook(characterBook: any): WorldBookEntry[] {
    if (!characterBook || !characterBook.entries) {
      return [];
    }

    const entriesSource = characterBook.entries;
    let entriesArray: any[] = [];

    if (Array.isArray(entriesSource)) {
      entriesArray = entriesSource;
    } else if (typeof entriesSource === "object" && entriesSource !== null) {
      entriesArray = Object.values(entriesSource);
    }

    return entriesArray.map((entry) => ({
      // X·ª≠ l√Ω keys, ƒë·∫£m b·∫£o lu√¥n l√† m·ªôt m·∫£ng chu·ªói
      keys:
        entry.keys ||
        (entry.key ? (Array.isArray(entry.key) ? entry.key : [entry.key]) : []),
      content: entry.content || "",
      comment: entry.comment || "",
      // X·ª≠ l√Ω enabled/disable, ∆∞u ti√™n `disable` n·∫øu c√≥
      enabled: entry.disable === true ? false : entry.enabled !== false,
      // X·ª≠ l√Ω position
      position: this.normalizePosition(entry.position),
      // X·ª≠ l√Ω insertion_order, h·ªó tr·ª£ c·∫£ `order`
      insertionOrder: entry.insertion_order ?? entry.order ?? 0,
      // C√°c thu·ªôc t√≠nh boolean kh√°c
      selective: entry.selective === true,
      constant: entry.constant === true,
      useRegex: entry.use_regex === true,
      // C√°c thu·ªôc t√≠nh s·ªë
      depth: entry.depth ?? 1,
      // X·ª≠ l√Ω secondary_keys, h·ªó tr·ª£ c·∫£ `keysecondary`
      secondaryKeys: entry.secondary_keys || entry.keysecondary || [],
    }));
  }

  /**
   * Chu·∫©n h√≥a gi√° tr·ªã 'position' c·ªßa World Book sang m·ªôt ƒë·ªãnh d·∫°ng chu·ªói d·ªÖ ƒë·ªçc.
   */
  private normalizePosition(
    position: number | string | undefined
  ): WorldBookEntry["position"] {
    const posNum = Number(position);
    if (isNaN(posNum)) return "after_char"; // M·∫∑c ƒë·ªãnh an to√†n

    switch (posNum) {
      case 0:
        return "before_char";
      case 1:
        return "after_char";
      case 2:
        return "before_input";
      case 3:
        return "after_input";
      default:
        return "after_char";
    }
  }

  /**
   * L·∫•y l·ªùi ch√†o ƒë·∫ßu ti√™n, ∆∞u ti√™n alternate greetings.
   */

}
</file>

<file path="src/newDb/index.ts">
import { CharacterCardData } from "@/types/character";
import Dexie, { type EntityTable } from "dexie";

export class CharacterCard {
  id: string;
  data: Partial<CharacterCardData>;
  dataTranslated?: Partial<CharacterCardData>;
  isUseTranslated: boolean;
  imageFile?: File;
  createdAt: number;

  constructor(
    data: Partial<CharacterCardData>,
    imageFile?: File,
    createdAt?: number
  ) {
    this.id = crypto.randomUUID();
    this.data = data;
    this.isUseTranslated = false;
    this.imageFile = imageFile;
    this.createdAt = createdAt || Date.now();
  }

  getData(): Partial<CharacterCardData> {
    if (this.isUseTranslated) {
      return Object.assign({}, this.data, this.dataTranslated);
    }
    return this.data;
  }
  public getGreeting(): string {
    if (
      this.data.alternateGreetings &&
      this.data.alternateGreetings.length > 0
    ) {
      const randomIndex = Math.floor(
        Math.random() * this.data.alternateGreetings.length
      );
      return this.data.alternateGreetings[randomIndex];
    }
    return this.data.firstMessage ?? "";
  }
}

export type LLMModel = {
  id: string;
  name: string;
  apiKey: string;
  baseUrl: string;
  modelName: string;
  llmProvider: string;
  isDefault: boolean;
  createdAt: number;
};

const mianixDb = new Dexie("mianix-db") as Dexie & {
  characterCards: EntityTable<
    CharacterCard,
    "id" // primary key "id" (for the typings only)
  >;
  llmModels: EntityTable<
    LLMModel,
    "id" // primary key "id" (for the typings only)
  >;
};

mianixDb.version(1).stores({
  characterCards: "id, createdAt",
  llmModels: "id, createdAt",
});

mianixDb.version(2).stores({
  characterCards: "id, createdAt",
  llmModels: "id, isDefault, createdAt",
});

mianixDb.characterCards.mapToClass(CharacterCard);

export { mianixDb };
</file>

<file path="src/stores/app.ts">
import { db } from '@/db';
import { defineStore } from 'pinia';

export const useAppStore = defineStore('app', {
  state: () => ({
    isReady: false, // Add this line
    isDarkMode: false,
    currentProfile: db.UserProfiles.findOne({})
  }),
  getters: {
    getIsDarkMode: (state) => state.isDarkMode,
  },
  actions: {
    setReady(isReady: boolean) { // Add this action
      this.isReady = isReady;
    },
    setIsDarkMode(isDarkMode: boolean) {
      this.isDarkMode = isDarkMode;
    },
  },
});
</file>

<file path="src/stores/dialogue.ts">
// src/stores/dialogue.ts
import { defineStore } from "pinia";
import {
  CharacterCard,
  db,
  type Dialogue,
  type DialogueMessageType,
} from "@/db";
import { adaptText } from "@/utils/msg-process";
import { LLMOptions } from "@/db";

interface DialogueState {
  currentDialogue: Dialogue | null;
  currentMessages: DialogueMessageType[];
  suggestedPrompts: Record<string, string[]>;
  currentLLMOptions: Record<string, LLMOptions>;
}

export const useDialogueStore = defineStore("dialogue", {
  state: (): DialogueState => ({
    currentDialogue: null,
    currentMessages: [],
    suggestedPrompts: {},
    currentLLMOptions: {}
  }),
  getters: {
    // Getter quan tr·ªçng: L·∫•y ƒë∆∞·ªùng d·∫´n t·ª´ node hi·ªán t·∫°i v·ªÅ g·ªëc
    currentPath(state): DialogueMessageType[] {
      if (!state.currentDialogue || state.currentMessages.length === 0)
        return [];

      const path: DialogueMessageType[] = [];
      const messagesMap = new Map(state.currentMessages.map((m) => [m.id, m]));
      let currentNodeId: string | null = state.currentDialogue.currentNodeId;

      // // Debug logs
      // console.log("üîç Debug currentPath:");
      // console.log("currentNodeId:", currentNodeId);
      // console.log("messagesMap size:", messagesMap.size);
      // console.log(
      //   "all messages:",
      //   Array.from(messagesMap.values()).map((m) => ({
      //     id: m.id,
      //     parentId: m.parentId,
      //   }))
      // );

      while (currentNodeId && currentNodeId !== "root") {
        const node = messagesMap.get(currentNodeId);
        // console.log("Processing node:", currentNodeId, "found:", !!node);

        if (node) {
          path.unshift(node);
          currentNodeId = node.parentId;
          // console.log("Added to path, next parentId:", currentNodeId);
        } else {
          console.log("‚ùå Node not found, breaking");
          break;
        }
      }

      console.log("‚úÖ Final path length:", path.length);
      return path;
    },
    // Getter ch·ªâ l·∫•y t·ªëi ƒëa 10 tin nh·∫Øn m·ªõi nh·∫•t cho vi·ªác hi·ªÉn th·ªã, 
    currentMessagesForDisplay(_state): DialogueMessageType[] {
      return (this as any).currentPath.slice(-10);
    },
    // Getter ƒë·ªÉ l·∫•y l·ªãch s·ª≠ chat d∆∞·ªõi d·∫°ng chu·ªói cho prompt
    completedPath(_state): DialogueMessageType[] {
      return (this as any).currentPath.filter(
        (node: DialogueMessageType) => node.status === "completed"
      );
    },

    chatHistoryForPrompt(_state): string {
      const path = (this as any).completedPath as DialogueMessageType[];
      return path
        .map((node) => {
          let history = "";
          if (node.userInput) {
            history += `User: ${node.userInput}\n`;
          }
          if (node.assistantResponse) {
            history += `AI: ${node.assistantResponse}\n`;
          }
          return history;
        })
        .join("\n");
    },
  },
  actions: {
    // T·∫£i d·ªØ li·ªáu c·ªßa m·ªôt cu·ªôc h·ªôi tho·∫°i v√†o store
    loadDialogue(characterId: string) {
      this.currentDialogue = db.Dialogues.findOne({
        id: characterId,
      }) as Dialogue | null;
      if (this.currentDialogue) {
        this.currentMessages = db.DialogueMessages.find({
          dialogueId: characterId,
        }).fetch() as DialogueMessageType[];
        console.log(
          "üì• Loaded dialogue:",
          characterId,
          "messages:",
          this.currentMessages.length
        );
        this.suggestedPrompts[characterId] = [];
        this.currentLLMOptions[characterId] = Object.assign({
          top_p: 0.9,
          responseLength: 800
        }, this.currentDialogue.llmOptions);
      } else {
        // N·∫øu ch∆∞a c√≥, t·∫°o m·ªõi
        const newDialogue: Dialogue = {
          id: characterId,
          createdAt: Date.now(),
          llmOptions: {
            top_p: 0.9,
            temperature: 0.7,
            maxTokens: 1000,
            contextWindow: 4000,
            responseLength: 800
          },
          currentNodeId: "root",
        };
        db.Dialogues.insert(newDialogue);
        this.suggestedPrompts[characterId] = [];
        this.currentLLMOptions[characterId] = newDialogue.llmOptions;
        const characterCard = db.CharacterCards.findOne({
          id: characterId,
        }) as CharacterCard;
        characterCard.getData();
        let firstGreeting = characterCard.getGreeting() as string;
        firstGreeting = adaptText(firstGreeting);

        // T·∫°o message ƒë·∫ßu ti√™n
        const firstMessageId = crypto.randomUUID();
        db.DialogueMessages.insert({
          id: firstMessageId,
          dialogueId: newDialogue.id,
          parentId: "root",
          userInput: "",
          assistantResponse: firstGreeting,
          status: "completed",
          createdAt: Date.now(),
        });

        // üîß FIX: C·∫≠p nh·∫≠t currentNodeId ƒë·ªÉ tr·ªè ƒë·∫øn message v·ª´a t·∫°o
        db.Dialogues.updateOne(
          { id: characterId },
          { $set: { currentNodeId: firstMessageId } }
        );

        // C·∫≠p nh·∫≠t state
        newDialogue.currentNodeId = firstMessageId;
        this.currentDialogue = newDialogue;
        this.currentMessages = db.DialogueMessages.find({
          dialogueId: characterId,
        }).fetch() as DialogueMessageType[];
        console.log("üÜï Created new dialogue:", characterId);
      }
    },

    // Th√™m m·ªôt node m·ªõi v√†o c√¢y
    addMessage(userInput: string, assistantResponse: string) {
      if (!this.currentDialogue) return;

      const newNode: DialogueMessageType = {
        id: crypto.randomUUID(),
        dialogueId: this.currentDialogue.id,
        parentId: this.currentDialogue.currentNodeId,
        userInput,
        assistantResponse,
        createdAt: Date.now(),
      };

      console.log("‚ûï Adding message:", {
        id: newNode.id,
        parentId: newNode.parentId,
      });

      db.DialogueMessages.insert(newNode);

      // C·∫≠p nh·∫≠t currentNodeId trong Dialogue
      db.Dialogues.updateOne(
        { id: this.currentDialogue.id },
        {
          $set: { currentNodeId: newNode.id },
        }
      );

      // C·∫≠p nh·∫≠t state
      this.currentMessages.push(newNode);
      this.currentDialogue.currentNodeId = newNode.id;

      console.log("‚úÖ Message added, new currentNodeId:", newNode.id);
    },

    // Chuy·ªÉn nh√°nh
    switchBranch(nodeId: string) {
      if (!this.currentDialogue) return;

      db.Dialogues.updateOne(
        { id: this.currentDialogue.id },
        {
          $set: { currentNodeId: nodeId },
        }
      );

      this.currentDialogue.currentNodeId = nodeId;
    },

    // T√°i t·∫°o ph·∫£n h·ªìi
    regenerate() {
      if (
        !this.currentDialogue ||
        this.currentDialogue.currentNodeId === "root"
      )
        return;

      const currentNode = this.currentMessages.find(
        (m) => m.id === this.currentDialogue?.currentNodeId
      );
      if (!currentNode || !currentNode.parentId) return null;

      // üÜï Ki·ªÉm tra status c·ªßa node hi·ªán t·∫°i
      if (currentNode.status === "pending") {
        // N·∫øu ƒëang pending, ch·ªâ c·∫ßn cancel v√† x√≥a
        console.log("üö´ Canceling pending request");

        db.DialogueMessages.removeOne({ id: currentNode.id });
        this.currentMessages = this.currentMessages.filter(
          (m) => m.id !== currentNode.id
        );
        this.switchBranch(currentNode.parentId);

        return null; // Kh√¥ng c·∫ßn regenerate
      }

      // üÜï N·∫øu completed ho·∫∑c failed, regenerate nh∆∞ c≈©
      if (
        currentNode.status === "completed" ||
        currentNode.status === "failed"
      ) {
        console.log("üîÑ Regenerating response for:", currentNode.userInput);

        db.DialogueMessages.removeOne({ id: currentNode.id });
        this.currentMessages = this.currentMessages.filter(
          (m) => m.id !== currentNode.id
        );
        this.switchBranch(currentNode.parentId);

        return currentNode.userInput; // Tr·∫£ v·ªÅ ƒë·ªÉ g·ª≠i l·∫°i
      }

      return null;
    },

    // üóëÔ∏è Action m·ªõi: X√≥a to√†n b·ªô d·ªØ li·ªáu dialogue
    clearAllData(characterId: string) {
      console.log("üóëÔ∏è Clearing all data for:", characterId);

      // X√≥a t·∫•t c·∫£ messages
      db.DialogueMessages.removeOne({ id: characterId });

      // X√≥a dialogue
      db.Dialogues.removeOne({ id: characterId });

      // Reset state
      this.currentDialogue = null;
      this.currentMessages = [];
      this.suggestedPrompts = {
        [characterId]: [],
      };

      console.log("‚úÖ All data cleared");
    },

    // üîÑ Action m·ªõi: Reset dialogue v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
    resetDialogue(characterId: string) {
      this.clearAllData(characterId);
      this.loadDialogue(characterId);
    },

    // üÜï Action m·ªõi: Th√™m user input v·ªõi status pending
    addInput(input: string, isUserInput: boolean = true) {
      if (!this.currentDialogue) return;

      const newNode: DialogueMessageType = {
        id: crypto.randomUUID(),
        dialogueId: this.currentDialogue.id,
        parentId: this.currentDialogue.currentNodeId,
        userInput: isUserInput ? input : "",
        assistantResponse: !isUserInput ? input : "", // ƒê·ªÉ tr·ªëng
        status: "pending", // ƒê√°nh d·∫•u ƒëang ch·ªù
        createdAt: Date.now(),
      };

      console.log("‚ûï Adding pending user input:", {
        id: newNode.id,
        parentId: newNode.parentId,
      });

      db.DialogueMessages.insert(newNode);

      // C·∫≠p nh·∫≠t currentNodeId trong Dialogue
      db.Dialogues.updateOne(
        { id: this.currentDialogue.id },
        {
          $set: { currentNodeId: newNode.id },
        }
      );

      // C·∫≠p nh·∫≠t state
      this.currentMessages.push(newNode);
      this.currentDialogue.currentNodeId = newNode.id;

      console.log(
        "‚úÖ Pending user input added, new currentNodeId:",
        newNode.id
      );
      return newNode.id; // Tr·∫£ v·ªÅ ID ƒë·ªÉ update sau
    },

    // üÜï Action m·ªõi: C·∫≠p nh·∫≠t AI response
    updateAIResponse(nodeId: string, assistantResponse: string) {
      if (!this.currentDialogue) return;

      console.log("üîÑ Updating AI response for node:", nodeId);

      // Update trong database
      db.DialogueMessages.updateOne(
        { id: nodeId },
        {
          $set: {
            assistantResponse,
            status: "completed",
          },
        }
      );

      // Update trong state
      const messageIndex = this.currentMessages.findIndex(
        (m) => m.id === nodeId
      );
      if (messageIndex !== -1) {
        this.currentMessages[messageIndex].assistantResponse =
          assistantResponse;
        this.currentMessages[messageIndex].status = "completed";
      }

      console.log("‚úÖ AI response updated");
    },

    // üÜï Action m·ªõi: ƒê√°nh d·∫•u failed khi c√≥ l·ªói
    markAsFailed(nodeId: string) {
      if (!this.currentDialogue) return;

      db.DialogueMessages.updateOne(
        { id: nodeId },
        {
          $set: { status: "failed" },
        }
      );

      const messageIndex = this.currentMessages.findIndex(
        (m) => m.id === nodeId
      );
      if (messageIndex !== -1) {
        this.currentMessages[messageIndex].status = "failed";
      }
    },

    // üÜï Function m·ªõi: Retry message b·ªã failed
    retryMessage(nodeId: string) {
      const node = this.currentMessages.find((m) => m.id === nodeId);
      if (!node) return null;

      // console.log("üîÑ Retrying failed message:", node.userInput);

      // Reset v·ªÅ pending
      db.DialogueMessages.updateOne(
        { id: nodeId },
        {
          $set: {
            status: "pending",
            assistantResponse: "", // Clear response c≈©
          },
        }
      );

      // Update state
      const messageIndex = this.currentMessages.findIndex(
        (m) => m.id === nodeId
      );
      if (messageIndex !== -1) {
        this.currentMessages[messageIndex].status = "pending";
        this.currentMessages[messageIndex].assistantResponse = "";
      }

      return node.userInput; // Tr·∫£ v·ªÅ ƒë·ªÉ g·ª≠i l·∫°i
    },
    updateMessage(messageId: string, content: string, isAssistant: boolean) {
      db.DialogueMessages.updateOne({ id: messageId }, {
        $set: {
          [isAssistant ? 'assistantResponse' : 'userInput']: content,
        }
      })
      this.currentMessages.find(m => m.id === messageId)![isAssistant ? 'assistantResponse' : 'userInput'] = content
    },
    updateLLMOptions(characterId: string, options: LLMOptions) {
      this.currentLLMOptions[characterId] = options;
      db.Dialogues.updateOne(
        { id: characterId },
        {
          $set: {
            llmOptions: options,
          },
        }
      );
    },
  },
  persist: {
    storage: localStorage,
    pick: ["suggestedPrompts"],
  },
});
</file>

<file path="src/stores/modal.ts">
import { defineStore } from 'pinia'
import { MODALS } from '@/constants'

export const useModalStore = defineStore('modal', {
  state: () => ({
    currentModal: '',
    modalData: null as any
  }),
  
  getters: {
    isModalOpen: (state) => {
      return (modalName: string): boolean => {
        console.log('currentModal', state.currentModal)
        if(!state.currentModal) {
          return false
        }
        if(modalName) {
          return modalName === state.currentModal
        }
        return Object.values(MODALS).includes(state.currentModal)
      }
    }
  },
  
  actions: {
    openModal(modal: string, data: any = null) {
      this.currentModal = modal
      this.modalData = data
    },
    
    closeModal() {
      this.currentModal = ''
      this.modalData = null
    },
  }
})
</file>

<file path="src/stores/resources.ts">
import { getLLMProviders, getPresetResouce } from '@/utils/common';
import { defineStore } from 'pinia';

export interface LLMProviderNameBaseUrl {
  name: string;
  baseUrl: string;
  models: string[];
}


// export interface LLMProviderRemote extends LLMProviderNameBaseUrl {
//     modelName: string;
//     apiKey: string;
// }

export const useResourcesStore = defineStore('resources', {
  state: () => ({
    llmProviders: [],
    translatePrompt: '',
    multiModePrompt: '',
    multiModeChainOfThoughtPrompt: '',
    compressorPrompt: '',
    statusPrompt: '',
    outputStructureSoftGuidePrompt: '',
    outputFormatPrompt: '',
    extractorCharacterPrompt: '',
  }),
  getters: {
    llmProviders_NameAndBaseUrl: (state): LLMProviderNameBaseUrl[] => {
      if (!state.llmProviders || !Array.isArray(state.llmProviders)) {
        return [];
      }
      return (state.llmProviders as any[]).map((provider) => ({
        name: provider.name,
        baseUrl: provider.baseUrl,
        models: provider.models.map((model: any) => model.name),
      })) as LLMProviderNameBaseUrl[];
    },
  },
  actions: {
    async fetchResources() {
      const llmProviders = await getLLMProviders();
      this.llmProviders = llmProviders.providers;
      this.translatePrompt = await getPresetResouce('TRANSLATE_PROMPT.txt', 'text', true);
      this.multiModePrompt = await getPresetResouce('MULTI_MODE_PROMPT.txt', 'text', true);
      this.multiModeChainOfThoughtPrompt = await getPresetResouce('MULTI_MODE_CHAIN_OF_THOUGHT_PROMPT.txt', 'text', true);
      this.compressorPrompt = await getPresetResouce('COMPRESSOR_PROMPT.txt', 'text', true);
      this.statusPrompt = await getPresetResouce('STATUS_PROMPT.txt', 'text', true);
      this.outputStructureSoftGuidePrompt = await getPresetResouce('OUTPUT_STRUCTURE_SOFT_GUIDE_PROMPT.txt', 'text', true);
      this.outputFormatPrompt = await getPresetResouce('OUTPUT_FORMAT_PROMPT.txt', 'text', true);
      this.extractorCharacterPrompt = await getPresetResouce('EXTRACTOR_CHARACTER_PROMPT.txt', 'text', true);
    },
  },
});
</file>

<file path="src/stores/screen.ts">
import { defineStore } from 'pinia'
import { SCREENS } from '@/constants'
import CharacterList from '@/components/character_cards/Index.vue'
import CharacterTranslate from '@/components/character_cards/Translate.vue'
import ChatScreen from '@/components/chat_screen/ChatScreen.vue'
import LlmModelsList from '@/components/llm_models/LLMIndex.vue'
import PresetConfig from '@/components/PresetConfig.vue'
import ProfileList from '@/components/profile/ProfileList.vue'

export const useScreenStore = defineStore('screen', {
  state: () => ({
    currentScreen: localStorage.getItem('currentScreen') || SCREENS.PROFILE_LIST,
    screenPayload: null as any,
  }),
  
  actions: {
    setScreen(screen: string, payload: any = null) {
      this.currentScreen = screen
      this.screenPayload = payload
    }
  },
  getters: {
    currentComponent: (state) => {
      switch (state.currentScreen) {
        case SCREENS.CHARACTER_LIST:
          return CharacterList;
        case SCREENS.CHARACTER_TRANSLATE:
          return CharacterTranslate;
        case SCREENS.CHAT:
          return ChatScreen;
        case SCREENS.MODELS_LIST:
          return LlmModelsList;
        case SCREENS.PRESETS_CONFIG:
          return PresetConfig;
        default:
          return CharacterList;
      }
    }
  },
  persist: true
})
</file>

<file path="src/types/character.d.ts">
// file: src/types/character.d.ts

/**
 * Interface cho m·ªôt m·ª•c trong World Book.
 * ƒê·∫°i di·ªán cho m·ªôt m·∫©u th√¥ng tin v·ªÅ th·∫ø gi·ªõi, nh√¢n v·∫≠t, ho·∫∑c s·ª± ki·ªán.
 */
export interface WorldBookEntry {
  // C√°c thu·ªôc t√≠nh c∆° b·∫£n
  keys: string[];
  content: string;
  comment?: string; // Ghi ch√∫ ho·∫∑c ti√™u ƒë·ªÅ c·ªßa entry
  enabled?: boolean;

  // Thu·ªôc t√≠nh n√¢ng cao ƒë·ªÉ ki·ªÉm so√°t vi·ªác ch√®n v√†o prompt
  position?: 'before_char' | 'after_char' | 'before_input' | 'after_input';
  insertionOrder?: number; // ∆Øu ti√™n ch√®n, s·ªë nh·ªè h∆°n ƒë∆∞·ª£c ∆∞u ti√™n
  
  // Thu·ªôc t√≠nh cho logic n√¢ng cao
  selective?: boolean; // Ch·ªâ k√≠ch ho·∫°t n·∫øu key ƒë∆∞·ª£c t√¨m th·∫•y trong ng·ªØ c·∫£nh g·∫ßn ƒë√¢y
  constant?: boolean;  // Lu√¥n ƒë∆∞·ª£c ch√®n v√†o prompt n·∫øu enabled
  useRegex?: boolean;  // S·ª≠ d·ª•ng keys nh∆∞ c√°c bi·ªÉu th·ª©c ch√≠nh quy (regex)
  
  // C√°c thu·ªôc t√≠nh k·∫ø th·ª´a t·ª´ SillyTavern ƒë·ªÉ t∆∞∆°ng th√≠ch
  depth?: number;
  secondaryKeys?: string[];
}

/**
 * Interface cho d·ªØ li·ªáu nh√¢n v·∫≠t ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a (s·ª≠ d·ª•ng camelCase).
 * ƒê√¢y l√† c·∫•u tr√∫c d·ªØ li·ªáu ch√≠nh m√† ·ª©ng d·ª•ng c·ªßa b·∫°n s·∫Ω l√†m vi·ªác sau khi ƒë√£ x·ª≠ l√Ω d·ªØ li·ªáu th√¥.
 */
export interface CharacterCardData {
  // id: string;
  // imageFile?: File; // ƒê∆∞·ªùng d·∫´n t·ªõi ·∫£nh avatar l∆∞u trong IndexedDB/local storage

  // Th√¥ng tin c·ªët l√µi cho prompt
  name: string;
  description: string;
  personality: string;
  scenario: string;
  firstMessage: string;
  messageExamples: string;
  alternateGreetings: string[];
  
  // Th√¥ng tin b·ªï sung
  creatorNotes?: string;
  tags?: string[];
  creator?: string;

  // D·ªØ li·ªáu c·∫•u tr√∫c
  worldBook: WorldBookEntry[];
  // B·∫°n c√≥ th·ªÉ th√™m c√°c tr∆∞·ªùng kh√°c nh∆∞ regexScripts ·ªü ƒë√¢y n·∫øu c·∫ßn
  // regexScripts?: any[]; 
}

/**
 * Interface cho d·ªØ li·ªáu th√¥ ƒë·ªçc t·ª´ file PNG c·ªßa SillyTavern.
 * S·ª≠ d·ª•ng snake_case ƒë·ªÉ kh·ªõp v·ªõi ƒë·ªãnh d·∫°ng g·ªëc.
 * C√≥ c·∫•u tr√∫c l·ªìng nhau ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi nhi·ªÅu phi√™n b·∫£n card.
 */
export interface RawSillyTavernData {
  // D·ªØ li·ªáu c√≥ th·ªÉ ·ªü c·∫•p cao nh·∫•t
  name?: string;
  description?: string;
  personality?: string;
  scenario?: string;
  first_mes?: string;
  mes_example?: string;
  creatorcomment?: string; // Ch√∫ √Ω t√™n n√†y kh√¥ng theo quy t·∫Øc
  
  // Ho·∫∑c l·ªìng trong m·ªôt object 'data'
  data?: {
    name?: string;
    description?: string;
    personality?: string;
    scenario?: string;
    first_mes?: string;
    mes_example?: string;
    
    // C√°c tr∆∞·ªùng chi ti·∫øt h∆°n
    creator_notes?: string;
    system_prompt?: string;
    post_history_instructions?: string;
    tags?: string[];
    creator?: string;
    character_version?: string;
    alternate_greetings?: string[];
    
    // World Book g·ªëc
    character_book?: {
      entries: WorldBookEntry[] | Record<string, any>;
    };

    // C√°c ph·∫ßn m·ªü r·ªông
    extensions?: {
      [key: string]: any; // ƒê·ªÉ b·∫Øt c√°c tr∆∞·ªùng m·ªü r·ªông nh∆∞ regex_scripts
    };
  };
}
</file>

<file path="src/utils/character-parser.ts">
import extract from "png-chunks-extract";
import encode from "png-chunks-encode";
import PNGtext from "png-chunk-text";

const encodeBase64 = (str: string): string => {
  const utf8Bytes = new TextEncoder().encode(str);
  const binary = String.fromCharCode(...utf8Bytes);
  return btoa(binary);
};

const decodeBase64 = (b64: string): string => {
  const binary = atob(b64);
  const bytes = new Uint8Array([...binary].map(char => char.charCodeAt(0)));
  return new TextDecoder().decode(bytes);
};

/**
 * Helper function to sanitize and fix common JSON formatting issues
 * @param jsonString - The potentially malformed JSON string
 * @returns A sanitized JSON string that's more likely to be parsed successfully
 */
const sanitizeJson = (jsonString: string): string => {
  let result = jsonString;
  
  // Replace single quotes with double quotes for property names and string values
  result = result.replace(/([{,]\s*)(')?([a-zA-Z0-9_]+)(')?(\s*:)/g, '$1"$3"$5');
  
  // Replace unquoted string values with quoted ones
  result = result.replace(/:\s*'([^']*)'/g, ':"$1"');
  
  // Fix trailing commas in objects and arrays
  result = result.replace(/,\s*([\]}])/g, '$1');
  
  // Fix missing quotes around string values
  result = result.replace(/:\s*([a-zA-Z][a-zA-Z0-9_]*)(\s*[,}\]])/g, ':"$1"$2');
  
  // Fix newlines in string values
  result = result.replace(/"([^"]*)\n([^"]*)"/, '"$1\\n$2"');
  
  // Fix unescaped quotes in string values
  result = result.replace(/([^\\])"([^"]*)"([^"]*)"/, '$1"$2\\"$3"');
  
  // Fix missing commas between properties
  result = result.replace(/("[^"]*"|\d+)\s*\n\s*("[a-zA-Z0-9_]+"\s*:)/g, '$1,\n$2');
  
  // Remove comments
  result = result.replace(/\/\/.*\n/g, '\n');
  result = result.replace(/\/\*[\s\S]*?\*\//g, '');
  
  return result;
};

export const writeCharacterToPng = async (file: File, data: string): Promise<Blob> => {
  const buffer = new Uint8Array(await file.arrayBuffer());
  const chunks = extract(buffer);

  const filteredChunks = chunks.filter(chunk => {
    if (chunk.name !== "tEXt") return true;
    const { keyword } = PNGtext.decode(chunk.data);
    return !["chara", "ccv3"].includes(keyword.toLowerCase());
  });

  const base64Data = encodeBase64(data);
  filteredChunks.splice(-1, 0, PNGtext.encode("chara", base64Data));

  try {
    const v3Data = JSON.parse(data);
    v3Data.spec = "chara_card_v3";
    v3Data.spec_version = "3.0";
    const base64V3 = encodeBase64(JSON.stringify(v3Data));
    filteredChunks.splice(-1, 0, PNGtext.encode("ccv3", base64V3));
  } catch (err) {
    console.warn("Failed to add ccv3 chunk:", err);
  }

  const newBuffer = encode(filteredChunks);
  return new Blob([newBuffer], { type: "image/png" });
};

export const readCharacterFromPng = async (file: File): Promise<any> => {
  const buffer = new Uint8Array(await file.arrayBuffer());
  const chunks = extract(buffer);

  const textChunks = chunks
    .filter(chunk => chunk.name === "tEXt")
    .map(chunk => PNGtext.decode(chunk.data));

  const ccv3 = textChunks.find(c => c.keyword.toLowerCase() === "ccv3");
  const chara = textChunks.find(c => c.keyword.toLowerCase() === "chara");

  const raw = ccv3?.text || chara?.text;
  if (!raw) throw new Error("No PNG metadata found.");

  try {
    // Gi·∫£i m√£ Base64 v√† parse JSON
    const decodedText = decodeBase64(raw);
    try {
      return JSON.parse(decodedText);
    } catch (parseError) {
      console.warn("Initial JSON parsing failed, attempting to sanitize:", parseError);
      
      // Sanitize the JSON content before parsing
      const sanitized = sanitizeJson(decodedText);
      return JSON.parse(sanitized);
    }
  } catch (error: unknown) {
    console.error("Error parsing character data:", error);
    // X·ª≠ l√Ω error m·ªôt c√°ch an to√†n v·ªõi ki·ªÉu unknown
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to parse character data: ${errorMessage}`);
  }
};

export const parseCharacterCard = async (file: File) => {
  if (!file.name.toLowerCase().endsWith(".png")) {
    throw new Error("Unsupported format");
  }
  // readCharacterFromPng ƒë√£ th·ª±c hi·ªán JSON.parse n√™n kh√¥ng c·∫ßn parse l·∫°i
  return await readCharacterFromPng(file);
};
</file>

<file path="src/utils/common.ts">
import { LLM_PROVIDERS_API, SERVER_BASE_URL } from '@/constants';
import { fetchAndCached, FetchCachedOption } from './gm-helper';
// import { RawCharacterData } from '@/newDb';
export async function getLLMProviders(isForced: boolean = false) {
  const options: FetchCachedOption = {
    apiURL: LLM_PROVIDERS_API,
    apiType: "json",
    nameOfCache: "mianix:llm_providers",
  }
  return await fetchAndCached(options, isForced);
}

export async function getPresetResouce(pathName: string, apiType: 'json' | 'text', isForced: boolean = false) {
  const options: FetchCachedOption = {
    apiURL: `${SERVER_BASE_URL}/presets/${pathName}`,
    apiType: apiType,
    nameOfCache: `mianix:${pathName}`,
  }
  return await fetchAndCached(options, isForced);
}

export function fileSizeHuman(size: number){
  if(size < 1024) return `${size} bytes`;
  const units = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  let i = 0;
  size = size / 1024; // Convert to KB first
  while(size >= 1024 && i < units.length - 1){
    size /= 1024;
    i++;
  }
  return `${size.toFixed(2)} ${units[i]}`;
}

export function clearHtmlTag(text: string): string {
  return text.replace(/<\/?[^>]+(>|$)/g, "");
}

export function clearHtmlTagAndLineBreak(text: string): string {
  return text.replace(/<\/?[^>]+(>|$)/g, "").replace(/\n/g, "");
}

export function textTruncate(text: string, maxLength: number, isClearHtml: boolean = false): string {
  if (isClearHtml) {
    text = clearHtmlTagAndLineBreak(text);
  }
  if (text.length <= maxLength) {
    return text;
  }
  return text.slice(0, maxLength) + '...';
}

/**
 * Chuy·ªÉn ƒë·ªïi m·ªôt chu·ªói kebab-case th√†nh camelCase
 * V√≠ d·ª•: "first-mes" -> "firstMes"
 */
function kebabToCamel(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * ƒê·ªá quy chuy·ªÉn ƒë·ªïi t·∫•t c·∫£ keys trong object t·ª´ kebab-case sang camelCase
 */
function convertKeysToCamelCase(obj: any): any {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertKeysToCamelCase(item));
  }

  const newObj: any = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const camelKey = kebabToCamel(key);
      newObj[camelKey] = convertKeysToCamelCase(obj[key]);
    }
  }
  return newObj;
}

export function mergeObjects<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  function isObject(item: any): item is object {
    return item && typeof item === 'object' && !Array.isArray(item) && !(item instanceof Date) && !(item instanceof Map) && !(item instanceof Set);
  }

  function deepMerge(target: Record<string, any>, source: Record<string, any>): Record<string, any> {
    if (!isObject(target) || !isObject(source)) {
      return source;
    }

    const output: Record<string, any> = { ...target };
    
    for (const key in source) {
      if (isObject(source[key])) {
        if (key in target && isObject(target[key])) {
          output[key] = deepMerge(target[key], source[key]);
        } else {
          output[key] = { ...source[key] };
        }
      } else if (Array.isArray(source[key])) {
        output[key] = [...source[key]];
      } else if (source[key] instanceof Date) {
        output[key] = new Date(source[key]);
      } else if (source[key] instanceof Map) {
        output[key] = new Map(source[key]);
      } else if (source[key] instanceof Set) {
        output[key] = new Set(source[key]);
      } else {
        output[key] = source[key];
      }
    }

    return output;
  }

  return deepMerge(obj1, obj2) as T & U;
}

export function jsonStrToJson(valueToSave: string) {
  try {
    let cleanValue = valueToSave.trim();
    // Remove markdown code block if present
    if (cleanValue.startsWith('```json')) {
      cleanValue = cleanValue.replace(/^```json[\r\n]+|```$/g, '');
    }
    // Remove single-line comments
    cleanValue = cleanValue.replace(new RegExp('(^|\\s)//.*$', 'gm'), '');
    // Remove multi-line comments
    cleanValue = cleanValue.replace(/\/\*[\s\S]*?\*\//g, '');
    // Optionally: Replace template variables with empty string
    cleanValue = cleanValue.replace(/{{[^}]+}}/g, '');
    // Remove trailing commas before closing brackets/braces
    cleanValue = cleanValue.replace(/,\s*([}\]])/g, '$1');
    // Try to parse if it's a JSON string
    return JSON.parse(cleanValue);
  } catch (e) {
    console.warn('Failed to parse JSON:', e);
    return null;
  }
}
</file>

<file path="src/utils/gm-helper.ts">
import { GM } from '$';

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
type ResponseType = 'json' | 'text' | 'blob' | 'arrayBuffer';

interface GmFetchOptions {
  method?: HttpMethod;
  headers?: Record<string, string>;
  body?: string | FormData | Blob | ArrayBuffer;
  responseType?: ResponseType;
}

export interface FetchCachedOption {
  apiURL: string;
  apiType: 'json' | 'text';
  nameOfCache: string;
  needProcess?: boolean;
}

export async function gmFetch<T = any>(
  url: string, 
  options: GmFetchOptions = {}
): Promise<T> {
  const {
    method = 'GET',
    headers = {},
    body,
    responseType = 'json'
  } = options;

  // Prepare headers
  const defaultHeaders: Record<string, string> = {
    'Content-Type': 'application/json',
    ...headers
  };

  // Prepare body data
  let requestData: any = body;
  
  // If body is FormData or Blob, remove Content-Type to let browser set it
  if (body instanceof FormData || body instanceof Blob) {
    delete defaultHeaders['Content-Type'];
  } else if (body && typeof body === 'object' && !(body instanceof ArrayBuffer)) {
    // If body is an object and not ArrayBuffer, stringify it
    requestData = JSON.stringify(body);
  }
  
  // console.log('Request:', { method, url, headers: defaultHeaders, data: requestData });
  
  return new Promise((resolve, reject) => {
    GM.xmlHttpRequest({
      method,
      url,
      headers: defaultHeaders,
      data: requestData,
      responseType: responseType === 'arrayBuffer' ? 'arraybuffer' : undefined,
      onload: (response) => {
        try {
          // For LLM requests, we don't pre-process the response
          // Let the response object handle parsing based on the actual content
          const result = response.responseText || response.response || null;
          // console.log('Response:', { status: response.status, headers: response.responseHeaders, data: result });
          if (response.status >= 200 && response.status < 300) {
            resolve(result as T);
          } else {
            console.error(`HTTP ${response.status}: ${response.statusText}`);
            reject(new Error(`HTTP ${response.status}: ${response.statusText}`));
          }
        } catch (error) {
          console.error("Error processing response:", error);
          reject(error);
        }
      },
      onerror: (error) => {
        console.error("Network error:", error);
        reject(new Error(`Network error: ${error.error || 'Unknown error'}`));
      },
      ontimeout: () => {
        reject(new Error('Request timeout'));
      }
    });
  });
}

export async function gmFetchLLM<T = any>(
  url: string,
  options: GmFetchOptions = {}
): Promise<any> { // Tr·∫£ v·ªÅ 'any' v√¨ response c√≥ th·ªÉ l√† text stream
  const {
    method = 'GET',
    headers = {},
    body,
    responseType = 'text' // Thay ƒë·ªïi m·∫∑c ƒë·ªãnh sang 'text' ƒë·ªÉ l·∫•y d·ªØ li·ªáu th√¥
  } = options;

  // Prepare headers
  const defaultHeaders: Record<string, string> = {
    // 'Content-Type': 'application/json', // S·∫Ω ƒë∆∞·ª£c set b√™n d∆∞·ªõi n·∫øu l√† json
    ...headers
  };

  // Prepare body data
  let requestData: any = body;

  // If body is FormData or Blob, remove Content-Type to let browser set it
  if (body instanceof FormData || body instanceof Blob) {
    delete defaultHeaders['Content-Type'];
  } else if (body && typeof body === 'object' && !(body instanceof ArrayBuffer)) {
    // If body is an object and not ArrayBuffer, stringify it
    requestData = JSON.stringify(body);
    defaultHeaders['Content-Type'] = 'application/json'; // ƒê·∫∑t Content-Type khi g·ª≠i JSON
  }

  return new Promise((resolve, reject) => {
    let fullResponseText = ''; // T√≠ch l≈©y to√†n b·ªô text response
    let isStreamingDetected = false;

    GM.xmlHttpRequest({
      method,
      url,
      headers: defaultHeaders,
      data: requestData,
      // Kh√¥ng c·∫ßn responseType ·ªü ƒë√¢y n·∫øu ch√∫ng ta mu·ªën ƒë·ªçc text th√¥
      // GM.xmlHttpRequest tr·∫£ v·ªÅ responseText m·∫∑c ƒë·ªãnh l√† text
      onreadystatechange: (response) => {
        if (response.readyState === 3) {
          // Ph√°t hi·ªán streaming d·ª±a tr√™n d·∫•u hi·ªáu c·ªßa LLM SSE
          // N·∫øu b·∫°n mong ƒë·ª£i Server-Sent Events
          if (!isStreamingDetected && response.responseText && response.responseText.includes('data: ')) {
            isStreamingDetected = true;
            // Trong tr·∫°ng th√°i 3, ch√∫ng ta c√≥ th·ªÉ c√≥ d·ªØ li·ªáu ƒë·∫øn, nh∆∞ng kh√¥ng n√™n x·ª≠ l√Ω ngay t·∫°i ƒë√¢y
            // m√† ƒë·ªÉ onload x·ª≠ l√Ω to√†n b·ªô. Tuy nhi√™n, n·∫øu b·∫°n mu·ªën x·ª≠ l√Ω realtime,
            // b·∫°n c√≥ th·ªÉ ƒë·∫©y d·ªØ li·ªáu v√†o m·ªôt queue ho·∫∑c emit event.
            // C√°ch ƒë∆°n gi·∫£n nh·∫•t l√† ƒë·ªÉ onload x·ª≠ l√Ω to√†n b·ªô.
          }
          // N·∫øu l√† streaming, ch√∫ng ta kh√¥ng resolve ·ªü ƒë√¢y.
          // ƒê·ª£i readyState 4.
        } else if (response.readyState === 4) {
          // Y√™u c·∫ßu ƒë√£ ho√†n th√†nh
          fullResponseText = response.responseText || '';

          const responseObj = {
            ok: response.status >= 200 && response.status < 300,
            status: response.status,
            statusText: response.statusText || 'OK',
            headers: response.responseHeaders, // Headers th∆∞·ªùng l√† string, c·∫ßn parse n·∫øu c·∫ßn
            responseText: fullResponseText, // To√†n b·ªô text response
            // T√≠ch h·ª£p ph∆∞∆°ng th·ª©c json() v√† text() theo chu·∫©n Fetch API
            json: async () => {
              if (responseObj.ok && responseObj.responseText) {
                try {
                  return JSON.parse(responseObj.responseText);
                } catch (e) {
                  console.error("Failed to parse JSON:", e);
                  return null;
                }
              }
              return null;
            },
            text: async () => responseObj.responseText,
            // ƒê·ªÉ ƒë∆°n gi·∫£n, ta kh√¥ng gi·∫£ l·∫≠p getReader() ·ªü ƒë√¢y n·ªØa.
            // N·∫øu b·∫°n th·ª±c s·ª± c·∫ßn stream t·ª´ GM.xmlHttpRequest, n√≥ s·∫Ω ph·ª©c t·∫°p h∆°n.
            // Nh∆∞ng v·ªõi LLM, ch√∫ng ta th∆∞·ªùng mong ƒë·ª£i output cu·ªëi c√πng ho·∫∑c l√† c√°c chunk SSE ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.
            body: {
              getReader: () => {
                // ƒê√¢y l√† gi·∫£ l·∫≠p r·∫•t ƒë∆°n gi·∫£n, ch·ªâ cho c√°c tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ SSE
                // ho·∫∑c khi b·∫°n mu·ªën l·∫•y to√†n b·ªô response d∆∞·ªõi d·∫°ng stream gi·∫£ l·∫≠p
                const encoder = new TextEncoder();
                const data = encoder.encode(responseObj.responseText);
                let position = 0;
                return {
                  read: async (): Promise<{ done: boolean, value?: Uint8Array }> => {
                    if (position >= data.length) {
                      return { done: true, value: undefined };
                    }
                    const chunkSize = Math.min(1024, data.length - position);
                    const chunk = data.slice(position, position + chunkSize);
                    position += chunkSize;
                    return { done: false, value: chunk };
                  }
                };
              }
            }
          };
          resolve(responseObj);
        }
      },
      onload: (response) => {
        // onload ƒë∆∞·ª£c g·ªçi khi request ho√†n th√†nh (readyState 4).
        // Ch√∫ng ta ƒë√£ x·ª≠ l√Ω ·ªü onreadystatechange, n√™n ·ªü ƒë√¢y c√≥ th·ªÉ b·ªè tr·ªëng ho·∫∑c log.
        // if (!isStreamingDetected) {
        //   const responseObj = {
        //     ok: response.status >= 200 && response.status < 300,
        //     status: response.status,
        //     statusText: response.statusText || 'OK',
        //     headers: response.responseHeaders,
        //     responseText: response.responseText || '',
        //     json: async () => {
        //       if (responseObj.ok && responseObj.responseText) {
        //         try { return JSON.parse(responseObj.responseText); } catch (e) { return null; }
        //       }
        //       return null;
        //     },
        //     text: async () => responseObj.responseText,
        //     body: { // Fallback body reader
        //       getReader: () => {
        //         const encoder = new TextEncoder();
        //         const data = encoder.encode(responseObj.responseText);
        //         let position = 0;
        //         return {
        //           read: async (): Promise<{ done: boolean, value?: Uint8Array }> => {
        //             if (position >= data.length) { return { done: true, value: undefined }; }
        //             const chunkSize = Math.min(1024, data.length - position);
        //             const chunk = data.slice(position, position + chunkSize);
        //             position += chunkSize;
        //             return { done: false, value: chunk };
        //           }
        //         };
        //       }
        //     }
        //   };
        //   resolve(responseObj);
        // }
      },
      onerror: (error) => {
        console.error("Network error:", error);
        reject(new Error(`Network error: ${error.error || 'Unknown error'}`));
      },
      ontimeout: () => {
        reject(new Error('Request timeout'));
      }
    });
  });
}

// ƒê·ªãnh nghƒ©a ki·ªÉu d·ªØ li·ªáu cho options ƒë·ªÉ code r√µ r√†ng h∆°n
interface GmFetchStreamOptions extends GmFetchOptions {
  onChunk: (chunk: string) => void; // Callback ƒë·ªÉ x·ª≠ l√Ω t·ª´ng m·∫£nh d·ªØ li·ªáu m·ªõi
}

/**
 * H√†m n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒê·∫∂C BI·ªÜT cho vi·ªác streaming.
 * N√≥ kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu, m√† g·ªçi onChunk m·ªói khi c√≥ d·ªØ li·ªáu m·ªõi.
 * N√≥ tr·∫£ v·ªÅ m·ªôt Promise s·∫Ω resolve khi stream k·∫øt th√∫c.
 */
export function gmFetchLLMStream(
  url: string,
  options: GmFetchStreamOptions
): Promise<void> {
  const {
    method = 'POST', // Streaming th∆∞·ªùng l√† POST
    headers = {},
    body,
    onChunk,
  } = options;

  return new Promise((resolve, reject) => {
    // Bi·∫øn n√†y c·ª±c k·ª≥ quan tr·ªçng: n√≥ theo d√µi v·ªã tr√≠ cu·ªëi c√πng ch√∫ng ta ƒë√£ x·ª≠ l√Ω trong responseText
    let lastProcessedPosition = 0;

    // Prepare headers
    const defaultHeaders: Record<string, string> = {
      'Content-Type': 'application/json',
      ...headers,
    };

    let requestData: any = body;
    if (body instanceof FormData || body instanceof Blob) {
      delete defaultHeaders['Content-Type'];
    } else if (body && typeof body === 'object') {
      requestData = JSON.stringify(body);
    }

    GM.xmlHttpRequest({
      method,
      url,
      headers: defaultHeaders,
      data: requestData,
      
      // onreadystatechange l√† ch√¨a kh√≥a cho streaming
      onreadystatechange: (response) => {
        // readyState 3 l√† "LOADING", nghƒ©a l√† d·ªØ li·ªáu ƒëang ƒë∆∞·ª£c t·∫£i v·ªÅ
        if (response.readyState === 3) {
          const currentResponseText = response.responseText || '';
          // L·∫•y ph·∫ßn d·ªØ li·ªáu M·ªöI k·ªÉ t·ª´ l·∫ßn ki·ªÉm tra tr∆∞·ªõc
          const newData = currentResponseText.substring(lastProcessedPosition);
          
          if (newData) {
            // G·ªçi callback v·ªõi ch·ªâ d·ªØ li·ªáu m·ªõi
            onChunk(newData);
            // C·∫≠p nh·∫≠t v·ªã tr√≠ ƒë√£ x·ª≠ l√Ω
            lastProcessedPosition = currentResponseText.length;
          }
        }
      },

      // onload ƒë∆∞·ª£c g·ªçi khi request ho√†n th√†nh (readyState 4)
      onload: (response) => {
        // X·ª≠ l√Ω n·ªët ph·∫ßn d·ªØ li·ªáu cu·ªëi c√πng (n·∫øu c√≥)
        const finalData = (response.responseText || '').substring(lastProcessedPosition);
        if (finalData) {
          onChunk(finalData);
        }

        if (response.status >= 200 && response.status < 300) {
          resolve(); // Stream th√†nh c√¥ng, resolve Promise
        } else {
          // V·∫´n c√≥ th·ªÉ c√≥ l·ªói ngay c·∫£ khi onload
          console.error(`HTTP ${response.status}: ${response.statusText}`, response.responseText);
          reject(new Error(`HTTP ${response.status}: ${response.statusText}\nResponse: ${response.responseText}`));
        }
      },

      onerror: (error) => {
        console.error("Network error:", error);
        reject(new Error(`Network error: ${error.error || 'Unknown error'}`));
      },

      ontimeout: () => {
        reject(new Error('Request timeout'));
      }
    });
  });
}

export async function fetchAndCached(options: FetchCachedOption, isForced: boolean = false){
  const { apiURL, apiType, nameOfCache } = options;
  const lastCheck = await GM.getValue(`${nameOfCache}-check`);
  const cached = await GM.getValue(nameOfCache);
  const twelveHours = 12 * 60 * 60 * 1000; // 12 hours in milliseconds

  if (isForced || !lastCheck || !cached || Date.now() - lastCheck > twelveHours) {
    try {
      let data = await gmFetch(apiURL, {
        method: 'GET',
        responseType: apiType
      });

      if(data){
        await GM.setValue(nameOfCache, apiType === 'json' ? JSON.stringify(data): data);
        await GM.setValue(`${nameOfCache}-check`, Date.now());
      }

      return data;
    } catch (error) {
      console.error("Error fetching:", error);
      return cached ? JSON.parse(cached) : null;
    }
  }

  return apiType === 'json' ? JSON.parse(cached): cached;
}
</file>

<file path="src/utils/llm.ts">
import { gmFetchLLM,  gmFetchLLMStream } from "./gm-helper";

export interface OpenAIRequest {
  model: string;
  messages: { role: string; content: string }[];
  stream: boolean;
  maxTokens?: number;
  temperature?: number;
  top_p?: number;
}

// export interface LLMOptions {
//   maxTokens?: number;
//   temperature?: number;
//   top_p?: number;
//   contextWindow: number;
// }

export interface OpenAIOptions {
  baseURL: string;
  apiKey: string;
  data: OpenAIRequest;
  stream?: boolean;
}

export async function sendOpenAiRequest(
  options: OpenAIOptions,
  onChunk?: (chunk: string) => void
): Promise<string | void> {
  const isStreaming = options.stream === true && onChunk !== undefined;
  const requestData = { ...options.data, stream: isStreaming };
  const apiURL = `${options.baseURL}chat/completions`;

  // --- X·ª≠ l√Ω cho tr∆∞·ªùng h·ª£p KH√îNG STREAMING (gi·ªØ l·∫°i code c≈© n·∫øu c·∫ßn) ---
  if (!isStreaming) {
    // B·∫°n c√≥ th·ªÉ gi·ªØ l·∫°i h√†m gmFetchLLM c≈© cho tr∆∞·ªùng h·ª£p n√†y,
    // ho·∫∑c t·∫°o m·ªôt request m·ªõi ·ªü ƒë√¢y.
    console.log("Making a non-streaming request...");
    const response = await gmFetchLLM(apiURL, { // Gi·∫£ s·ª≠ gmFetchLLM c≈© v·∫´n t·ªìn t·∫°i
      method: "POST",
      headers: {
        Authorization: `Bearer ${options.apiKey}`,
      },
      body: JSON.stringify(requestData),
    });
    const data = await response.json();
    return data?.choices?.[0]?.message?.content || '';
  }

  // --- X·ª≠ l√Ω cho tr∆∞·ªùng h·ª£p STREAMING ---
  if (!onChunk) {
    throw new Error('onChunk callback is required for streaming mode');
  }

  // Buffer ƒë·ªÉ l∆∞u tr·ªØ c√°c d√≤ng d·ªØ li·ªáu ch∆∞a ho√†n ch·ªânh
  let buffer = "";

  const processDataChunk = (newData: string) => {
    // N·ªëi d·ªØ li·ªáu m·ªõi v√†o buffer
    buffer += newData;

    // T√°ch buffer th√†nh c√°c d√≤ng
    const lines = buffer.split('\n');

    // D√≤ng cu·ªëi c√πng c√≥ th·ªÉ ch∆∞a ho√†n ch·ªânh, gi·ªØ l·∫°i n√≥ trong buffer cho l·∫ßn sau
    buffer = lines.pop() || "";

    // X·ª≠ l√Ω t·ª´ng d√≤ng ho√†n ch·ªânh
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("data: ")) {
        const jsonStr = trimmedLine.slice(5).trim();
        if (jsonStr === "[DONE]") {
          // Stream ƒë√£ k·∫øt th√∫c t·ª´ ph√≠a server
          return;
        }
        try {
          const data = JSON.parse(jsonStr);
          const content = data?.choices?.[0]?.delta?.content;
          if (content) {
            // G·ª≠i n·ªôi dung ƒë·∫øn callback cu·ªëi c√πng c·ªßa ng∆∞·ªùi d√πng
            onChunk(content);
          }
        } catch (e) {
          console.warn("Could not parse streaming JSON chunk:", jsonStr, e);
        }
      }
    }
  };

  try {
    // G·ªçi h√†m streaming m·ªõi
    await gmFetchLLMStream(apiURL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${options.apiKey}`,
      },
      body: JSON.stringify(requestData),
      onChunk: processDataChunk, // Cung c·∫•p h√†m x·ª≠ l√Ω chunk
    });
    // Khi promise resolve, stream ƒë√£ k·∫øt th√∫c
    console.log("LLM stream finished successfully.");
  } catch (error) {
    console.error("Error during LLM stream:", error);
    // B√°o l·ªói cho ng∆∞·ªùi d√πng, v√≠ d·ª•: onChunk("[ERROR]...")
    onChunk(`\n\n[L·ªñI]: ${(error as Error).message}`);
    throw error;
  }
}

// Convenience function for non-streaming requests
export async function sendOpenAiRequestSync(
  options: Omit<OpenAIOptions, 'stream'>
): Promise<string> {
  const result = await sendOpenAiRequest({ ...options, stream: false });
  return result as string;
}

// Convenience function for streaming requests
export async function sendOpenAiRequestStream(
  options: Omit<OpenAIOptions, 'stream'>,
  onChunk: (chunk: string) => void
): Promise<void> {
  await sendOpenAiRequest({ ...options, stream: true }, onChunk);
}
</file>

<file path="src/utils/msg-process.ts">
export function adaptText(text: string, username?: string, charName?: string): string {
  let parsed = text.replace(/<br\s*\/?>/gi, "\n"); // Chuy·ªÉn ƒë·ªïi <br> th√†nh d√≤ng m·ªõi
  const userReplacement = username ?? 'T√¥i';
  const charReplacement = charName ?? "";
  
  // Thay th·∫ø c·∫£ hai ƒë·ªãnh d·∫°ng placeholder cho user
  parsed = parsed.replace(/{{user}}/g, userReplacement);
  parsed = parsed.replace(/{user}/g, userReplacement);
  
  // Thay th·∫ø c·∫£ hai ƒë·ªãnh d·∫°ng placeholder cho char
  parsed = parsed.replace(/{{char}}/g, charReplacement);
  parsed = parsed.replace(/{char}/g, charReplacement);
  
  return parsed;
}

export function formatMessageContent(content: string): string {
  if (!content) {
    return '';
  }
  let formattedContent = content;

  // B∆∞·ªõc 1: Chu·∫©n h√≥a t·∫•t c·∫£ c√°c d·∫°ng <br> th√†nh \n
  formattedContent = formattedContent.replace(/<br\s*\/?>/gi, "\n");

  // B∆∞·ªõc 2: X·ª≠ l√Ω c√°c d√≤ng m·ªõi - thay th·∫ø \n\n th√†nh r·ªóng
  formattedContent = formattedContent.replace(/\n\n/g, '');

  // B∆∞·ªõc 3: √Åp d·ª•ng ƒë·ªãnh d·∫°ng m√†u s·∫Øc
  // L·ªùi n√≥i (quotes) - m√†u xanh d∆∞∆°ng nh·∫π
  formattedContent = formattedContent.replace(
    /([""](.*?)[""]) /g,
    '<span class="text-blue-600 dark:text-blue-400">$1</span>'
  );
  // H√†nh ƒë·ªông (*text*) - m√†u cam nh·∫π
  formattedContent = formattedContent.replace(
    /(\*(.*?)\*)/g,
    '<span class="text-orange-600 dark:text-orange-400 italic">$1</span>'
  );
  // Nh·∫•n m·∫°nh (**text**) - m√†u t√≠m nh·∫π
  formattedContent = formattedContent.replace(
    /(\*\*(.*?)\*\*)/g,
    '<span class="text-purple-600 dark:text-purple-400 font-semibold">$1</span>'
  );
  // Suy nghƒ© [text] - m√†u x√°m
  formattedContent = formattedContent.replace(
    /(\[(.*?)\])/g,
    '<span class="text-gray-500 dark:text-gray-400">$1</span>'
  );
  
  // --- B∆Ø·ªöC 3: CHUY·ªÇN ƒê·ªîI K√ù T·ª∞ XU·ªêNG D√íNG SANG <br> ---
  // B√¢y gi·ªù ch√∫ng ta m·ªõi chuy·ªÉn ƒë·ªïi, ƒë·∫£m b·∫£o r·∫±ng s·∫Ω kh√¥ng c√≥ nhi·ªÅu h∆°n hai th·∫ª <br> li√™n ti·∫øp.
  formattedContent = formattedContent.replace(/\n/g, '<br>');

  return formattedContent;
}
</file>

<file path="src/utils/prompt-utils.ts">
// file: src/utils/prompt-utils.ts

import type { WorldBookEntry } from '@/types/character';
import { CharacterCard } from '@/db';
import { adaptText } from './msg-process';

/**
 * Thay th·∫ø c√°c placeholder ƒë·ªông trong m·ªôt chu·ªói vƒÉn b·∫£n.
 * @param text - Chu·ªói c·∫ßn x·ª≠ l√Ω.
 * @param context - Object ch·ª©a c√°c gi√° tr·ªã ƒë·ªÉ thay th·∫ø.
 * @returns Chu·ªói ƒë√£ ƒë∆∞·ª£c thay th·∫ø.
 */
function applyPlaceholders(text: string, context: { user: string; char: string }): string {
  // H√†m adaptText c·ªßa b·∫°n ƒë√£ x·ª≠ l√Ω vi·ªác n√†y
  return adaptText(text, context.user, context.char);
}

/**
 * ƒê·ªãnh d·∫°ng c√°c entry c·ªßa World Book ƒë·ªÉ ch√®n v√†o prompt.
 * @param entries - M·∫£ng c√°c WorldBookEntry.
 * @param context - Ng·ªØ c·∫£nh ch·ª©a t√™n user v√† char.
 * @returns M·ªôt chu·ªói ƒë√£ ƒë·ªãnh d·∫°ng ch·ª©a th√¥ng tin World Book.
 */
function formatWorldBookEntries(entries: WorldBookEntry[], context: { user: string; char: string }): string {
  if (!entries || entries.length === 0) return '';
  return entries
    .map(entry => {
      const tagName = entry.comment || 'world_info';
      const content = applyPlaceholders(entry.content || '', context);
      return `<world_information tag="${tagName}">\n${content}\n</world_information>`;
    })
    .join('\n\n');
}

/**
 * L·ªçc v√† ch·ªçn c√°c entry World Book ph√π h·ª£p v·ªõi ng·ªØ c·∫£nh hi·ªán t·∫°i.
 * @param worldBook - To√†n b·ªô World Book c·ªßa nh√¢n v·∫≠t.
 * @param chatHistoryString - L·ªãch s·ª≠ tr√≤ chuy·ªán g·∫ßn ƒë√¢y d∆∞·ªõi d·∫°ng chu·ªói.
 * @param currentUserInput - Tin nh·∫Øn hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng.
 * @returns M·ªôt m·∫£ng c√°c WorldBookEntry ph√π h·ª£p.
 */
function getRelevantWorldBookEntries(
  worldBook: WorldBookEntry[],
  chatHistoryString: string,
  currentUserInput: string
): WorldBookEntry[] {
  if (!worldBook || worldBook.length === 0) return [];

  // K·∫øt h·ª£p l·ªãch s·ª≠ chat v√† input hi·ªán t·∫°i ƒë·ªÉ t·∫°o ng·ªØ c·∫£nh t√¨m ki·∫øm
  const contextText = `${chatHistoryString}\nUser: ${currentUserInput}`.toLowerCase();

  const relevantEntries = worldBook.filter(entry => {
    // Lu√¥n bao g·ªìm c√°c entry 'constant' v√† 'enabled'
    if (entry.constant && entry.enabled) {
      return true;
    }

    // N·∫øu entry b·ªã v√¥ hi·ªáu h√≥a ho·∫∑c kh√¥ng ph·∫£i 'selective', b·ªè qua
    if (!entry.enabled || entry.selective === false) {
      return false;
    }

    // Ki·ªÉm tra xem c√≥ key n√†o kh·ªõp v·ªõi ng·ªØ c·∫£nh kh√¥ng
    // ƒê·∫£m b·∫£o keys l√† m·ªôt m·∫£ng tr∆∞·ªõc khi d√πng `some`
    return Array.isArray(entry.keys) && entry.keys.some(key => contextText.includes(key.toLowerCase()));
  });

  // S·∫Øp x·∫øp c√°c entry theo ∆∞u ti√™n (insertionOrder)
  return relevantEntries.sort((a, b) => (a.insertionOrder || 0) - (b.insertionOrder || 0));
}

/**
 * X√¢y d·ª±ng prompt cu·ªëi c√πng ƒë·ªÉ g·ª≠i ƒë·∫øn LLM.
 * ƒê√¢y l√† h√†m t·ªïng h·ª£p ch√≠nh, ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ nh·∫≠n `chatHistoryString`.
 * @param characterData - D·ªØ li·ªáu nh√¢n v·∫≠t ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a.
 * @param chatHistoryString - L·ªãch s·ª≠ c√°c tin nh·∫Øn g·∫ßn ƒë√¢y d∆∞·ªõi d·∫°ng m·ªôt chu·ªói duy nh·∫•t.
 * @param currentUserInput - Tin nh·∫Øn m·ªõi nh·∫•t c·ªßa ng∆∞·ªùi d√πng.
 * @param userProfile - H·ªì s∆° c·ªßa ng∆∞·ªùi d√πng (t√™n, etc.).
 * @param prompts - C√°c prompt m·∫´u t·ª´ resources.
 * @returns M·ªôt object ch·ª©a systemPrompt v√† userPrompt ho√†n ch·ªânh.
 */
export function buildFinalPrompt(
  characterData: CharacterCard,
  chatHistoryString: string, // <-- THAY ƒê·ªîI QUAN TR·ªåNG: nh·∫≠n chu·ªói thay v√¨ m·∫£ng
  currentUserInput: string,
  userProfile: { name: string },
  prompts: {
    multiModePrompt: string;
    multiModeChainOfThoughtPrompt: string;
    outputStructureSoftGuidePrompt: string;
    outputFormatPrompt: string;
  },
  responseInstructionHint?: string,
  responseLength? : number
): { systemPrompt: string; userPrompt: string } {
  
  // ƒê·∫£m b·∫£o d·ªØ li·ªáu nh√¢n v·∫≠t ƒë∆∞·ª£c x·ª≠ l√Ω ƒë√∫ng c√°ch
  characterData.getData();

  const context = {
    user: userProfile.name,
    char: characterData.data.name || 'Character', // Th√™m fallback
  };

  // 1. L·∫•y c√°c entry World Book ph√π h·ª£p d·ª±a tr√™n l·ªãch s·ª≠ d·∫°ng chu·ªói
  const relevantWorldBook = getRelevantWorldBookEntries(
    characterData.data.worldBook || [],
    chatHistoryString,
    currentUserInput
  );

  // Ph√¢n lo·∫°i entry theo v·ªã tr√≠ ch√®n
  const worldBookBeforeChar = formatWorldBookEntries(
    relevantWorldBook.filter(e => e.position === 'before_char'),
    context
  );
  const worldBookAfterChar = formatWorldBookEntries(
    relevantWorldBook.filter(e => e.position === 'after_char'),
    context
  );
  const worldBookBeforeInput = formatWorldBookEntries(
    relevantWorldBook.filter(e => e.position === 'before_input'),
    context
  );
  const worldBookAfterInput = formatWorldBookEntries(
    relevantWorldBook.filter(e => e.position === 'after_input'),
    context
  );

  // 2. X√¢y d·ª±ng System Prompt
  let systemPrompt = applyPlaceholders(prompts.multiModePrompt, context);
  
  const charDescription = applyPlaceholders(characterData.data.description || '', context);
  const charPersonality = applyPlaceholders(characterData.data.personality || '', context);
  const scenario = applyPlaceholders(characterData.data.scenario || '', context);

  const responseInstructions = responseInstructionHint ? `
    <response_instructions>
    **H∆∞·ªõng d·∫´n ph·∫£n h·ªìi:** ${responseInstructionHint}
    </response_instructions>
  ` : '';
  
  systemPrompt += `
    <character_description>
    ${worldBookBeforeChar}
    ${charDescription}
    ${worldBookAfterChar}
    </character_description>

    <character_personality>
    ${charPersonality}
    </character_personality>
    
    <scenario>
    ${scenario}
    </scenario>
  `;

  // 3. X√¢y d·ª±ng User Prompt
  const dialogueExamples = applyPlaceholders(characterData.data.messageExamples || '', context);
  
  let userPrompt = `
    <dialogue_examples>
    ${dialogueExamples}
    </dialogue_examples>
    
    <chain_of_thought_instructions>
    ${prompts.multiModeChainOfThoughtPrompt}
    </chain_of_thought_instructions>

    <output_format_guide>
    ${prompts.outputStructureSoftGuidePrompt}
    </output_format_guide>

    <chat_history>
    ${chatHistoryString}
    </chat_history>
    
    <user_input_section>
    ${worldBookBeforeInput}
    ${context.user}: ${currentUserInput}
    ${worldBookAfterInput}
    </user_input_section>

    ${responseInstructions}

    ${prompts.outputFormatPrompt.replace('${responseLength}', `${responseLength || 800}`)}
  `;

  return {
    systemPrompt: systemPrompt.trim(),
    userPrompt: userPrompt.trim(),
  };
}
</file>

<file path="src/utils/resource-to-blob-url.ts">
import { GM } from "$";

export async function resourceToBlobUrl(resourceName: string) {
    var blob = new Blob([await GM.getResourceText(resourceName)], {
        type: 'text/javascript'
    });
    // console.log('resourceToBlobUrl', resourceName, blob);
    return URL.createObjectURL(blob);
}

// H√†m gi·∫£i ph√≥ng URL khi kh√¥ng c·∫ßn n·ªØa
export function revokeResourceBlobUrl(url: string): void {
    if (url) URL.revokeObjectURL(url);
}
</file>

<file path="src/utils/response-parser.ts">
export interface ParsedLLMResponse {
  mainContent: string;
  nextPrompts: string[];
  events: string;
}

export function parseLLMResponse(rawResponse: string): ParsedLLMResponse {
  const cleaned = rawResponse.replace(/<\/?outputFormat>/g, '').trim();

  let mainContent = cleaned;
  let nextPrompts: string[] = [];
  let events = '';

  const promptsMatch = mainContent.match(/<next_prompts>([\s\S]*?)<\/next_prompts>/);
  if (promptsMatch && promptsMatch[1]) {
    nextPrompts = promptsMatch[1]
      .split('\n')
      .map(line => line.trim().replace(/^[-*]\s*\[|\]\s*$/g, '').trim())
      .filter(line => line.length > 0);
    mainContent = mainContent.replace(promptsMatch[0], '');
  }

  const eventsMatch = mainContent.match(/<events>([\s\S]*?)<\/events>/);
  if (eventsMatch && eventsMatch[1]) {
    events = eventsMatch[1].trim();
    mainContent = mainContent.replace(eventsMatch[0], '');
  }
  
  // L·∫•y n·ªôi dung b√™n trong th·∫ª <output> n·∫øu c√≥
  const outputMatch = mainContent.match(/<output>([\s\S]*?)<\/output>/);
  if (outputMatch && outputMatch[1]) {
    mainContent = outputMatch[1].trim();
  } else {
    mainContent = mainContent.trim();
  }

  return { mainContent, nextPrompts, events };
}
</file>

<file path="src/App.vue">
<script setup lang="ts">
import MainLayout from '@/components/MainLayout.vue'
import ConfirmDialog from 'primevue/confirmdialog';
import LoadingScreen from '@/components/common/LoadingScreen.vue'; // Import LoadingScreen
import { onMounted } from 'vue';
import { useResourcesStore } from '@/stores/resources';
import { useAppStore } from '@/stores/app';
import { storeToRefs } from 'pinia';
import { useModalStore } from '@/stores/modal';

const resourcesStore = useResourcesStore();
const appStore = useAppStore();
const modalStore = useModalStore(); // Th√™m modal store
const { isReady } = storeToRefs(appStore); // Make isReady reactive

onMounted(async () => {
  modalStore.closeModal(); // Reset t·∫•t c·∫£ modal khi app ƒë∆∞·ª£c mount
  await resourcesStore.fetchResources();
});
</script>

<template>
  <div v-if="!isReady">
    <LoadingScreen />
  </div>
  <div v-else>
    <MainLayout />
    <ConfirmDialog />
  </div>
</template>
</file>

<file path="src/constants.ts">
export const SCREENS = {
  PROFILE_LIST: "profile-list",
  CHARACTER_LIST: "character-list",
  CHARACTER_TRANSLATE: "character-translate",
  CHAT: "chat",
  MODELS_LIST: "models-list",
  PRESETS_CONFIG: "preset-config",
};

export const MODALS = {
  LLM_MODEL: "llm_model",
  CHARACTER_IMPORT: "character_import",
  EDIT_MESSAGE: "edit_message",
  EXTRACTOR_CHARACTER: 'extractor_character',
};
export const USCR_NAME = "Mianix";
export const SERVER_BASE_URL = "https://mianix.sourman.dev";
export const LLM_PROVIDERS_API = `${SERVER_BASE_URL}/json/llm-providers.json`;
export const APP_LOGO = 'https://mianix.sourman.dev/logo.png'
</file>

<file path="src/i18n.ts">
import { createI18n } from 'vue-i18n';

export const i18n = createI18n({
  legacy: false,
  globalInjection: true,
  locale: 'vi',
  messages: {
    vi: {
      'app.name': 'Mianix',
      'nav.profiles': 'H·ªì s∆°',
      'nav.characters': 'Nh√¢n v·∫≠t',
      'nav.llm_models': 'Models AI',
      'nav.presets': 'L·ªùi nh·∫Øc',
      'llm_models.index.title': 'Qu·∫£n l√Ω LLM models',
      'llm_models.index.subtitle': 'Qu·∫£n l√Ω c√°c Models AI ƒë∆∞·ª£c s·ª≠ d·ª•ng',
      'llm_models.index.add': 'Th√™m Model AI',
      'llm_models.index.edit': 'S·ª≠a Model AI',
      'llm_models.index.delete': 'X√≥a Model AI',
      'llm_models.index.default': 'M·∫∑c ƒë·ªãnh',
      'message.empty': 'Danh s√°ch tr·ªëng, h√£y th√™m m·ªõi.',
    },
  },
});
</file>

<file path="src/main.ts">
import { createApp } from "vue";
import App from "./App.vue";
import { createPinia } from "pinia";
import PrimeVue from "primevue/config";
import Aura from "@primeuix/themes/aura";
import ConfirmationService from "primevue/confirmationservice";
import piniaPluginPersistedstate from "pinia-plugin-persistedstate";
// Import c√°c file CSS
// import './tailwind.css'; // <-- Import file Tailwind chuy√™n d·ª•ng
import './style.css';   // <-- Import file style chung
import { i18n } from "./i18n";
import { useAppStore } from "./stores/app";

const appDiv = document.createElement("div");
document.body.appendChild(appDiv);
const app = createApp(App);
const pinia = createPinia();
pinia.use(piniaPluginPersistedstate);
app.use(pinia);

// Set app to ready. The persisted state is loaded automatically.
const appStore = useAppStore();
appStore.setReady(true);

app.use(i18n);
app.use(PrimeVue, {
  theme: {
    preset: Aura,
    options: {
      prefix: "p",
      darkModeSelector: 'html[data-theme="dark"]',
      cssLayer: false,
    },
  },
});
app.use(ConfirmationService);
app.mount(appDiv);
</file>

<file path="src/style.css">
/* src/style.css */

/* Import c√°c th∆∞ vi·ªán b√™n ngo√†i */
@import url("https://cdn.jsdelivr.net/npm/primeicons@7.0.0/primeicons.css");
@import "tailwindcss";
@import "tailwindcss-primeui"; /* Gi·ªØ l·∫°i n·∫øu b·∫°n d√πng plugin n√†y */

/* ƒê·ªãnh nghƒ©a c√°c custom-variant */
@custom-variant dark (&:where(.p-dark, .p-dark *));

/* Cu·ªëi c√πng l√† c√°c custom-variant */
@custom-variant dark (&:where(.p-dark, .p-dark *));

/* B·∫†N KH√îNG C·∫¶N @theme n·ªØa khi ƒë√£ c√≥ safelist */
/* B·∫°n c√≥ th·ªÉ gi·ªØ l·∫°i c√°c @apply ·ªü ƒë√¢y n·∫øu mu·ªën */
.message-buttons {
    @apply absolute top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col gap-1 bg-gray-800/50 backdrop-blur-sm p-1 rounded-lg;
}
.user-buttons {
    @apply -left-2 sm:-left-12;
}
.assistant-buttons {
    @apply -right-2 sm:-right-12;
}
.prose {
    line-height: 1.75;
}
.prose p {
    margin-bottom: 0;
}
</file>

<file path="src/tailwind.css">
/* src/tailwind.css */

/*
 * 1. Import c√°c th√†nh ph·∫ßn c∆° b·∫£n c·ªßa Tailwind
 */
@import "tailwindcss";

/*
 * 2. ƒêƒÉng k√Ω c√°c gi√° tr·ªã ti·ªán √≠ch (utility values) b·∫°n s·∫Ω d√πng trong project.
 *    ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t c·ªßa Tailwind v4.
 *    B·∫•t k·ª≥ gi√° tr·ªã n√†o b·∫°n mu·ªën d√πng (v√≠ d·ª•: p-4, gap-2, text-lg) ƒë·ªÅu c·∫ßn ƒë∆∞·ª£c tham chi·∫øu ·ªü ƒë√¢y.
 */
@theme {
  /* Spacing (cho p, m, gap, w, h, v.v...) */
  --spacing-1: theme(spacing.1);
  --spacing-2: theme(spacing.2);
  --spacing-3: theme(spacing.3);
  --spacing-4: theme(spacing.4);
  --spacing-6: theme(spacing.6);
  --spacing-12: theme(spacing.12);
  /* B·∫°n c√≥ th·ªÉ th√™m nhi·ªÅu h∆°n n·∫øu c·∫ßn */

  /* Font Sizes (cho text-sm, text-lg, v.v...) */
  --font-size-xs: theme(fontSize.xs);
  --font-size-sm: theme(fontSize.sm);
  --font-size-base: theme(fontSize.base);
  --font-size-lg: theme(fontSize.lg);
  --font-size-xl: theme(fontSize.xl);
  --font-size-2xl: theme(fontSize.2xl);

  /* Colors (cho bg-*, text-*, border-*, v.v...) */
  /* V√≠ d·ª•, n·∫øu b·∫°n mu·ªën d√πng text-white, bg-gray-900 */
  --color-white: theme(colors.white);
  --color-gray-900: theme(colors.gray.900);
  --color-blue-500: theme(colors.blue.500);
  /* Th√™m c√°c m√†u kh√°c b·∫°n s·ª≠ d·ª•ng */

  /* Th√™m c√°c thu·ªôc t√≠nh kh√°c n·∫øu b·∫°n d√πng, v√≠ d·ª•: borderRadius, fontWeight */
  --border-radius-lg: theme(borderRadius.lg);
  --font-weight-bold: theme(fontWeight.bold);
  --font-weight-semibold: theme(fontWeight.semibold);
}

/*
 * 3. (T√πy ch·ªçn) ƒê·ªãnh nghƒ©a c√°c component t√πy ch·ªânh b·∫±ng @apply
 *    ƒê·∫∑t ch√∫ng ·ªü ƒë√¢y s·∫Ω gi√∫p t√°ch bi·ªát logic v√† tr√°nh xung ƒë·ªôt.
 */
.message-buttons {
  @apply absolute top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col gap-1 bg-gray-800/50 backdrop-blur-sm p-1 rounded-lg;
}
.user-buttons {
  @apply -left-2 sm:-left-12;
}
.assistant-buttons {
  @apply -right-2 sm:-right-12;
}
.prose {
    line-height: 1.75;
}
.prose p {
    margin-bottom: 0;
}
</file>

<file path="src/TESTING-GUIDE.md">
# H∆∞·ªõng d·∫´n Test T·ª´ng Th∆∞ vi·ªán

ƒê·ªÉ x√°c ƒë·ªãnh th∆∞ vi·ªán n√†o g√¢y ra l·ªói `TypeError: Failed to construct 'URL': Invalid base URL`, h√£y l√†m theo c√°c b∆∞·ªõc sau:

## B∆∞·ªõc 1: Test kh√¥ng c√≥ th∆∞ vi·ªán database

**Hi·ªán t·∫°i**: `main.ts` ƒë√£ ƒë∆∞·ª£c comment to√†n b·ªô database code. App s·∫Ω ch·∫°y m√† kh√¥ng c√≥ database.

```bash
npm run build
```

N·∫øu build th√†nh c√¥ng v√† kh√¥ng c√≥ l·ªói ‚Üí V·∫•n ƒë·ªÅ n·∫±m ·ªü database libraries.

## B∆∞·ªõc 2: Test t·ª´ng th∆∞ vi·ªán ri√™ng bi·ªát

### Test 2.1: Ch·ªâ import PGlite

Trong `src/test-imports.ts`, uncomment d√≤ng:
```typescript
import { PGlite } from '@electric-sql/pglite';
console.log('PGlite imported successfully');
```

Trong `src/main.ts`, uncomment d√≤ng:
```typescript
import './test-imports';
```

Ch·∫°y build v√† ki·ªÉm tra console.

### Test 2.2: Ch·ªâ import Drizzle

Comment l·∫°i PGlite, uncomment:
```typescript
import { drizzle } from 'drizzle-orm/pglite';
console.log('Drizzle imported successfully');
```

### Test 2.3: Import c·∫£ hai nh∆∞ng kh√¥ng kh·ªüi t·∫°o

Uncomment:
```typescript
import { PGlite } from '@electric-sql/pglite';
import { drizzle } from 'drizzle-orm/pglite';
console.log('Both libraries imported successfully');
```

### Test 2.4: Test kh·ªüi t·∫°o PGlite

Uncomment:
```typescript
import { PGlite } from '@electric-sql/pglite';

// Test v·ªõi memory database
const memoryDb = new PGlite();
console.log('Memory database created');
```

### Test 2.5: Test IndexedDB (c√≥ th·ªÉ g√¢y l·ªói)

Uncomment:
```typescript
// Test v·ªõi IndexedDB (c√≥ th·ªÉ g√¢y l·ªói)
const idbDb = new PGlite('idb://test-db');
console.log('IndexedDB database created');
```

## B∆∞·ªõc 3: Ph√¢n t√≠ch k·∫øt qu·∫£

- **N·∫øu l·ªói ·ªü Test 2.1**: V·∫•n ƒë·ªÅ v·ªõi `@electric-sql/pglite`
- **N·∫øu l·ªói ·ªü Test 2.2**: V·∫•n ƒë·ªÅ v·ªõi `drizzle-orm/pglite`
- **N·∫øu l·ªói ·ªü Test 2.4**: V·∫•n ƒë·ªÅ v·ªõi memory database initialization
- **N·∫øu l·ªói ·ªü Test 2.5**: V·∫•n ƒë·ªÅ v·ªõi IndexedDB URL trong userscript environment

## B∆∞·ªõc 4: Kh√¥i ph·ª•c sau khi test

Sau khi x√°c ƒë·ªãnh ƒë∆∞·ª£c nguy√™n nh√¢n, uncomment l·∫°i database initialization trong `main.ts`:

```typescript
import { DatabaseService } from './db/database';

// Initialize database before creating app
DatabaseService.initialize().then(() => {
  const app = createApp(App);
  const pinia = createPinia();
  app.use(pinia);
  const container = document.createElement('div');
  document.body.appendChild(container);
  app.mount(container);
}).catch(console.error);
```

V√† comment l·∫°i:
```typescript
// import './test-imports';
```
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
/// <reference types="vite-plugin-monkey/client" />
//// <reference types="vite-plugin-monkey/global" />
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="components.d.ts">
/* eslint-disable */
// @ts-nocheck
// Generated by unplugin-vue-components
// Read more: https://github.com/vuejs/core/pull/3399
// biome-ignore lint: disable
export {}

/* prettier-ignore */
declare module 'vue' {
  export interface GlobalComponents {
    CharacterAvatar: typeof import('./src/components/character_cards/CharacterAvatar.vue')['default']
    ChatScreen: typeof import('./src/components/chat_screen/ChatScreen.vue')['default']
    DeleteConfirm: typeof import('./src/components/DeleteConfirm.vue')['default']
    EditMessageModal: typeof import('./src/components/chat_screen/EditMessageModal.vue')['default']
    ExtractorCharacterModal: typeof import('./src/components/chat_screen/ExtractorCharacterModal.vue')['default']
    Index: typeof import('./src/components/character_cards/Index.vue')['default']
    LLMIndex: typeof import('./src/components/llm_models/LLMIndex.vue')['default']
    LLMOptionsModal: typeof import('./src/components/llm_models/LLMOptionsModal.vue')['default']
    LLMProviderSelect: typeof import('./src/components/common/LLMProviderSelect.vue')['default']
    LoadingScreen: typeof import('./src/components/common/LoadingScreen.vue')['default']
    MainLayout: typeof import('./src/components/MainLayout.vue')['default']
    MessageButtons: typeof import('./src/components/chat_screen/MessageButtons.vue')['default']
    Modal: typeof import('./src/components/llm_models/Modal.vue')['default']
    ModalImport: typeof import('./src/components/character_cards/ModalImport.vue')['default']
    NavConfig: typeof import('./src/components/NavConfig.vue')['default']
    PresetConfig: typeof import('./src/components/PresetConfig.vue')['default']
    ProfileList: typeof import('./src/components/profile/ProfileList.vue')['default']
    SaveButton: typeof import('./src/components/common/SaveButton.vue')['default']
    SelectButton: typeof import('primevue/selectbutton')['default']
    SplitButton: typeof import('primevue/splitbutton')['default']
    Translate: typeof import('./src/components/character_cards/Translate.vue')['default']
  }
  export interface GlobalDirectives {
    Ripple: typeof import('primevue/ripple')['default']
    Tooltip: typeof import('primevue/tooltip')['default']
  }
}
</file>

<file path="grok3-suggestion.md">
ƒê·ªÉ x√¢y d·ª±ng m·ªôt ·ª©ng d·ª•ng roleplay AI v·ªõi giao di·ªán responsive, ƒë·∫∑c bi·ªát t·ªëi ∆∞u cho mobile, s·ª≠ d·ª•ng **Flowbite Vue** (d·ª±a tr√™n Tailwind CSS) l√† m·ªôt l·ª±a ch·ªçn t·ªët nh·ªù t√≠nh linh ho·∫°t v√† kh·∫£ nƒÉng t√πy ch·ªânh. D∆∞·ªõi ƒë√¢y l√† ƒë·ªÅ xu·∫•t chi ti·∫øt v·ªÅ layout, c√°ch t·ªï ch·ª©c c√°c th√†nh ph·∫ßn, v√† c√°ch t√≠ch h·ª£p Flowbite Vue ƒë·ªÉ ƒë√°p ·ª©ng y√™u c·∫ßu c·ªßa b·∫°n, v·ªõi tr·ªçng t√¢m l√† m√†n h√¨nh chat gi·ªëng Grok 3 (ph·∫ßn chat ch√≠nh, kh√¥ng t√≠nh bottom menu) v√† t·ªëi ∆∞u cho mobile.

---

### Ph√¢n t√≠ch y√™u c·∫ßu
1. **M√†n h√¨nh ch√≠nh**: Danh s√°ch character (g·ªìm th√™m/s·ª≠a/x√≥a, import character, worldbook/lorebook theo t·ª´ng character).
2. **Menu ph·ª•**: 
   - **Models**: C·∫•u h√¨nh LLM API.
   - **Preset**: Global prompt.
3. **M√†n h√¨nh chat**: 
   - T·ªëi ∆∞u cho mobile, giao di·ªán gi·ªëng Grok 3 (ph·∫ßn chat ch√≠nh: tin nh·∫Øn hi·ªÉn th·ªã r√µ r√†ng, input ·ªü d∆∞·ªõi, kh√¥ng qu√° c·ªìng k·ªÅnh).
   - Responsive, tr√°nh c√°c th√†nh ph·∫ßn qu√° l·ªõn ho·∫∑c kh√¥ng ph√π h·ª£p v·ªõi m√†n h√¨nh nh·ªè.
4. **Th∆∞ vi·ªán**: Flowbite Vue, v·ªõi Tailwind CSS ƒë·ªÉ ƒë·∫£m b·∫£o responsive.

---

### ƒê·ªÅ xu·∫•t layout t·ªïng th·ªÉ
D·ª±a tr√™n y√™u c·∫ßu, ·ª©ng d·ª•ng n√™n s·ª≠ d·ª•ng **mobile-first design**, v·ªõi layout g·ªìm c√°c ph·∫ßn ch√≠nh sau:

#### 1. Layout t·ªïng th·ªÉ (Responsive)
- **Desktop/Tablet**:
  - S·ª≠ d·ª•ng **sidebar b√™n tr√°i** (ho·∫∑c navbar tr√™n c√πng) ƒë·ªÉ ch·ª©a c√°c menu: Characters, Models, Preset.
  - Ph·∫ßn n·ªôi dung ch√≠nh chi·∫øm ph·∫ßn l·ªõn m√†n h√¨nh, hi·ªÉn th·ªã danh s√°ch character ho·∫∑c m√†n h√¨nh chat.
  - Sidebar c√≥ th·ªÉ thu g·ªçn (collapsible) ƒë·ªÉ t·ªëi ∆∞u kh√¥ng gian.
- **Mobile**:
  - **Hamburger menu** (menu ·∫©n, m·ªü b·∫±ng n√∫t) thay cho sidebar, ti·∫øt ki·ªám kh√¥ng gian.
  - M√†n h√¨nh ch√≠nh full-width, t·∫≠p trung v√†o danh s√°ch character ho·∫∑c chat.
  - C√°c h√†nh ƒë·ªông nh∆∞ th√™m/s·ª≠a/x√≥a character, import, ho·∫∑c truy c·∫≠p worldbook/lorebook ƒë∆∞·ª£c ƒë·∫∑t trong **modal** ho·∫∑c **dropdown** ƒë·ªÉ tr√°nh l·∫•n chi·∫øm kh√¥ng gian.

#### 2. M√†n h√¨nh ch√≠nh: Danh s√°ch Character
- **C·∫•u tr√∫c**:
  - **Header**: 
    - Logo/t√™n app (b√™n tr√°i).
    - N√∫t hamburger (mobile) ho·∫∑c sidebar toggle (desktop).
    - N√∫t ‚Äú+ New Character‚Äù (ho·∫∑c bi·ªÉu t∆∞·ª£ng c·ªông).
  - **N·ªôi dung**:
    - Danh s√°ch character hi·ªÉn th·ªã d∆∞·ªõi d·∫°ng **card grid** (1 c·ªôt tr√™n mobile, 2-3 c·ªôt tr√™n desktop).
    - M·ªói card ch·ª©a:
      - ·∫¢nh character (n·∫øu c√≥).
      - T√™n character.
      - M√¥ t·∫£ ng·∫Øn (n·∫øu c√≥).
      - N√∫t h√†nh ƒë·ªông (s·ª≠a, x√≥a, worldbook/lorebook).
    - N√∫t ‚ÄúImport Character‚Äù ·ªü header ho·∫∑c footer.
  - **Footer** (t√πy ch·ªçn): Thanh ƒëi·ªÅu h∆∞·ªõng nhanh (Characters, Models, Preset) tr√™n mobile.

- **Responsive**:
  - Mobile: Card full-width, c√°c n√∫t h√†nh ƒë·ªông nh·ªè g·ªçn (d√πng icon thay text).
  - Desktop: Grid layout, hover effect ƒë·ªÉ hi·ªÉn th·ªã n√∫t h√†nh ƒë·ªông.

- **Worldbook/Lorebook**:
  - M·ªü trong **modal** ho·∫∑c **slide-over panel** khi click v√†o n√∫t tr√™n card character.
  - N·ªôi dung: Tab ho·∫∑c accordion ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin (v√≠ d·ª•: Background, Lore, Settings).
  - Responsive: Modal full-screen tr√™n mobile, c·ªë ƒë·ªãnh k√≠ch th∆∞·ªõc tr√™n desktop.

#### 3. M√†n h√¨nh Chat
- **C·∫•u tr√∫c** (l·∫•y c·∫£m h·ª©ng t·ª´ Grok 3, ph·∫ßn chat ch√≠nh):
  - **Header**:
    - T√™n character ho·∫∑c n√∫t quay l·∫°i (mobile).
    - N√∫t m·ªü worldbook/lorebook (bi·ªÉu t∆∞·ª£ng s√°ch nh·ªè).
  - **N·ªôi dung chat**:
    - Danh s√°ch tin nh·∫Øn chi·∫øm 80-90% chi·ªÅu cao m√†n h√¨nh.
    - Tin nh·∫Øn c·ªßa user v√† AI ph√¢n bi·ªát r√µ r√†ng (bong b√≥ng chat, cƒÉn ph·∫£i/tr√°i).
    - T·ª± ƒë·ªông cu·ªôn xu·ªëng tin nh·∫Øn m·ªõi nh·∫•t.
  - **Input**:
    - Textarea ho·∫∑c input ƒë∆°n gi·∫£n ·ªü d∆∞·ªõi c√πng, k√®m n√∫t g·ª≠i (bi·ªÉu t∆∞·ª£ng m≈©i t√™n).
    - Tr√°nh th√™m qu√° nhi·ªÅu n√∫t ho·∫∑c thanh c√¥ng c·ª• ƒë·ªÉ gi·ªØ giao di·ªán g·ªçn g√†ng.
  - **Responsive**:
    - Mobile: Full-width, font-size v√† padding nh·ªè ƒë·ªÉ t·ªëi ∆∞u kh√¥ng gian.
    - Desktop: Gi·ªõi h·∫°n chi·ªÅu r·ªông t·ªëi ƒëa (v√≠ d·ª•: 800px), cƒÉn gi·ªØa ƒë·ªÉ d·ªÖ ƒë·ªçc.

#### 4. Menu Models v√† Preset
- **Models** (C·∫•u h√¨nh LLM API):
  - M·ªü trong **modal** ho·∫∑c **slide-over panel**.
  - N·ªôi dung: Form v·ªõi c√°c tr∆∞·ªùng nh∆∞ API key, endpoint, model type (dropdown).
  - Responsive: Form stack d·ªçc tr√™n mobile, grid tr√™n desktop.
- **Preset** (Global prompt):
  - T∆∞∆°ng t·ª± Models, d√πng modal ho·∫∑c slide-over.
  - N·ªôi dung: Textarea cho prompt, n√∫t l∆∞u/h·ªßy.
  - Responsive: Textarea full-width tr√™n mobile, c·ªë ƒë·ªãnh chi·ªÅu cao tr√™n desktop.

---

### T√≠ch h·ª£p v·ªõi Flowbite Vue
Flowbite Vue cung c·∫•p c√°c th√†nh ph·∫ßn nh∆∞ **Navbar**, **Sidebar**, **Modal**, **Card**, **Dropdown**, **Form**, v√† **Chat Bubble**, ph√π h·ª£p ƒë·ªÉ x√¢y d·ª±ng layout tr√™n. D∆∞·ªõi ƒë√¢y l√† c√°ch √°p d·ª•ng:

#### 1. C√†i ƒë·∫∑t Flowbite Vue
- C√†i ƒë·∫∑t Tailwind CSS v√† Flowbite Vue:
  ```bash
  npm install tailwindcss flowbite flowbite-vue
  ```
- C·∫•u h√¨nh Tailwind CSS trong `tailwind.config.js`:
  ```js
  module.exports = {
    content: [
      './node_modules/flowbite-vue/**/*.{js,jsx,ts,tsx,vue}',
      './src/**/*.{vue,js,ts,jsx,tsx}',
    ],
    plugins: [require('flowbite/plugin')],
  };
  ```
- Import Flowbite Vue trong `main.js`:
  ```js
  import { createApp } from 'vue';
  import App from './App.vue';
  import Flowbite from 'flowbite-vue';
  const app = createApp(App);
  app.use(Flowbite);
  app.mount('#app');
  ```

#### 2. M√†n h√¨nh ch√≠nh: Danh s√°ch Character
- **S·ª≠ d·ª•ng th√†nh ph·∫ßn**:
  - **Navbar** (Flowbite): Ch·ª©a hamburger menu (mobile) v√† n√∫t ‚Äú+ New Character‚Äù.
  - **Sidebar** (Flowbite): Menu Characters, Models, Preset (·∫©n tr√™n mobile).
  - **Card** (Flowbite): Hi·ªÉn th·ªã danh s√°ch character.
  - **Modal** (Flowbite): D√πng cho th√™m/s·ª≠a character, import, worldbook/lorebook.

- **V√≠ d·ª• code** (danh s√°ch character):
  ```vue
  <template>
    <div>
      <!-- Navbar -->
      <f-navbar>
        <f-navbar-brand>
          <span class="text-xl font-bold">Roleplay AI</span>
        </f-navbar-brand>
        <f-navbar-toggle />
        <f-navbar-collapse>
          <f-navbar-link href="/characters">Characters</f-navbar-link>
          <f-navbar-link href="/models">Models</f-navbar-link>
          <f-navbar-link href="/preset">Preset</f-navbar-link>
        </f-navbar-collapse>
        <f-button color="primary" @click="openAddModal">+ New Character</f-button>
      </f-navbar>

      <!-- Danh s√°ch character -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
        <f-card v-for="char in characters" :key="char.id" class="hover:shadow-lg">
          <img :src="char.image" alt="Character" class="w-full h-32 object-cover" />
          <div class="p-4">
            <h3 class="text-lg font-semibold">{{ char.name }}</h3>
            <p class="text-sm text-gray-600">{{ char.description }}</p>
            <div class="flex justify-between mt-2">
              <f-button size="xs" @click="openEditModal(char)">Edit</f-button>
              <f-button size="xs" color="red" @click="deleteChar(char.id)">Delete</f-button>
              <f-button size="xs" @click="openWorldbook(char)">Worldbook</f-button>
            </div>
          </div>
        </f-card>
      </div>

      <!-- Modal th√™m character -->
      <f-modal v-model="showAddModal">
        <f-modal-header>Add Character</f-modal-header>
        <f-modal-body>
          <f-form>
            <f-form-label>Name</f-form-label>
            <f-input v-model="newChar.name" />
            <f-form-label>Description</f-form-label>
            <f-textarea v-model="newChar.description" />
          </f-form>
        </f-modal-body>
        <f-modal-footer>
          <f-button color="primary" @click="saveChar">Save</f-button>
          <f-button color="alternative" @click="showAddModal = false">Cancel</f-button>
        </f-modal-footer>
      </f-modal>
    </div>
  </template>

  <script setup>
  import { ref } from 'vue';
  import { FNavbar, FNavbarBrand, FNavbarToggle, FNavbarCollapse, FNavbarLink, FButton, FCard, FModal, FModalHeader, FModalBody, FModalFooter, FForm, FFormLabel, FInput, FTextarea } from 'flowbite-vue';

  const characters = ref([
    { id: 1, name: 'Elf Warrior', description: 'A brave elf...', image: 'elf.jpg' },
    // Th√™m character kh√°c
  ]);
  const showAddModal = ref(false);
  const newChar = ref({ name: '', description: '' });

  const openAddModal = () => { showAddModal.value = true; };
  const saveChar = () => { /* L∆∞u character */ showAddModal.value = false; };
  const openEditModal = (char) => { /* M·ªü modal s·ª≠a */ };
  const deleteChar = (id) => { /* X√≥a character */ };
  const openWorldbook = (char) => { /* M·ªü modal worldbook */ };
  </script>
  ```

- **Responsive**:
  - Tailwind‚Äôs `grid-cols-1 md:grid-cols-2 lg:grid-cols-3` ƒë·∫£m b·∫£o 1 c·ªôt tr√™n mobile, 2-3 c·ªôt tr√™n desktop.
  - `w-full h-32 object-cover` gi·ªØ ·∫£nh character t·ª∑ l·ªá c·ªë ƒë·ªãnh.
  - Modal full-screen tr√™n mobile nh·ªù Flowbite‚Äôs responsive modal.

#### 3. M√†n h√¨nh Chat
- **S·ª≠ d·ª•ng th√†nh ph·∫ßn**:
  - **Chat Bubble** (Flowbite): Hi·ªÉn th·ªã tin nh·∫Øn user v√† AI.
  - **Input** (Flowbite): Text input cho tin nh·∫Øn.
  - **Navbar** (Flowbite): Header ch·ª©a t√™n character v√† n√∫t worldbook.

- **V√≠ d·ª• code**:
  ```vue
  <template>
    <div class="flex flex-col h-screen">
      <!-- Header -->
      <f-navbar class="border-b">
        <f-navbar-brand>
          <f-button size="sm" color="alternative" @click="goBack">Back</f-button>
          <span class="ml-2 text-lg font-semibold">{{ character.name }}</span>
        </f-navbar-brand>
        <f-button size="sm" @click="openWorldbook">Worldbook</f-button>
      </f-navbar>

      <!-- Chat content -->
      <div class="flex-1 overflow-y-auto p-4 space-y-4">
        <div v-for="msg in messages" :key="msg.id" :class="msg.isUser ? 'flex justify-end' : 'flex justify-start'">
          <f-chat-bubble :type="msg.isUser ? 'sent' : 'received'">
            {{ msg.text }}
          </f-chat-bubble>
        </div>
      </div>

      <!-- Input -->
      <div class="border-t p-4">
        <div class="flex items-center gap-2">
          <f-input v-model="newMessage" placeholder="Type a message..." class="flex-1" @keyup.enter="sendMessage" />
          <f-button size="sm" color="primary" @click="sendMessage">Send</f-button>
        </div>
      </div>

      <!-- Worldbook Modal -->
      <f-modal v-model="showWorldbook">
        <f-modal-header>{{ character.name }}'s Worldbook</f-modal-header>
        <f-modal-body>
          <f-tabs>
            <f-tab title="Background">
              <p>{{ character.background }}</p>
            </f-tab>
            <f-tab title="Lore">
              <p>{{ character.lore }}</p>
            </f-tab>
          </f-tabs>
        </f-modal-body>
      </f-modal>
    </div>
  </template>

  <script setup>
  import { ref } from 'vue';
  import { FNavbar, FNavbarBrand, FButton, FChatBubble, FInput, FModal, FModalHeader, FModalBody, FTabs, FTab } from 'flowbite-vue';

  const character = ref({ name: 'Elf Warrior', background: '...', lore: '...' });
  const messages = ref([
    { id: 1, text: 'Hello!', isUser: false },
    { id: 2, text: 'Hi there!', isUser: true },
  ]);
  const newMessage = ref('');
  const showWorldbook = ref(false);

  const goBack = () => { /* Quay l·∫°i danh s√°ch character */ };
  const sendMessage = () => {
    if (newMessage.value) {
      messages.value.push({ id: messages.value.length + 1, text: newMessage.value, isUser: true });
      newMessage.value = '';
      // G·ª≠i ƒë·∫øn AI v√† nh·∫≠n ph·∫£n h·ªìi
    }
  };
  const openWorldbook = () => { showWorldbook.value = true; };
  </script>

  <style>
  .h-screen { height: 100vh; }
  .overflow-y-auto { scroll-behavior: smooth; }
  </style>
  ```

- **Responsive**:
  - `flex flex-col h-screen`: ƒê·∫£m b·∫£o chat chi·∫øm to√†n b·ªô chi·ªÅu cao m√†n h√¨nh.
  - `overflow-y-auto`: Cho ph√©p cu·ªôn tin nh·∫Øn.
  - `flex justify-end/start`: Bong b√≥ng chat cƒÉn tr√°i/ph·∫£i theo user/AI.
  - `f-input` v√† `f-button` t·ª± ƒë·ªông co gi√£n tr√™n mobile nh·ªù Tailwind.

- **Gi·ªëng Grok 3**:
  - Giao di·ªán t·ªëi gi·∫£n, t·∫≠p trung v√†o tin nh·∫Øn.
  - Input v√† n√∫t g·ª≠i nh·ªè g·ªçn, kh√¥ng chi·∫øm nhi·ªÅu kh√¥ng gian.
  - Font-size v√† padding ƒëi·ªÅu ch·ªânh cho mobile (d√πng Tailwind‚Äôs `text-sm`, `p-2`).

#### 4. Menu Models v√† Preset
- **S·ª≠ d·ª•ng th√†nh ph·∫ßn**:
  - **Modal** (Flowbite): Form c·∫•u h√¨nh Models v√† Preset.
  - **Form** (Flowbite): Input, Dropdown, Textarea.

- **V√≠ d·ª• code** (Models):
  ```vue
  <template>
    <f-button @click="showModal = true">Configure Models</f-button>
    <f-modal v-model="showModal">
      <f-modal-header>Configure LLM API</f-modal-header>
      <f-modal-body>
        <f-form>
          <f-form-label>API Key</f-form-label>
          <f-input v-model="apiKey" type="password" />
          <f-form-label>Model</f-form-label>
          <f-select v-model="model">
            <option value="gpt-3.5">GPT-3.5</option>
            <option value="gpt-4">GPT-4</option>
          </f-select>
        </f-form>
      </f-modal-body>
      <f-modal-footer>
        <f-button color="primary" @click="saveConfig">Save</f-button>
        <f-button color="alternative" @click="showModal = false">Cancel</f-button>
      </f-modal-footer>
    </f-modal>
  </template>

  <script setup>
  import { ref } from 'vue';
  import { FButton, FModal, FModalHeader, FModalBody, FModalFooter, FForm, FFormLabel, FInput, FSelect } from 'flowbite-vue';

  const showModal = ref(false);
  const apiKey = ref('');
  const model = ref('gpt-3.5');

  const saveConfig = () => { /* L∆∞u c·∫•u h√¨nh */ showModal.value = false; };
  </script>
  ```

- **Responsive**:
  - Form stack d·ªçc (`flex flex-col`) tr√™n mobile.
  - Input full-width, label font-size nh·ªè h∆°n tr√™n mobile.

---

### T·ªëi ∆∞u h√≥a cho Mobile
1. **Font v√† Padding**:
   - `text-sm` ho·∫∑c `text-base` cho vƒÉn b·∫£n ch√≠nh.
   - `p-2` ho·∫∑c `p-3` ƒë·ªÉ gi·∫£m padding tr√™n mobile.
2. **K√≠ch th∆∞·ªõc n√∫t**:
   - D√πng `size="xs"` ho·∫∑c `sm` cho c√°c n√∫t h√†nh ƒë·ªông.
   - Icon thay text (v√≠ d·ª•: `<f-button><i class="fas fa-trash"></i></f-button>`).
3. **Modal v√† SlideOver**:
   - Modal full-screen tr√™n mobile (`w-full h-full`).
   - Slide-over d√πng Tailwind‚Äôs `translate-x-0` ƒë·ªÉ tr∆∞·ª£t t·ª´ b√™n ph·∫£i.
4. **Chat**:
   - Gi·ªõi h·∫°n chi·ªÅu r·ªông tin nh·∫Øn t·ªëi ƒëa (`max-w-3xl`) ƒë·ªÉ d·ªÖ ƒë·ªçc.
   - T·ª± ƒë·ªông focus v√†o input khi m·ªü m√†n h√¨nh chat.
   - X·ª≠ l√Ω b√†n ph√≠m mobile: ·∫®n b√†n ph√≠m khi nh·∫•n g·ª≠i (`blur()`).

---

### So s√°nh v·ªõi c√°c app nh∆∞ RisuAI, Narratrix
- **kh·∫Øc ph·ª•c v·∫•n ƒë·ªÅ ‚Äúth√†nh ph·∫ßn qu√° l·ªõn‚Äù**:
  - RisuAI v√† Narratrix th∆∞·ªùng g·∫∑p v·∫•n ƒë·ªÅ do s·ª≠ d·ª•ng layout c·ªë ƒë·ªãnh ho·∫∑c font-size/padding kh√¥ng t·ªëi ∆∞u cho mobile. Flowbite Vue + Tailwind gi√∫p:
    - T√πy ch·ªânh k√≠ch th∆∞·ªõc linh ho·∫°t v·ªõi Tailwind classes.
    - Mobile-first design, ki·ªÉm so√°t t·ª´ng breakpoint (`sm`, `md`, `lg`).
    - Th√†nh ph·∫ßn nh∆∞ `f-card`, `f-chat-bubble ƒë∆∞·ª£c t·ªëi ∆∞u s·∫µn, kh√¥ng c·∫ßn vi·∫øt nhi·ªÅu CSS ph·ª©c t·∫°p.

---

### L·ª£i √≠ch c·ªßa Flowbite Vue
- **Nhanh ch√≥ng**: Th√†nh ph·∫ßn s·∫µn c√≥, t√≠ch h·ª£p d·ªÖ v·ªõi Vue 3.
- **Responsive**: Tailwind CSS ƒë·∫£m b·∫£o layout th√≠ch ·ª©ng m·ªçi m√†n h√¨nh.
- **T√πy ch·ªânh**: D·ªÖ d√†ng ƒë·ªïi theme, m√†u s·∫Øc, font b·∫±ng Tailwind.config.js`.
- **Nh·∫π**: Tree-shaking t·ª± ƒë·ªông lo·∫°i b·ªè code kh√¥ng d√πng.

### H·∫°n ch·∫ø v√† c·∫£i thi·ªán
- **Flowbite Vue** c√≥ th√†nh ph·∫ßn ph·ª©c t·∫°p nh∆∞ rich-text chat (n·∫øu c·∫ßn th√™m ƒë·ªãnh d·∫°ng markdown ho·∫∑c emoji, ph·∫£i t√≠ch h·ª£p th√™m th∆∞ vi·ªán nh∆∞ `marked` ho·∫∑c `emoji-mart-vue`).
- N·∫øu c·∫ßn hi·ªáu su·∫•t cao h∆°n, c√≥ th·ªÉ k·∫øt h·ª£p v·ªõi **Pinia** ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i (state management) v√† **Vue Router** cho ƒëi·ªÅu h∆∞·ªõng.

---

### K·∫øt lu·∫≠n
- **Layout ƒë·ªÅ xu·∫•t** xu·∫•t**:
  - Mobile: Hamburger menu, card full-width, modal/slide-over cho h√†nh ƒë·ªông, m√†n h√¨nh chat t·ªëi gi·∫£n gi·ªëng Grok 3.
  - Desktop: Sidebar, grid layout, modal c·ªë ƒë·ªãnh k√≠ch th∆∞·ªõc.
- **Flowbite Vue** ph√π h·ª£p nh·ªù t√≠nh linh ho·∫°t v√† th√†nh ph·∫ßn responsive s·∫µn c√≥.
- ƒê·ªÉ tri·ªÉn khai, b·∫Øt ƒë·∫ßu v·ªõi Navbar, Card cho danh s√°ch character, v√† ChatBubble cho m√†n h√¨nh chat. Modal d√πng cho c√°c ch·ª©c nƒÉng ph·ª•.

Hi·ªÉu r·ªìi! B·∫°n mu·ªën s·ª≠ d·ª•ng **Pinia** ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i ƒëi·ªÅu h∆∞·ªõng gi·ªØa c√°c trang/m√†n h√¨nh (thay v√¨ **Vue Router**) b·∫±ng c√°ch s·ª≠ d·ª•ng **component ƒë·ªông** trong ·ª©ng d·ª•ng roleplay AI v·ªõi Flowbite Vue. M√¨nh s·∫Ω ƒë·ªÅ xu·∫•t c√°ch t·ªï ch·ª©c layout, qu·∫£n l√Ω ƒëi·ªÅu h∆∞·ªõng v·ªõi Pinia, v√† ƒë·∫£m b·∫£o giao di·ªán responsive, ƒë·∫∑c bi·ªát t·ªëi ∆∞u cho mobile v·ªõi m√†n h√¨nh chat gi·ªëng Grok 3 (ph·∫ßn chat ch√≠nh, kh√¥ng t√≠nh bottom menu). D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt.

---

### T·ªïng quan c√°ch ti·∫øp c·∫≠n
- **Pinia**: Qu·∫£n l√Ω tr·∫°ng th√°i ·ª©ng d·ª•ng, bao g·ªìm:
  - Trang hi·ªán t·∫°i (screen state: danh s√°ch character, chat, models, preset).
  - D·ªØ li·ªáu character, messages, models, v√† preset.
- **Component ƒë·ªông**: S·ª≠ d·ª•ng `<component :is>` ƒë·ªÉ render c√°c m√†n h√¨nh d·ª±a tr√™n tr·∫°ng th√°i Pinia.
- **Flowbite Vue**: ƒê·∫£m b·∫£o giao di·ªán responsive, t·∫≠p trung v√†o mobile-first.
- **M√†n h√¨nh chat**: T·ªëi ∆∞u cho mobile, gi·ªëng Grok 3 (tin nh·∫Øn r√µ r√†ng, input g·ªçn g√†ng, kh√¥ng c·ªìng k·ªÅnh).
- **C·∫•u tr√∫c**: M·ªôt layout ch√≠nh ch·ª©a navbar v√† component ƒë·ªông, c√°c modal cho h√†nh ƒë·ªông ph·ª• (th√™m/s·ª≠a character, worldbook, v.v.).

---

### C·∫•u tr√∫c d·ª± √°n
D∆∞·ªõi ƒë√¢y l√† c√°ch t·ªï ch·ª©c d·ª± √°n:

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ MainLayout.vue         # Layout ch√≠nh (navbar + n·ªôi dung ƒë·ªông)
‚îÇ   ‚îú‚îÄ‚îÄ CharacterList.vue      # M√†n h√¨nh danh s√°ch character
‚îÇ   ‚îú‚îÄ‚îÄ ChatScreen.vue         # M√†n h√¨nh chat
‚îÇ   ‚îú‚îÄ‚îÄ ModelsConfig.vue       # M√†n h√¨nh c·∫•u h√¨nh LLM API
‚îÇ   ‚îú‚îÄ‚îÄ PresetConfig.vue       # M√†n h√¨nh global prompt
‚îÇ   ‚îú‚îÄ‚îÄ CharacterModal.vue     # Modal th√™m/s·ª≠a character
‚îÇ   ‚îî‚îÄ‚îÄ WorldbookModal.vue     # Modal worldbook/lorebook
‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îî‚îÄ‚îÄ app.js                # Pinia store qu·∫£n l√Ω tr·∫°ng th√°i
‚îú‚îÄ‚îÄ App.vue                   # Root component
‚îî‚îÄ‚îÄ main.js                   # Kh·ªüi t·∫°o app v√† Pinia
```

---

### Thi·∫øt l·∫≠p Pinia
T·∫°o store ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i ƒëi·ªÅu h∆∞·ªõng v√† d·ªØ li·ªáu.

#### `src/stores/app.js`
```javascript
import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useAppStore = defineStore('app', () => {
  // Tr·∫°ng th√°i ƒëi·ªÅu h∆∞·ªõng
  const currentScreen = ref('character-list'); // M√†n h√¨nh hi·ªán t·∫°i
  const selectedCharacter = ref(null); // Character ƒëang ch·ªçn ƒë·ªÉ chat

  // D·ªØ li·ªáu ·ª©ng d·ª•ng
  const characters = ref([
    { id: 1, name: 'Elf Warrior', description: 'A brave elf...', image: 'elf.jpg', background: 'Forest realm...', lore: 'Ancient hero...' },
    // Th√™m character kh√°c
  ]);
  const messages = ref([]); // Tin nh·∫Øn cho m√†n h√¨nh chat
  const apiConfig = ref({ apiKey: '', model: 'gpt-3.5' }); // C·∫•u h√¨nh LLM
  const globalPrompt = ref(''); // Global prompt

  // H√†m ƒëi·ªÅu h∆∞·ªõng
  const setScreen = (screen) => {
    currentScreen.value = screen;
    if (screen !== 'chat') selectedCharacter.value = null; // Reset khi kh√¥ng ·ªü m√†n h√¨nh chat
  };

  // H√†m ch·ªçn character ƒë·ªÉ chat
  const selectCharacter = (char) => {
    selectedCharacter.value = char;
    messages.value = []; // Reset tin nh·∫Øn
    setScreen('chat');
  };

  // H√†m qu·∫£n l√Ω character
  const addCharacter = (char) => {
    characters.value.push({ id: characters.value.length + 1, ...char });
  };
  const updateCharacter = (id, updatedChar) => {
    const index = characters.value.findIndex(c => c.id === id);
    if (index !== -1) characters.value[index] = { ...characters.value[index], ...updatedChar };
  };
  const deleteCharacter = (id) => {
    characters.value = characters.value.filter(c => c.id !== id);
  };

  // H√†m g·ª≠i tin nh·∫Øn
  const sendMessage = (text) => {
    messages.value.push({ id: messages.value.length + 1, text, isUser: true });
    // Gi·∫£ l·∫≠p ph·∫£n h·ªìi AI
    messages.value.push({ id: messages.value.length + 1, text: 'AI response...', isUser: false });
  };

  // H√†m c·∫•u h√¨nh
  const saveApiConfig = (config) => {
    apiConfig.value = config;
  };
  const saveGlobalPrompt = (prompt) => {
    globalPrompt.value = prompt;
  };

  return {
    currentScreen,
    selectedCharacter,
    characters,
    messages,
    apiConfig,
    globalPrompt,
    setScreen,
    selectCharacter,
    addCharacter,
    updateCharacter,
    deleteCharacter,
    sendMessage,
    saveApiConfig,
    saveGlobalPrompt,
  };
});
```

#### C√†i ƒë·∫∑t Pinia trong `main.js`
```javascript
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import Flowbite from 'flowbite-vue';
import App from './App.vue';

const app = createApp(App);
app.use(createPinia());
app.use(Flowbite);
app.mount('#app');
```

---

### Layout ch√≠nh v·ªõi Component ƒë·ªông
S·ª≠ d·ª•ng `<component :is>` ƒë·ªÉ render m√†n h√¨nh d·ª±a tr√™n tr·∫°ng th√°i `currentScreen` t·ª´ Pinia.

#### `src/components/MainLayout.vue`
```vue
<template>
  <div class="min-h-screen flex flex-col">
    <!-- Navbar -->
    <f-navbar class="border-b">
      <f-navbar-brand>
        <f-button v-if="currentScreen !== 'character-list'" size="sm" color="alternative" @click="setScreen('character-list')">Back</f-button>
        <span class="ml-2 text-xl font-bold">Roleplay AI</span>
      </f-navbar-brand>
      <f-navbar-toggle />
      <f-navbar-collapse>
        <f-navbar-link @click="setScreen('character-list')">Characters</f-navbar-link>
        <f-navbar-link @click="setScreen('models')">Models</f-navbar-link>
        <f-navbar-link @click="setScreen('preset')">Preset</f-navbar-link>
      </f-navbar-collapse>
      <f-button v-if="currentScreen === 'character-list'" size="sm" color="primary" @click="showAddModal = true">+ New Character</f-button>
    </f-navbar>

    <!-- N·ªôi dung ƒë·ªông -->
    <div class="flex-1 p-4">
      <component :is="screenComponent" />
    </div>

    <!-- Modal th√™m/s·ª≠a character -->
    <character-modal v-model="showAddModal" :character="editCharacter" @save="saveCharacter" />
  </div>
</template>

<script setup>
import { computed, ref } from 'vue';
import { useAppStore } from '../stores/app';
import { FNavbar, FNavbarBrand, FNavbarToggle, FNavbarCollapse, FNavbarLink, FButton } from 'flowbite-vue';
import CharacterList from './CharacterList.vue';
import ChatScreen from './ChatScreen.vue';
import ModelsConfig from './ModelsConfig.vue';
import PresetConfig from './PresetConfig.vue';
import CharacterModal from './CharacterModal.vue';

const store = useAppStore();
const showAddModal = ref(false);
const editCharacter = ref(null);

// Map screen name to component
const screenMap = {
  'character-list': CharacterList,
  chat: ChatScreen,
  models: ModelsConfig,
  preset: PresetConfig,
};
const screenComponent = computed(() => screenMap[store.currentScreen]);

const setScreen = (screen) => store.setScreen(screen);
const saveCharacter = (char) => {
  if (editCharacter.value) {
    store.updateCharacter(editCharacter.value.id, char);
    editCharacter.value = null;
  } else {
    store.addCharacter(char);
  }
  showAddModal.value = false;
};
</script>
```

- **Gi·∫£i th√≠ch**:
  - `currentScreen` t·ª´ Pinia quy·∫øt ƒë·ªãnh component n√†o ƒë∆∞·ª£c render (`CharacterList`, `ChatScreen`, v.v.).
  - Navbar d√πng Flowbite Vue, hi·ªÉn th·ªã hamburger menu tr√™n mobile.
  - Modal th√™m/s·ª≠a character ƒë∆∞·ª£c qu·∫£n l√Ω b·∫±ng `showAddModal`.

---

### M√†n h√¨nh danh s√°ch Character
#### `src/components/CharacterList.vue`
```vue
<template>
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    <f-card v-for="char in characters" :key="char.id" class="hover:shadow-lg">
      <img :src="char.image" alt="Character" class="w-full h-32 object-cover" />
      <div class="p-4">
        <h3 class="text-lg font-semibold">{{ char.name }}</h3>
        <p class="text-sm text-gray-600">{{ char.description }}</p>
        <div class="flex justify-between mt-2">
          <f-button size="xs" @click="selectCharacter(char)">Chat</f-button>
          <f-button size="xs" @click="openEditModal(char)">Edit</f-button>
          <f-button size="xs" color="red" @click="deleteChar(char.id)">Delete</f-button>
          <f-button size="xs" @click="openWorldbook(char)">Worldbook</f-button>
        </div>
      </div>
    </f-card>
  </div>

  <!-- Modal worldbook -->
  <worldbook-modal v-model="showWorldbook" :character="selectedWorldbook" />
</template>

<script setup>
import { ref } from 'vue';
import { useAppStore } from '../stores/app';
import { FCard, FButton } from 'flowbite-vue';
import WorldbookModal from './WorldbookModal.vue';

const store = useAppStore();
const { characters, selectCharacter, deleteCharacter } = store;
const showWorldbook = ref(false);
const selectedWorldbook = ref(null);

const openEditModal = (char) => {
  store.setScreen('character-list'); // ƒê·∫£m b·∫£o ·ªü m√†n h√¨nh ch√≠nh
  // Emit s·ª± ki·ªán ƒë·ªÉ m·ªü modal t·ª´ MainLayout (x·ª≠ l√Ω trong parent)
  // Gi·∫£ s·ª≠ parent x·ª≠ l√Ω modal
};
const openWorldbook = (char) => {
  selectedWorldbook.value = char;
  showWorldbook.value = true;
};
const deleteChar = (id) => deleteCharacter(id);
</script>
```

- **Responsive**:
  - `grid-cols-1 md:grid-cols-2 lg:grid-cols-3`: 1 c·ªôt tr√™n mobile, 2-3 c·ªôt tr√™n desktop.
  - N√∫t `size="xs"`: Nh·ªè g·ªçn tr√™n mobile.
  - ·∫¢nh character (`h-32 object-cover`): Gi·ªØ t·ª∑ l·ªá c·ªë ƒë·ªãnh.

---

### M√†n h√¨nh Chat
#### `src/components/ChatScreen.vue`
```vue
<template>
  <div class="flex flex-col h-[calc(100vh-4rem)]">
    <!-- Header -->
    <div class="border-b p-2 flex justify-between items-center">
      <div class="flex items-center gap-2">
        <f-button size="sm" color="alternative" @click="setScreen('character-list')">Back</f-button>
        <span class="text-lg font-semibold">{{ selectedCharacter?.name }}</span>
      </div>
      <f-button size="sm" @click="openWorldbook">Worldbook</f-button>
    </div>

    <!-- Chat content -->
    <div ref="chatContainer" class="flex-1 overflow-y-auto p-4 space-y-4">
      <div v-for="msg in messages" :key="msg.id" :class="msg.isUser ? 'flex justify-end' : 'flex justify-start'">
        <f-chat-bubble :type="msg.isUser ? 'sent' : 'received'" class="max-w-[80%]">
          {{ msg.text }}
        </f-chat-bubble>
      </div>
    </div>

    <!-- Input -->
    <div class="border-t p-2">
      <div class="flex items-center gap-2">
        <f-input v-model="newMessage" placeholder="Type a message..." class="flex-1 text-sm" @keyup.enter="sendMessage" />
        <f-button size="sm" color="primary" @click="sendMessage">Send</f-button>
      </div>
    </div>

    <!-- Worldbook Modal -->
    <worldbook-modal v-model="showWorldbook" :character="selectedCharacter" />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useAppStore } from '../stores/app';
import { FButton, FChatBubble, FInput } from 'flowbite-vue';
import WorldbookModal from './WorldbookModal.vue';

const store = useAppStore();
const { selectedCharacter, messages, sendMessage, setScreen } = store;
const newMessage = ref('');
const showWorldbook = ref(false);
const chatContainer = ref(null);

// T·ª± ƒë·ªông cu·ªôn xu·ªëng tin nh·∫Øn m·ªõi nh·∫•t
watch(messages, () => {
  nextTick(() => {
    if (chatContainer.value) {
      chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
    }
  });
});

const sendMessageHandler = () => {
  if (newMessage.value) {
    sendMessage(newMessage.value);
    newMessage.value = '';
  }
};
const openWorldbook = () => { showWorldbook.value = true; };
</script>

<style>
.max-w-\[80\%\] { max-width: 80%; }
.text-sm { font-size: 0.875rem; }
</style>
```

- **T·ªëi ∆∞u mobile**:
  - `h-[calc(100vh-4rem)]`: ƒê·∫£m b·∫£o chat chi·∫øm to√†n b·ªô chi·ªÅu cao tr·ª´ navbar.
  - `max-w-[80%]`: Bong b√≥ng chat kh√¥ng qu√° r·ªông tr√™n mobile.
  - `text-sm`: Font nh·ªè g·ªçn, d·ªÖ ƒë·ªçc.
  - `p-2`: Padding nh·ªè ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian.
  - T·ª± ƒë·ªông cu·ªôn (`scrollTop`) ƒë·ªÉ hi·ªÉn th·ªã tin nh·∫Øn m·ªõi nh·∫•t.

- **Gi·ªëng Grok 3**:
  - Giao di·ªán t·ªëi gi·∫£n, ch·ªâ c√≥ tin nh·∫Øn v√† input.
  - Bong b√≥ng chat cƒÉn tr√°i/ph·∫£i r√µ r√†ng.
  - Input n·∫±m d∆∞·ªõi c√πng, kh√¥ng th√™m thanh c√¥ng c·ª• th·ª´a.

---

### Modal Character v√† Worldbook
#### `src/components/CharacterModal.vue`
```vue
<template>
  <f-modal v-model="show">
    <f-modal-header>{{ character ? 'Edit Character' : 'Add Character' }}</f-modal-header>
    <f-modal-body>
      <f-form>
        <f-form-label>Name</f-form-label>
        <f-input v-model="form.name" />
        <f-form-label>Description</f-form-label>
        <f-textarea v-model="form.description" />
        <f-form-label>Image URL</f-form-label>
        <f-input v-model="form.image" />
      </f-form>
    </f-modal-body>
    <f-modal-footer>
      <f-button color="primary" @click="emit('save', form)">Save</f-button>
      <f-button color="alternative" @click="show = false">Cancel</f-button>
    </f-modal-footer>
  </f-modal>
</template>

<script setup>
import { ref, watch } from 'vue';
import { FModal, FModalHeader, FModalBody, FModalFooter, FForm, FFormLabel, FInput, FTextarea, FButton } from 'flowbite-vue';

defineProps(['modelValue', 'character']);
const emit = defineEmits(['update:modelValue', 'save']);
const show = ref(false);
const form = ref({ name: '', description: '', image: '' });

watch(() => show.value, (val) => emit('update:modelValue', val));
watch(() => props.modelValue, (val) => { show.value = val; });
watch(() => props.character, (char) => {
  if (char) form.value = { ...char };
  else form.value = { name: '', description: '', image: '' };
});
</script>
```

#### `src/components/WorldbookModal.vue`
```vue
<template>
  <f-modal v-model="show">
    <f-modal-header>{{ character?.name }}'s Worldbook</f-modal-header>
    <f-modal-body>
      <f-tabs>
        <f-tab title="Background">
          <p>{{ character?.background }}</p>
        </f-tab>
        <f-tab title="Lore">
          <p>{{ character?.lore }}</p>
        </f-tab>
      </f-tabs>
    </f-modal-body>
    <f-modal-footer>
      <f-button color="alternative" @click="show = false">Close</f-button>
    </f-modal-footer>
  </f-modal>
</template>

<script setup>
import { ref, watch } from 'vue';
import { FModal, FModalHeader, FModalBody, FModalFooter, FTabs, FTab, FButton } from 'flowbite-vue';

defineProps(['modelValue', 'character']);
const emit = defineEmits(['update:modelValue']);
const show = ref(false);

watch(() => show.value, (val) => emit('update:modelValue', val));
watch(() => props.modelValue, (val) => { show.value = val; });
</script>
```

- **Responsive**:
  - Modal full-screen tr√™n mobile (`w-full h-full` t·ª´ Flowbite).
  - Form stack d·ªçc, input full-width.

---

### M√†n h√¨nh Models v√† Preset
#### `src/components/ModelsConfig.vue`
```vue
<template>
  <div class="p-4">
    <h2 class="text-xl font-semibold mb-4">Configure LLM API</h2>
    <f-form>
      <f-form-label>API Key</f-form-label>
      <f-input v-model="form.apiKey" type="password" />
      <f-form-label>Model</f-form-label>
      <f-select v-model="form.model">
        <option value="gpt-3.5">GPT-3.5</option>
        <option value="gpt-4">GPT-4</option>
      </f-select>
      <div class="mt-4">
        <f-button color="primary" @click="saveConfig">Save</f-button>
      </div>
    </f-form>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useAppStore } from '../stores/app';
import { FForm, FFormLabel, FInput, FSelect, FButton } from 'flowbite-vue';

const store = useAppStore();
const form = ref({ ...store.apiConfig });

const saveConfig = () => {
  store.saveApiConfig(form.value);
  store.setScreen('character-list');
};
</script>
```

#### `src/components/PresetConfig.vue`
```vue
<template>
  <div class="p-4">
    <h2 class="text-xl font-semibold mb-4">Global Prompt</h2>
    <f-form>
      <f-form-label>Prompt</f-form-label>
      <f-textarea v-model="prompt" rows="6" />
      <div class="mt-4">
        <f-button color="primary" @click="savePrompt">Save</f-button>
      </div>
    </f-form>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useAppStore } from '../stores/app';
import { FForm, FFormLabel, FTextarea, FButton } from 'flowbite-vue';

const store = useAppStore();
const prompt = ref(store.globalPrompt);

const savePrompt = () => {
  store.saveGlobalPrompt(prompt.value);
  store.setScreen('character-list');
};
</script>
```

---

### T·ªëi ∆∞u cho Mobile
1. **Navbar**:
   - Hamburger menu (`FNavbarToggle`) ·∫©n menu tr√™n mobile, ch·ªâ hi·ªÉn th·ªã khi nh·∫•n.
   - N√∫t nh·ªè g·ªçn (`size="sm"`), icon thay text n·∫øu c·∫ßn.
2. **Danh s√°ch Character**:
   - Card full-width (`grid-cols-1`), ·∫£nh t·ª∑ l·ªá c·ªë ƒë·ªãnh (`h-32 object-cover`).
   - N√∫t h√†nh ƒë·ªông nh·ªè (`size="xs"`), d√πng icon ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian.
3. **Chat**:
   - `h-[calc(100vh-4rem)]` ƒë·∫£m b·∫£o chat chi·∫øm to√†n m√†n h√¨nh tr·ª´ navbar.
   - Bong b√≥ng chat gi·ªõi h·∫°n `max-w-[80%]` ƒë·ªÉ tr√°nh tr√†n.
   - Input font nh·ªè (`text-sm`), padding nh·ªè (`p-2`).
   - T·ª± ƒë·ªông cu·ªôn (`scrollTop`) ƒë·ªÉ hi·ªÉn th·ªã tin nh·∫Øn m·ªõi.
4. **Modal**:
   - Full-screen tr√™n mobile, c·ªë ƒë·ªãnh k√≠ch th∆∞·ªõc tr√™n desktop.
   - Form stack d·ªçc, input full-width.

---

### So s√°nh v·ªõi RisuAI, Narratrix
- **V·∫•n ƒë·ªÅ c·ªßa RisuAI/Narratrix**: Th√†nh ph·∫ßn qu√° l·ªõn, kh√¥ng t·ªëi ∆∞u mobile (font l·ªõn, padding th·ª´a, layout c·ªë ƒë·ªãnh).
- **Kh·∫Øc ph·ª•c**:
  - Flowbite Vue + Tailwind cung c·∫•p classes nh∆∞ `text-sm`, `p-2`, `max-w-[80%]` ƒë·ªÉ thu g·ªçn giao di·ªán.
  - Mobile-first design v·ªõi breakpoints (`sm`, `md`, `lg`) ƒë·∫£m b·∫£o layout th√≠ch ·ª©ng.
  - Component ƒë·ªông v·ªõi Pinia gi·∫£m t·∫£i, tr√°nh render th·ª´a.

---

### L·ª£i √≠ch c·ªßa c√°ch ti·∫øp c·∫≠n
- **Pinia**: Qu·∫£n l√Ω tr·∫°ng th√°i t·∫≠p trung, d·ªÖ m·ªü r·ªông (th√™m m√†n h√¨nh m·ªõi ch·ªâ c·∫ßn th√™m v√†o `screenMap`).
- **Component ƒë·ªông**: Kh√¥ng c·∫ßn Vue Router, gi·∫£m ƒë·ªô ph·ª©c t·∫°p, ph√π h·ª£p v·ªõi ·ª©ng d·ª•ng ƒë∆°n gi·∫£n.
- **Flowbite Vue**: Th√†nh ph·∫ßn responsive s·∫µn c√≥, t√≠ch h·ª£p Tailwind d·ªÖ t√πy ch·ªânh.
- **Mobile-first**: Giao di·ªán t·ªëi ∆∞u cho mobile, ƒë·∫∑c bi·ªát m√†n h√¨nh chat gi·ªëng Grok 3.

---

### H∆∞·ªõng d·∫´n m·ªü r·ªông
1. **Import Character**:
   - Th√™m n√∫t ‚ÄúImport‚Äù trong `CharacterList.vue`, m·ªü modal v·ªõi input file (`<input type="file">`).
   - Parse file (JSON/CSV) trong store (`addCharacter`).
2. **Worldbook/Lorebook chi ti·∫øt**:
   - D√πng `FTabs` trong `WorldbookModal.vue` ƒë·ªÉ th√™m c√°c tab nh∆∞ Skills, Inventory.
   - L∆∞u d·ªØ li·ªáu chi ti·∫øt trong `characters` (Pinia).
3. **T√≠ch h·ª£p backend**:
   - D√πng `axios` ho·∫∑c `fetch` trong store ƒë·ªÉ g·ª≠i tin nh·∫Øn ƒë·∫øn LLM API.
   - V√≠ d·ª•:
     ```javascript
     const sendMessage = async (text) => {
       messages.value.push({ id: messages.value.length + 1, text, isUser: true });
       const response = await axios.post('/api/chat', { message: text, model: apiConfig.value.model });
       messages.value.push({ id: messages.value.length + 1, text: response.data.reply, isUser: false });
     };
     ```
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 sourman-dev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "mianix",
  "private": true,
  "version": "0.0.2",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vue-tsc -b && vite preview"
  },
  "dependencies": {
    "@primeuix/themes": "^1.1.2",
    "@signaldb/core": "^1.6.0",
    "@signaldb/indexeddb": "^1.1.0",
    "@signaldb/vue": "^1.0.0",
    "dayjs": "^1.11.13",
    "dexie": "^4.0.11",
    "easy-web-worker": "^7.0.2",
    "idb-keyval": "^6.2.2",
    "pinia": "^3.0.3",
    "pinia-plugin-persistedstate": "^4.3.0",
    "png-chunk-text": "^1.0.0",
    "png-chunks-encode": "^1.0.0",
    "png-chunks-extract": "^1.0.0",
    "primeicons": "^7.0.0",
    "primevue": "^4.3.5",
    "tailwindcss-primeui": "^0.6.1",
    "vue": "^3.5.13",
    "vue-i18n": "11"
  },
  "devDependencies": {
    "@primevue/auto-import-resolver": "^4.3.5",
    "@tailwindcss/vite": "^4.1.10",
    "@types/node": "^24.0.3",
    "@types/png-chunk-text": "^1.0.3",
    "@types/png-chunks-encode": "^1.0.2",
    "@types/png-chunks-extract": "^1.0.2",
    "@vitejs/plugin-vue": "^5.2.1",
    "tailwindcss": "^4.1.10",
    "terser": "^5.43.1",
    "typescript": "^5.7.2",
    "unplugin-vue-components": "^28.7.0",
    "vite": "^6.0.5",
    "vite-plugin-monkey": "^5.0.3",
    "vue-tsc": "^2.2.0"
  }
}
</file>

<file path="preset-narratium.md">
# Narratium Preset Collection

T·ªïng h·ª£p c√°c preset ƒë∆∞·ª£c fix c·ª©ng trong code c·ªßa Narratium, ƒë∆∞·ª£c tr√≠ch xu·∫•t t·ª´ thi·∫øt k·∫ø tham kh·∫£o.

## 1. Default Global Prompt

**Ngu·ªìn:** `src/stores/app.ts`

```
You are a helpful AI assistant for roleplay conversations.
```

## 2. Roleplay Assistant

**Ngu·ªìn:** `src/components/PresetConfig.vue`

```
You are {character_name}, a character in an interactive roleplay scenario.

Character Description: {character_description}
Background: {character_background}
Lore: {character_lore}

You should:
- Stay in character at all times
- Respond naturally and authentically as {character_name}
- Use the {response_format} format for your responses
- Remember previous conversations and maintain consistency
- Be engaging and immersive in your interactions

Current conversation context: {conversation_context}
```

## 3. Interactive Storyteller

**Ngu·ªìn:** `src/components/PresetConfig.vue`

```
You are an interactive storyteller working with {character_name} as the main character.

Character: {character_name}
Description: {character_description}
Background: {character_background}

As a storyteller, you should:
- Create engaging, immersive narratives
- Incorporate the character's background and personality
- Respond to user input to advance the story
- Use vivid descriptions and compelling dialogue
- Maintain narrative consistency and flow

Response format: {response_format}
Context: {conversation_context}
```

## 4. AI Companion

**Ngu·ªìn:** `src/components/PresetConfig.vue`

```
You are {character_name}, a friendly AI companion designed to have meaningful conversations.

About you:
- Name: {character_name}
- Description: {character_description}
- Background: {character_background}

Your personality and approach:
- Be warm, understanding, and supportive
- Show genuine interest in the user's thoughts and feelings
- Share insights based on your character background
- Maintain a consistent personality throughout conversations
- Use the {response_format} communication style

Conversation context: {conversation_context}
```

## 5. Adventure Guide

**Ngu·ªìn:** `src/components/PresetConfig.vue`

```
You are {character_name}, an adventure guide in an interactive story.

Character Details:
- Name: {character_name}
- Role: {character_description}
- Background: {character_background}
- Lore: {character_lore}

As an adventure guide, you should:
- Present choices and scenarios for the user to navigate
- Describe environments, challenges, and opportunities
- React to user decisions and drive the adventure forward
- Maintain excitement and engagement
- Use {response_format} style responses

Current adventure context: {conversation_context}
```

## Template Options

**Ngu·ªìn:** `src/components/PresetConfig.vue`

C√°c template ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong `templateOptions`:

1. **Custom Prompt** - Cho ph√©p ng∆∞·ªùi d√πng t·ª± t·∫°o prompt
2. **Roleplay Assistant** - Tr·ª£ l√Ω nh·∫≠p vai
3. **Interactive Storyteller** - Ng∆∞·ªùi k·ªÉ chuy·ªán t∆∞∆°ng t√°c
4. **AI Companion** - B·∫°n ƒë·ªìng h√†nh AI
5. **Adventure Guide** - H∆∞·ªõng d·∫´n vi√™n phi√™u l∆∞u

## Response Format Options

**Ngu·ªìn:** `src/components/PresetConfig.vue`

C√°c ƒë·ªãnh d·∫°ng ph·∫£n h·ªìi ƒë∆∞·ª£c h·ªó tr·ª£:

1. **Narrative** - D·∫°ng k·ªÉ chuy·ªán
2. **Dialogue** - D·∫°ng h·ªôi tho·∫°i
3. **Action** - D·∫°ng h√†nh ƒë·ªông (*actions* v√† dialogue)
4. **Mixed Format** - ƒê·ªãnh d·∫°ng h·ªón h·ª£p

## Available Variables

**Ngu·ªìn:** `src/components/PresetConfig.vue`

C√°c bi·∫øn c√≥ th·ªÉ s·ª≠ d·ª•ng trong preset:

- `{character_name}` - T√™n nh√¢n v·∫≠t
- `{character_description}` - M√¥ t·∫£ nh√¢n v·∫≠t
- `{character_background}` - L√Ω l·ªãch nh√¢n v·∫≠t
- `{character_lore}` - Lore v√† th√¥ng tin b·ªï sung
- `{user_name}` - T√™n ng∆∞·ªùi d√πng (n·∫øu c√≥)
- `{conversation_context}` - Ng·ªØ c·∫£nh cu·ªôc tr√≤ chuy·ªán hi·ªán t·∫°i
- `{current_time}` - Ng√†y gi·ªù hi·ªán t·∫°i
- `{response_format}` - ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi ƒë∆∞·ª£c ch·ªçn

## Ghi ch√∫

- C√°c preset n√†y ƒë∆∞·ª£c tr√≠ch xu·∫•t t·ª´ file `repomix-output-Narratium-Narratium.ai.xml` v√† m√£ ngu·ªìn hi·ªán t·∫°i
- Th·ª© t·ª± preset ƒë∆∞·ª£c s·∫Øp x·∫øp theo m·ª©c ƒë·ªô ph·ªï bi·∫øn v√† t√≠nh ·ª©ng d·ª•ng
- T·∫•t c·∫£ preset ƒë·ªÅu h·ªó tr·ª£ c√°c bi·∫øn ƒë·ªông ƒë·ªÉ t√πy ch·ªânh theo nh√¢n v·∫≠t c·ª• th·ªÉ
- Preset m·∫∑c ƒë·ªãnh l√† "Roleplay Assistant" khi kh·ªüi t·∫°o ·ª©ng d·ª•ng
</file>

<file path="README.md">
# Vue 3 + TypeScript + Vite

This template should help get you started developing with Vue 3 and TypeScript in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Vue - Official](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur).

## Type Support For `.vue` Imports in TS

TypeScript cannot handle type information for `.vue` imports by default, so we replace the `tsc` CLI with `vue-tsc` for type checking. In editors, we need [Vue - Official](https://marketplace.visualstudio.com/items?itemName=Vue.volar) to make the TypeScript language service aware of `.vue` types.
</file>

<file path="repomix-output-Narratium-Narratium.ai.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ‚ãÆ---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ‚ãÆ---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build.yml
    BuildDockerImage.yml
    sync.yml
app/
  character/
    page.tsx
  character-cards/
    page.tsx
  contexts/
    SoundContext.tsx
  creator-area/
    page.tsx
  creator-input/
    page.tsx
  i18n/
    locales/
      en.json
      zh.json
    fonts.ts
    FontWrapper.tsx
    index.ts
    LanguageProvider.tsx
  styles/
    fantasy-ui.css
    fonts.css
    local-fonts.css
  globals.css
  layout.tsx
  metadata.ts
  not-found.tsx
  page.tsx
components/
  __tests__/
    ChatHtmlBubble.test.ts
  AdvancedSettingsEditor.tsx
  CharacterAvatarBackground.tsx
  CharacterCardCarousel.tsx
  CharacterCardGrid.tsx
  CharacterChatHeader.tsx
  CharacterChatPanel.tsx
  CharacterSidebar.tsx
  ChatHtmlBubble.tsx
  CreatePresetModal.tsx
  DialogueTreeModal.tsx
  DownloadCharacterModal.tsx
  EditCharacterModal.tsx
  EditPromptModal.tsx
  GoogleAnalytics.tsx
  HomeContent.tsx
  ImportCharacterModal.tsx
  ImportPresetModal.tsx
  ImportRegexScriptModal.tsx
  ImportWorldBookModal.tsx
  LoadingTransition.tsx
  LoginModal.tsx
  MainLayout.tsx
  MobileBottomNav.tsx
  ModelSidebar.tsx
  PresetEditor.tsx
  PromptEditor.tsx
  RegexScriptEditor.tsx
  RegexScriptEntryEditor.tsx
  SettingsDropdown.tsx
  Sidebar.tsx
  TagColorEditor.tsx
  UserTour.tsx
  WorldBookEditor.tsx
  WorldBookEntryEditor.tsx
contexts/
  SoundContext.tsx
  SymbolColorStore.ts
docs/
  GETTING_STARTED.md
  PROBLEM.md
  VERCEL_DEPLOYMENT.md
function/
  character/
    delete.ts
    import.ts
    list.ts
  data/
    export-import.ts
    google-control.ts
    google-request.ts
  dialogue/
    chat.ts
    delete.ts
    edit.ts
    incremental-info.ts
    info.ts
    init.ts
    save-prompts.ts
    truncate.ts
    update.ts
  preset/
    download.ts
    edit.ts
    global.ts
    import.ts
  regex/
    add.ts
    delete.ts
    get-setting.ts
    get.ts
    global.ts
    import.ts
    update-setting.ts
    update.ts
  worldbook/
    bulk-operations.ts
    delete.ts
    edit.ts
    global.ts
    import.ts
    info.ts
    settings.ts
hooks/
  useTour.ts
lib/
  adapter/
    tagReplacer.ts
  core/
    agent-engine.ts
    agent-service.ts
    agent-tools.ts
    character-dialogue.ts
    character-history.ts
    character.ts
    preset-assembler.ts
    prompt-assembler.ts
    regex-processor.ts
    world-book.ts
  data/
    agent-operation.ts
    character-dialogue-operation.ts
    character-record-operation.ts
    local-storage.ts
    preset-operation.ts
    regex-script-operation.ts
    world-book-operation.ts
  models/
    agent-model.ts
    character-dialogue-model.ts
    character-model.ts
    character-prompts-model.ts
    node-model.ts
    parsed-response.ts
    preset-model.ts
    rawdata-model.ts
    regex-script-model.ts
    world-book-model.ts
  nodeflow/
    ContextNode/
      ContextNode.ts
      ContextNodeTools.ts
    LLMNode/
      LLMNode.ts
      LLMNodeTools.ts
    OutputNode/
      OutputNode.ts
    PresetNode/
      PresetNode.ts
      PresetNodeTools.ts
    RegexNode/
      RegexNode.ts
      RegexNodeTools.ts
    UserInputNode/
      UserInputNode.ts
    WorldBookNode/
      WorldBookNode.ts
      WorldBookNodeTools.ts
    NodeBase.ts
    NodeContext.ts
    NodeTool.ts
    types.ts
    WorkflowEngine.ts
  prompts/
    character-prompts.ts
    preset-prompts.ts
  workflow/
    examples/
      DialogueWorkflow.ts
    BaseWorkflow.ts
utils/
  character-parser.ts
  google-analytics.ts
  response-parser.ts
  version-compare.ts
.env.example
.gitignore
docker-compose.yml
Dockerfile
eslint.config.mjs
LICENSE
next.config.ts
package.json
postcss.config.mjs
README_ZH.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/build.yml">
name: Build and Package
on:
  workflow_dispatch:
jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        include:
          - os: ubuntu-latest
            artifact_name: Narratium-linux
            asset_name: narratium-linux.tar.gz
            output_dir: pake/Narratium-linux
          - os: windows-latest
            artifact_name: Narratium-windows
            asset_name: narratium-windows.zip
            output_dir: pake/Narratium-win32
          - os: macos-latest
            artifact_name: Narratium-macos
            asset_name: narratium-macos.dmg
            output_dir: pake/Narratium.app
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
    - name: Install Linux dependencies
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt update
        sudo apt install -y libwebkit2gtk-4.1-dev \
          build-essential \
          curl \
          wget \
          file \
          libxdo-dev \
          libssl-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev
    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
        run_install: false
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    - name: Install dependencies
      run: pnpm install
    - name: Build Next.js app
      run: pnpm build
    - name: Install Pake CLI
      run: npm install -g pake-cli
    - name: Debug - Check icon files
      if: matrix.os != 'windows-latest'
      run: |
        echo "Checking icon files:"
        ls -la public/
        echo "Icon file exists:"
        if [ -f "public/icon.ico" ]; then echo "Yes"; else echo "No"; fi
        if [ -f "public/icon.png" ]; then echo "Yes"; else echo "No"; fi
        if [ -f "public/icon.icns" ]; then echo "Yes"; else echo "No"; fi
    - name: Debug - Check icon files (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        echo "Checking icon files:"
        Get-ChildItem -Path public/
        echo "Icon file exists:"
        if (Test-Path -Path "public/icon.ico") { echo "Yes" } else { echo "No" }
        if (Test-Path -Path "public/icon.png") { echo "Yes" } else { echo "No" }
        if (Test-Path -Path "public/icon.icns") { echo "Yes" } else { echo "No" }
    - name: Build with Pake (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: pake out/index.html --name Narratium --use-local-file --icon public/icon.png
    - name: Build with Pake (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        mkdir -p pake/icons
        Copy-Item "public\icon.ico" "pake\icons\icon.ico" -Force
        pake out/index.html --name Narratium
    - name: Build with Pake (macOS)
      if: matrix.os == 'macos-latest'
      run: pake out/index.html --name Narratium --use-local-file --icon public/icon.icns
    - name: Debug - List files (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        echo "Current directory:"
        pwd
        echo "Files in current directory:"
        ls -la
        echo "Files in pake directory (if exists):"
        ls -la pake || echo "pake directory not found"
        echo "Finding DMG files:"
        find . -name "*.dmg"
    - name: Package artifacts (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        mkdir -p dist
        echo "Current directory:"
        pwd
        echo "Files in current directory:"
        ls -la
        if [ -f "pake.deb" ]; then
          echo "Found pake.deb file, using it as the artifact"
          cp pake.deb dist/${{ matrix.asset_name }}
        else
          DEB_FILE=$(find . -name "*.deb" | head -n 1)
          if [ -n "$DEB_FILE" ]; then
            echo "Found .deb file: $DEB_FILE"
            cp "$DEB_FILE" dist/${{ matrix.asset_name }}
          else
            echo "No .deb file found, trying to find Narratium directory"
            NARRATIUM_DIR=$(find . -type d -name "Narratium*" | grep -v "node_modules" | head -n 1)
            if [ -z "$NARRATIUM_DIR" ]; then
              echo "Error: Could not find Narratium directory or .deb file"
              exit 1
            else
              echo "Found Narratium directory: $NARRATIUM_DIR"
              tar -czf dist/${{ matrix.asset_name }} "$NARRATIUM_DIR"
            fi
          fi
        fi
    - name: Package artifacts (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        mkdir -p dist
        New-Item -Path "temp_for_zip" -ItemType Directory -Force
        $msiFile = Get-ChildItem -Path "C:\npm\prefix\node_modules\pake-cli\src-tauri\target\release\bundle\msi\*.msi" -File | Select-Object -First 1
        if ($msiFile) {
          echo "Found MSI file: $($msiFile.FullName)"
          Copy-Item $msiFile.FullName -Destination "temp_for_zip\Narratium.msi"
          $exeFile = Get-ChildItem -Path "C:\npm\prefix\node_modules\pake-cli\src-tauri\target\release\*.exe" -File | Select-Object -First 1
          if ($exeFile) {
            echo "Found EXE file: $($exeFile.FullName)"
            Copy-Item $exeFile.FullName -Destination "temp_for_zip\Narratium.exe"
          }
          Set-Content -Path "temp_for_zip\README.txt" -Value "Narratium Windows Installation`n`nThis package contains:`n- Narratium.msi: Windows installer`n`nTo install, double-click the MSI file."
          Compress-Archive -Path "temp_for_zip\*" -DestinationPath "dist\${{ matrix.asset_name }}" -Force
        } else {
          $msiFile = Get-ChildItem -Path . -Recurse -Filter "*.msi" | Where-Object { $_.FullName -like "*Narratium*.msi" } | Select-Object -First 1
          if ($msiFile) {
            echo "Found MSI file via fallback search: $($msiFile.FullName)"
            Copy-Item $msiFile.FullName -Destination "temp_for_zip\Narratium.msi"
            Set-Content -Path "temp_for_zip\README.txt" -Value "Narratium Windows Installation`n`nThis package contains:`n- Narratium.msi: Windows installer`n`nTo install, double-click the MSI file."
            Compress-Archive -Path "temp_for_zip\*" -DestinationPath "dist\${{ matrix.asset_name }}" -Force
          } else {
            echo "Error: Could not find MSI file"
            exit 1
          }
        }
    - name: Package artifacts (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        mkdir -p dist
        DMG_FILE=$(find . -name "Narratium*.dmg" | head -n 1)
        if [ -z "$DMG_FILE" ]; then
          echo "Error: DMG file not found"
          exit 1
        else
          echo "Found DMG file: $DMG_FILE"
          cp "$DMG_FILE" dist/${{ matrix.asset_name }}
        fi
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: dist/${{ matrix.asset_name }}
        retention-days: 30
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/Narratium-linux/narratium-linux.tar.gz
            artifacts/Narratium-windows/narratium-windows.zip
            artifacts/Narratium-macos/narratium-macos.dmg
          draft: false
          prerelease: false
</file>

<file path=".github/workflows/BuildDockerImage.yml">
name: Build and Push Docker Image
on:
  workflow_dispatch:
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get latest tag as version
        id: get_latest_tag
        run: |
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "latest")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/narratium-ai:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/narratium-ai:${{ env.LATEST_TAG }}
</file>

<file path=".github/workflows/sync.yml">
name: Upstream Sync
permissions:
  contents: write
on:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:
jobs:
  sync_latest_from_upstream:
    name: Sync latest commits from upstream repo
    runs-on: ubuntu-latest
    if: ${{ github.event.repository.fork }}
    steps:
      - name: Checkout target repo
        uses: actions/checkout@v3
      - name: Sync upstream changes
        id: sync
        uses: aormsby/Fork-Sync-With-Upstream-action@v3.4
        with:
          upstream_sync_repo: Narratium/Narratium.ai
          upstream_sync_branch: main
          target_sync_branch: main
          target_repo_token: ${{ secrets.GITHUB_TOKEN }}
          test_mode: false
      - name: Sync check
        if: failure()
        run: |
          echo "[Error] Áî±‰∫é‰∏äÊ∏∏‰ªìÂ∫ìÁöÑ workflow Êñá‰ª∂ÂèòÊõ¥ÔºåÂØºËá¥ GitHub Ëá™Âä®ÊöÇÂÅú‰∫ÜÊú¨Ê¨°Ëá™Âä®Êõ¥Êñ∞Ôºå‰Ω†ÈúÄË¶ÅÊâãÂä® Sync Fork ‰∏ÄÊ¨°„ÄÇ"
          exit 1
</file>

<file path="app/character/page.tsx">
import { useState, useEffect, useRef } from "react";
import { useSearchParams } from "next/navigation";
import { useLanguage } from "@/app/i18n";
import CharacterSidebar from "@/components/CharacterSidebar";
import { PromptType } from "@/lib/models/character-prompts-model";
import { v4 as uuidv4 } from "uuid";
import { initCharacterDialogue } from "@/function/dialogue/init";
import { getCharacterDialogue } from "@/function/dialogue/info";
import { handleCharacterChatRequest } from "@/function/dialogue/chat";
import { switchDialogueBranch } from "@/function/dialogue/truncate";
import { deleteDialogueNode } from "@/function/dialogue/delete";
import CharacterChatPanel from "@/components/CharacterChatPanel";
import WorldBookEditor from "@/components/WorldBookEditor";
import RegexScriptEditor from "@/components/RegexScriptEditor";
import PresetEditor from "@/components/PresetEditor";
import CharacterChatHeader from "@/components/CharacterChatHeader";
import UserTour from "@/components/UserTour";
import { useTour } from "@/hooks/useTour";
interface Character {
  id: string;
  name: string;
  personality?: string;
  avatar_path?: string;
}
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp?: string;
}
‚ãÆ----
const switchToView = (targetView: "chat" | "worldbook" | "regex" | "preset") =>
const toggleView = () =>
const toggleRegexEditor = () =>
const truncateMessagesAfter = async (nodeId: string) =>
const handleRegenerate = async (nodeId: string) =>
const fetchLatestDialogue = async () =>
‚ãÆ----
const loadCharacterAndDialogue = async () =>
‚ãÆ----
const initializeNewDialogue = async (charId: string) =>
const handleSendMessage = async (message: string) =>
‚ãÆ----
const handleSwitchToPresetView = (event: any) =>
‚ãÆ----
const toggleSidebar = () =>
const handleSuggestedInput = (input: string) =>
‚ãÆ----
onViewSwitch=
</file>

<file path="app/character-cards/page.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { motion } from "framer-motion";
import ImportCharacterModal from "@/components/ImportCharacterModal";
import EditCharacterModal from "@/components/EditCharacterModal";
import DownloadCharacterModal from "@/components/DownloadCharacterModal";
import CharacterCardGrid from "@/components/CharacterCardGrid";
import CharacterCardCarousel from "@/components/CharacterCardCarousel";
import { getAllCharacters } from "@/function/character/list";
import { deleteCharacter } from "@/function/character/delete";
import { handleCharacterUpload } from "@/function/character/import";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
‚ãÆ----
const checkMobile = () =>
‚ãÆ----
const fetchCharacters = async () =>
const handleDeleteCharacter = async (characterId: string) =>
const handleEditClick = (character: Character, e: React.MouseEvent) =>
const handleEditSuccess = () =>
const downloadPresetCharacters = async () =>
</file>

<file path="app/contexts/SoundContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
interface SoundContextType {
  soundEnabled: boolean;
  toggleSound: () => void;
}
‚ãÆ----
export function useSoundContext()
interface SoundProviderProps {
  children: ReactNode;
}
export function SoundProvider(
‚ãÆ----
const toggleSound = () =>
</file>

<file path="app/creator-area/page.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
</file>

<file path="app/creator-input/page.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import { Send, Sparkles } from "lucide-react";
import { useRouter } from "next/navigation";
import { useLanguage } from "../i18n";
‚ãÆ----
const handleSubmit = async (e: React.FormEvent) =>
const handleKeyPress = (e: React.KeyboardEvent) =>
‚ãÆ----
onChange=
‚ãÆ----
placeholder=
</file>

<file path="app/i18n/locales/en.json">
{
  "common": {
    "save": "Save",
    "cancel": "Cancel",
    "close": "Close",
    "return": "Return",
    "settings": "Settings",
    "switchToEnglish": "Switch to English",
    "switchToChinese": "Switch to Chinese",
    "soundOn": "Sound On",
    "soundOff": "Sound Off",
    "saving": "Saving...",
    "defaultAutoFillFileName": "Default: Auto-fill from file name",
    "exportData": "Export Data",
    "exportDataToGoogle": "Export Data To Google",
    "importData": "Import Data",
    "importDataFromGoogle": "Import Data From Google",
    "exportFailed": "Export failed, please try again",
    "importFailed": "Import failed, please try again"
  },
  "sidebar": {
    "home": "Home",
    "gameArea": "Game Area",
    "creator": "Creator",
    "creationArea": "Creation Area",
    "historyRecords": "History Records",
    "newStory": "New Adventure",
    "storyCollection": "Story Collection",
    "characterCards": "Character Cards",
    "characterMarket": "Character Market",
    "login": "Login & Explore",
    "nologin": "Define User Name",
    "logout": "Logout",
    "collapseHome": "Collapse Home",
    "expandHome": "Expand Home",
    "collapseCreation": "Collapse Game Area",
    "expandCreation": "Expand Game Area",
    "collapseCreator": "Collapse Creation Area",
    "expandCreator": "Expand Creation Area",
    "goToUpdate": "Go to Update",
    "newVersionAvailable": "New Version Available",
    "currentVersion": "Current: v{version}"
  },
  "modelSettings": {
    "title": "Model Settings",
    "llmType": "LLM Type",
    "baseUrl": "Base URL",
    "model": "Model",
    "apiKey": "API Key",
    "language": "Output Language",
    "chinese": "Chinese",
    "english": "English",
    "saveSettings": "Click to enable",
    "settingsSaved": "Settings Saved",
    "commonModels": "Common Models:",
    "modelList": "Model List",
    "selectModel": "Select a model...",
    "modelListUnavailable": "Model list unavailable",
    "configurations": "API Configurations",
    "newConfig": "New Config",
    "configName": "Configuration Name",
    "configNamePlaceholder": "My API Configuration",
    "createConfig": "Create Configuration",
    "nameRequired": "Name is required",
    "cannotDeleteLastConfig": "Cannot delete the last configuration",
    "confirmDelete": "Are you sure you want to delete this configuration?",
    "createFirstConfig": "Create Your First Configuration",
    "noConfigs": "No API configurations yet",
    "getModelList": "Get Model List",
    "getModelListSuccess": "Get Model List Success",
    "getModelListError": "Get Model List Error",
    "configCreated": "Configuration created",
    "doubleClickToEditName": "Double click to edit name",
    "testModel": "Test Model",
    "testing": "Testing...",
    "testSuccess": "Model test successful",
    "testError": "Model test failed",
    "apiTestFailed": "API test failed",
    "modelTestFailed": "Model test failed"
  },
  "llmSettings": {
    "title": "Settings",
    "modelType": "Model Type",
    "presets": "Presets",
    "creative": "Creative",
    "balanced": "Balanced",
    "precise": "Precise",
    "commonParams": "Common",
    "advancedParams": "Advanced",
    "temperature": "Temperature",
    "temperatureDescription": "Controls randomness in text generation. Higher values produce more diverse outputs, lower values produce more deterministic outputs.",
    "maxTokens": "Max Tokens",
    "maxTokensDescription": "Maximum number of tokens to generate. Leave empty to use model default.",
    "timeout": "Timeout",
    "timeoutDescription": "Timeout for API requests in milliseconds. Leave empty to use default.",
    "maxRetries": "Max Retries",
    "maxRetriesDescription": "Maximum number of retries when API requests fail.",
    "topP": "Top P",
    "topPDescription": "Controls diversity via nucleus sampling. Lower values consider fewer high-probability options.",
    "frequencyPenalty": "Frequency Penalty",
    "frequencyPenaltyDescription": "Penalizes tokens based on their frequency in the text so far. Higher values reduce repetition.",
    "presencePenalty": "Presence Penalty",
    "presencePenaltyDescription": "Penalizes tokens that have appeared in the text so far. Higher values encourage new topics.",
    "topK": "Top K",
    "topKDescription": "Limits token selection to the K most likely tokens. Lower values make output more focused.",
    "repeatPenalty": "Repeat Penalty",
    "repeatPenaltyDescription": "Penalizes repeated tokens. Higher values reduce repetition in Ollama models.",
    "optional": "Optional, leave empty for default"
  },
  "sessionList": {
    "loading": "Summoning history scrolls...",
    "noHistory": "No history records yet",
    "continue": "Continue",
    "delete": "Delete"
  },
  "homePage": {
    "slogan": "Within each of us burns a flame",
    "newAdventure": "Begin a New Adventure",
    "continueJourney": "Continue Your Journey",
    "immediatelyStart": "Immediately Start"
  },
  "auth": {
    "username": "Username",
    "password": "Password",
    "login": "Login",
    "register": "Register",
    "welcomeBack": "Welcome Back",
    "continueJourney": "Sign in to continue your journey",
    "emailPlaceholder": "Press Enter to apply username",
    "passwordPlaceholder": "Enter your password...",
    "codePlaceholder": "Enter the verification code...",
    "wizardQuestion": "‚ú® Brave adventurer, please leave your name",
    "spellQuestion": "üîÆ Cast your protective spell, it will guard your fantastic journey!",
    "codeQuestion": "‚ö° Enter the mysterious runes sent by the cosmic sea to prove your identity!",
    "getCode": "Get Code",
    "openingMagicDoor": "Opening the magic door...",
    "magicSpell": "Password Login",
    "starCode": "Verification Code",
    "agreementText": "By continuing, you agree to our",
    "termsOfService": "Terms of Service",
    "privacyPolicy": "Privacy Policy"
  },
  "storiesPage": {
    "title": "My Story Collection",
    "createNewStory": "Create New Story",
    "loading": "Loading stories...",
    "noStories": "You haven't created any stories yet",
    "createFirstStory": "Create Your First Story",
    "recentlyCreated": "Recently Created",
    "fetchError": "Failed to fetch stories",
    "edit": "Edit",
    "delete": "Delete",
    "play": "Play",
    "deleteConfirm": "Are you sure you want to delete this story?",
    "deleteSuccess": "Story deleted",
    "deleteFailed": "Failed to delete story"
  },
  "newStory": {
    "title": "Create New Story",
    "editTitle": "Edit Story",
    "storyTitle": "Story Title",
    "storyFramework": "Story Setting",
    "characterInfo": "Character Information",
    "questionTitle": "‚ú® What name shall your legend be known by?",
    "questionFramework": "‚ú® In what mystical realm will your adventure unfold?",
    "questionCharacter": "‚ú® What form will you take in this immortal tale?",
    "titlePlaceholder": "Name your epic tale",
    "frameworkPlaceholder": "Describe your fantasy world",
    "characterPlaceholder": "Reveal your hero's identity",
    "create": "Begin Your Legend",
    "creating": "Weaving your legendary tale...",
    "update": "Update Story",
    "updating": "Updating...",
    "cancel": "Cancel",
    "fillAllFields": "Please fill in all required fields",
    "createFailed": "Failed to create story, please try again",
    "updateFailed": "Failed to update story, please try again",
    "updateSuccess": "Story updated successfully"
  },
  "notFound": {
    "title": "The Path Ahead Is Not Yet Open",
    "subtitle": "This Realm Is Still Under Construction",
    "message": "Noble Dreamer, the magical scroll you seek appears to be lost or not yet created.",
    "backToHome": "Return to Home",
    "exploreMore": "Explore Later"
  },
  "game": {
    "fetchStoryFailed": "Failed to fetch story details",
    "fetchStoryFailedRetry": "Failed to fetch story details, please try again",
    "loadSessionFailed": "Failed to load session history",
    "loadSessionFailedRetry": "Failed to load session history, please try again",
    "initializeFailed": "Game initialization failed",
    "setupFailed": "Game setup failed",
    "cannotReadResponseStream": "Cannot read response stream",
    "generatingStory": "Generating story...",
    "actionFailed": "Action failed",
    "confirmDelete": "Are you sure you want to delete this story? This action cannot be undone.",
    "deleteFailed": "Failed to delete story",
    "deleteFailedRetry": "Failed to delete story, please try again",
    "storyNotExist": "Story of Session Not Found", 
    "cannotFindStory": "Cannot find story with ID {id}",
    "backToStoryList": "Back to Story List",
    "expandSidebar": "Expand Sidebar",
    "collapseSidebar": "Collapse Sidebar",
    "storySummary": "Story Summary",
    "storyFramework": "Story Framework",
    "characterInfo": "Character Information",
    "starting": "Starting...",
    "startAdventure": "Begin Adventure",
    "inputCustomAction": "Enter custom action...",
    "execute": "Execute",
    "deleting": "Deleting...",
    "deleteStory": "Delete Story",
    "gameInfo": "Game Information",
    "memoryManagement": "Memory Management",
    "navigation": "Navigation",
    "collapse": "Collapse",
    "expand": "Expand",
    "memoryPlaceholder": "Game memories will be displayed here",
    "memoryDescription": "Memory management allows you to view and edit segments of the game",
    "memoryInstructions": "Click a node to view full content, edges show your actions",
    "editMemory": "Edit Memory",
    "memorySummary": "Memory Summary",
    "fullMemoryContent": "Full Memory Content",
    "editMemoryPlaceholder": "Edit your game memory...",
    "noSessionFound": "No Session Found",
    "startSessionFirst": "Please start a game session first to view memories",
    "loadingMemories": "Loading memories...",
    "jumpToNode": "Jump to this node",
    "expandMemory": "Expand memory content"
  },
  "characterCardsPage": {
    "title": "Character Cards",
    "importCharacter": "Import Character",
    "importFirstCharacter": "Import Your First Character",
    "noCharacters": "You don't have any characters yet",
    "loading": "Loading...",
    "downloadingPresets": "Downloading preset characters...",
    "fetchError": "Failed to fetch characters",
    "deleteFailed": "Failed to delete character",
    "delete": "Delete",
    "edit": "Edit",
    "chat": "Chat",
    "recentlyCreated": "Recently Created",
    "downloadCharacter": "Community Download Character"
  },
  "editCharacterModal": {
    "title": "Edit Character",
    "name": "Name",
    "description": "Description",
    "personality": "Personality",
    "scenario": "Scenario",
    "firstMessage": "Opening Message",
    "mesExample": "Message Examples",
    "creatorComment": "Creator Comments",
    "save": "Save",
    "cancel": "Cancel"
  },
  "importCharacterModal": {
    "title": "Import Character",
    "description": "Select or drag and drop a SillyTavern PNG character card file to import",
    "dragOrClick": "Drag file here or click to select",
    "pngFormat": "Only SillyTavern PNG character card files are supported",
    "pngOnly": "Please select a SillyTavern PNG file",
    "noFileSelected": "Please select a file first",
    "uploadFailed": "Upload failed, please try again",
    "import": "Import",
    "uploading": "Uploading..."
  },
  "characterMarketPage": {
    "description": "Explore a variety of fascinating characters to bring your stories to life",
    "searchPlaceholder": "Search character names or descriptions",
    "allTags": "All",
    "loading": "Loading characters...",
    "noResults": "No matching characters found",
    "clearFilters": "Clear Filters",
    "by": "By:",
    "download": "Download Character",
    "viewDetails": "View Details"
  },
  "characterChat": {
    "navigation": "Navigation",
    "characterInfo": "Character Info",
    "actions": "Actions",
    "expandSidebar": "Expand Sidebar",
    "collapseSidebar": "Collapse Sidebar",
    "backToCharacters": "Back to Characters",
    "Conversation": "Context Manager",
    "noPersonality": "No personality defined",
    "typeMessage": "Type a message...",
    "startConversation": "Start a conversation...",
    "send": "Send",
    "isTyping": "is typing...",
    "suggestedResponse1": "Tell me more",
    "suggestedResponse2": "What happened next?",
    "suggestedResponse3": "How do you feel about that?",
    "promptMode": "Prompt Mode",
    "companionMode": "Progression Mode",
    "nsfwMode": "Companion Mode",
    "explicitMode": "NSFW Mode",
    "customMode":"custom Mode",
    "innerThought": "Inner Thought",
    "screen": "Screen",
    "speech": "Speech",
    "nextPrompt": "Next Step",
    "storyProgress": "Story Progress",
    "storyProgressHint": "Please advance the story plot forward, make the story more interesting and engaging.",
    "perspective": "Perspective",
    "novelPerspective": "Novel Perspective",
    "protagonistPerspective": "Protagonist Perspective",
    "novelPerspectiveHint": "Please use a novel perspective to narrate, describing the scene and character actions in third person.",
    "protagonistPerspectiveHint": "Please use the protagonist's perspective to narrate, using first person to describe thoughts and feelings.",
    "sceneTransition": "Scene Setting",
    "sceneTransitionHint": "Please add scene descriptions and environmental details to enhance the atmosphere.",
    "screenPlaceholder": "Describe the scene or actions...",
    "speechPlaceholder": "What does the character say...",
    "innerThoughtPlaceholder": "What does the character think...",
    "playerInput": "Player Input",
    "responseInstructions": "Response Instructions",
    "characterStatus": "Character Status",
    "responseLength": "Model Response Length",
    "customPrompt": "Custom Prompt",
    "customPromptFor": "Custom Prompts",
    "presets": "Presets",
    "presetEditor": "Preset Editor",
    "githubPresets": "GitHub Presets",
    "noPresets": "No presets available",
    "prefixPrompt": "Prefix Prompt",
    "chainOfThoughtPrompt": "Chain of Thought",
    "suffixPrompt": "Suffix Prompt",
    "prefixPromptDescription": "The prefix prompt is placed at the beginning of the prompt, used to set the character's basic behavior and background.",
    "chainOfThoughtPromptDescription": "The chain of thought prompt is placed in the middle of the prompt, used to guide the character's thinking process.",
    "suffixPromptDescription": "The suffix prompt is placed at the end of the prompt, used to emphasize the character's response format and restrictions.",
    "prefixPromptPlaceholder": "Enter prefix prompt...",
    "chainOfThoughtPromptPlaceholder": "Enter chain of thought prompt...",
    "suffixPromptPlaceholder": "Enter suffix prompt...",
    "autoSaveEnabled": "Auto-save enabled",
    "initializing": "Initializing character...",
    "extractingTemplate": "Extracting character template...",
    "loadingTimeHint": "Loading usually takes 5-20 seconds. If it exceeds 30 seconds, please check your API configuration.",
    "error": "Error",
    "characterNotFound": "Character not found",
    "loading": "Loading...Parsing status, please wait...",
    "worldBook": "World Book",
    "regex": "Regex Script",
    "preset": "Preset",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "filtered": "Filtered",
    "advancedSettings": "Advanced Settings",
    "tagColorEditor": "Tag Color Editor",
    "enterTagName": "Enter tag name...",
    "add": "Add",
    "saveChanges": "Save Changes",
    "enterSymbol": "When entering a tag, it will match <tag>...</tag>",
    "enableStreaming": "Enable Streaming",
    "disableStreaming": "Disable Streaming",
    "jumpToMessage": "Jump to Message",
    "regenerateMessage": "Regenerate Message",
    "enableFastModel": "Enable Fast Mode",
    "disableFastModel": "Disable Fast Mode"
  },
  "preset": {
    "title": "Preset Manager",
    "createPreset": "Create Preset",
    "importPreset": "Import Preset",
    "sortBy": "Sort By",
    "sortOrder": "Sort Order",
    "filterBy": "Filter By",
    "ascending": "Ascending",
    "descending": "Descending",
    "asc": "Asc",
    "desc": "Desc",
    "all": "All",
    "active": "With Prompts",
    "empty": "Empty",
    "name": "Name",
    "promptCount": "Prompt Count",
    "lastUpdated": "Last Updated",
    "status": "Status",
    "prompts": "Prompts",
    "updated": "Updated",
    "actions": "Actions",
    "active_status": "Active",
    "empty_status": "Empty",
    "total": "Total",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "filtered": "Filtered",
    "loading": "Loading Presets...",
    "noPresetsFound": "No Presets Found",
    "createFirstPreset": "Create your first preset to get started",
    "enterPresetName": "Enter preset name:",
    "createSuccess": "Preset created successfully",
    "createFailed": "Failed to create preset",
    "deleteConfirm": "Are you sure you want to delete this preset?",
    "deleteSuccess": "Preset deleted successfully",
    "deleteFailed": "Failed to delete preset",
    "loadFailed": "Failed to load presets",
    "loadDetailsFailed": "Failed to load preset details",
    "expandDetails": "Expand details",
    "collapseDetails": "Collapse details",
    "promptsTitle": "Prompts",
    "addPrompt": "Add Prompt",
    "enterPromptName": "Enter prompt name:",
    "addPromptSuccess": "Prompt added successfully",
    "addPromptFailed": "Failed to add prompt",
    "deletePromptConfirm": "Are you sure you want to delete this prompt?",
    "deletePromptSuccess": "Prompt deleted successfully",
    "deletePromptFailed": "Failed to delete prompt",
    "noPromptsInPreset": "No prompts in this preset",
    "enabled_prompt": "Enabled",
    "disabled_prompt": "Disabled",
    "system": "System",
    "deletePrompt": "Delete prompt",
    "promptEnabledSuccess": "Prompt enabled successfully",
    "promptDisabledSuccess": "Prompt disabled successfully",
    "togglePromptFailed": "Failed to toggle prompt",
    "applyPresetSuccess": "Preset applied successfully",
    "applyPresetFailed": "Failed to apply preset",
    "applyPreset": "Apply Preset",
    "presetApplied": "Preset Active",
    "cannotApplyEmpty": "Cannot apply empty preset",
    "enablePreset": "Enable preset",
    "disablePreset": "Disable preset",
    "presetEnabledSuccess": "Preset enabled successfully",
    "presetEnabledExclusiveSuccess": "Preset enabled successfully (other presets disabled)",
    "presetDisabledSuccess": "Preset disabled successfully",
    "togglePresetFailed": "Failed to toggle preset",
    "presetDisabled": "Preset is disabled",
    "cannotApplyDisabled": "Cannot apply disabled preset",
    "toggle": "Toggle",
    "presetName": "Preset Name",
    "presetNamePlaceholder": "Enter preset name",
    "presetNameRequired": "Preset name is required",
    "creating": "Creating...",
    "create": "Create",
    "cancel": "Cancel",
    "editPrompt": "Edit Prompt",
    "promptContent": "Prompt Content",
    "saving": "Saving",
    "save": "Save"
  },
  "importPreset": {
    "title": "Import Preset",
    "dragDropFile": "Import Preset File",
    "dropFileHere": "Drop your file here",
    "browseFiles": "Browse Files",
    "dragAndDrop": "Drag and drop a JSON preset file, or click to browse",
    "importing": "Importing...",
    "importSuccess": "Import Successful",
    "importFailed": "Import Failed",
    "presetImported": "Preset has been imported successfully!",
    "importError": "An error occurred during import",
    "customizePreset": "Customize Preset",
    "presetName": "Preset Name",
    "presetNameDesc": "Leave empty to use the original name from the file",
    "confirmImport": "Confirm Import",
    "guidelines": "Import Guidelines",
    "jsonFormat": "Preset files must be in JSON format",
    "validStructure": "Files should contain valid preset structure with prompts",
    "noOverwrite": "Existing presets with same name will not be overwritten",
    "maxFileSize": "Maximum file size: 10MB",
    "selectJsonFile": "Please select a JSON file",
    "failedToImport": "Failed to import",
    "cancel": "Cancel"
  },
  "worldBook": {
    "title": "World Book",
    "addEntry": "Add Entry",
    "sortBy": "Sort by",
    "sortOrder": "Sort Order",
    "asc": "Ascending",
    "desc": "Descending",
    "importing": "Importing",
    "imported": "Global",
    "importedAt": "Imported at:",
    "saveAsGlobalWorldBook": "Save as Global World Book",
    "globalName": "Global Name",
    "description": "Description (Optional)",
    "enterGlobalWorldBookName": "Default to use filename",
    "enterDescriptionForThisGlobalWorldBook": "Default to empty description",
    "importWorldBook": "Import World Book",
    "dragDropJson": "Drag and drop JSON file here",
    "jsonFileOnly": "JSON files only",
    "importResults": "Import Results",
    "importedEntries": "Imported {count} entries",
    "skippedEntries": "Skipped {count} entries",
    "importErrors": "Import Errors",
    "loading": "Loading world book data...",
    "noEntries": "No world book entries yet",
    "noEntriesDescription": "Click \"Create Entry\" to start creating your first world book entry",
    "createEntry": "Create Entry",
    "editEntry": "Edit Entry",
    "newEntry": "New World Book Entry",
    "deleteEntry": "Delete Entry",
    "bulkOperations": "Bulk Operations",
    "enableAll": "Enable All",
    "disableAll": "Disable All",
    "enableDisabled": "Enable Disabled",
    "disableEnabled": "Disable Enabled",
    "enabledAll": "All entries enabled",
    "disabledAll": "All entries disabled",
    "noEntriesWithStatus": "No entries found with status \"{status}\"",
    "bulkEnable": "Bulk Enable",
    "bulkDisable": "Bulk Disable",
    "bulkDelete": "Bulk Delete",
    "selectAll": "Select All",
    "selectEntriesFirst": "Please select entries to operate on first",
    "confirmDelete": "Are you sure you want to delete this entry?",
    "saveSuccess": "Save successful",
    "saveFailed": "Save failed",
    "deleteSuccess": "Delete successful",
    "deleteFailed": "Delete failed",
    "bulkOperationFailed": "Bulk operation failed",
    "keywordRequired": "At least one keyword is required",
    "contentRequired": "Content cannot be empty",
    "totalCount": "Total:",
    "enabledCount": "Enabled:",
    "disabledCount": "Disabled:",
    "selectedItems": "Selected",
    "items": "items",
    "contextWindow": "Context Window:",
    "status": "Status",
    "comment": "Comment",
    "keywords": "Keywords",
    "position": "Position",
    "depth": "Depth",
    "characterCount": "Characters",
    "priority": "Priority",
    "actions": "Actions",
    "enabled": "Enabled",
    "disabled": "Disabled",
    "regex": "Regex",
    "constant": "Constant",
    "noComment": "No comment",
    "edit": "Edit",
    "delete": "Delete",
    "contentPreview": "Content Preview",
    "noContent": "No content",
    "secondaryKeywords": "Secondary Keywords",
    "selectiveMatching": "Selective Matching:",
    "tokenCount": "Token Count:",
    "lastUpdated": "Last Updated:",
    "totalKeywords": "Total Keywords:",
    "notCalculated": "Not calculated",
    "yes": "Yes",
    "no": "No",
    "commentTitle": "Comment/Title",
    "commentPlaceholder": "Enter comment or title",
    "insertionOrder": "Insertion Order",
    "primaryKeywords": "Primary Keywords",
    "keywordPlaceholder": "Enter keyword",
    "addKeyword": "Add Keyword",
    "removeKeyword": "Remove Keyword",
    "depthLabel": "Depth",
    "enabledLabel": "Enabled",
    "regexLabel": "Regular Expression",
    "selectiveLabel": "Selective Matching",
    "constantLabel": "Constant Entry",
    "contentLabel": "Content",
    "contentPlaceholder": "Enter world book content...",
    "characters": "characters",
    "save": "Save",
    "cancel": "Cancel",
    "saving": "Saving...",
    "positionOptions": {
      "systemPromptStart": "System Prompt Start",
      "afterSystemPrompt": "After System Prompt",
      "userMessageStart": "User Message Start",
      "afterResponseMode": "After Response Mode",
      "basedOnDepth": "Based on Depth"
    },
    "toggleFailed": "Toggle failed",
    "enableEntry": "Enable entry",
    "disableEntry": "Disable entry",
    "toggle": "Toggle",
    "item": "item",
    "confirmBulkDisable": "This action will disable all entries",
    "importFromJson": "Import from JSON",
    "importValidationFailed": "Import validation failed",
    "selectJsonFile": "Select JSON file",
    "importFromGlobal": "Import from Global World Book",
    "noGlobalWorldBooks": "No global world books available",
    "createGlobalWorldBookFirst": "Create a global world book first",
    "selectGlobalWorldBook": "Select Global World Book",
    "entryCount": "Entry Count",
    "createdAt": "Created At",
    "sourceCharacter": "Source Character",
    "filterBy": "Filter By",
    "filterAll": "All",
    "filterEnabled": "Enabled",
    "filterDisabled": "Disabled",
    "filterImported": "Global",
    "filteredCount": "Filtered",
    "ascending": "Ascending",
    "descending": "Descending",
    "fullscreenContent": "Large Editor",
    "exitFullscreen": "Close Editor"
  },
  "regexScriptEditor": {
    "title": "Regex Script Editor",
    "close": "Close",
    "settings": "Settings",
    "enableProcessing": "Enable regex processing",
    "applyToPrompts": "Apply to prompts",
    "applyToResponses": "Apply to responses",
    "addNewScript": "Add New Script",
    "existingScripts": "Existing Scripts",
    "noScripts": "No scripts found",
    "noScriptsDescription": "Click Add New Script to create your first regex script",
    "priority": "Priority",
    "edit": "Edit",
    "enable": "Enable",
    "disable": "Disable",
    "delete": "Delete",
    "replace": "Replace",
    "findRegex": "Find Regex",
    "replaceString": "Replace String",
    "trimStrings": "Trim Strings",
    "confirmDelete": "Are you sure you want to delete this script?",
    "deleteError": "Failed to delete script",
    "newScript": "New Script",
    "editScript": "Edit Script",
    "scriptName": "Script Name",
    "scriptNamePlaceholder": "Enter script name",
    "findRegexPlaceholder": "/pattern/flags or pattern",
    "replaceStringPlaceholder": "Replacement text (use $1, $2 for groups)",
    "disabled": "Disabled",
    "enabled": "Enabled",
    "cancel": "Cancel",
    "save": "Save",
    "saving": "Saving...",
    "loading": "Loading...",
    "requiredFields": "Please fill in all required fields",
    "saveError": "Failed to save script",
    "totalCount": "Total",
    "enabledCount": "Enabled",
    "disabledCount": "Disabled",
    "filteredCount": "Filtered",
    "sortBy": "Sort By",
    "sortOrder": "Sort Order",
    "asc": "Ascending",
    "desc": "Descending",
    "filterBy": "Filter By",
    "filterAll": "All",
    "filterEnabled": "Enabled",
    "filterDisabled": "Disabled",
    "filterImported": "Global",
    "name": "Name",
    "status": "Status",
    "globalEnabled": "Global Enabled",
    "applyToPrompt": "Apply to Prompt",
    "applyToResponse": "Apply to Response",
    "yes": "Yes",
    "no": "No",
    "importScript": "Import Script",
    "importRegexScript": "Import Regex Script",
    "importFromJson": "Import from JSON",
    "importFromGlobal": "Import from Global",
    "dragDropJson": "Drag and drop JSON file here",
    "jsonFileOnly": "JSON files only",
    "saveAsGlobalRegexScript": "Save as Global Regex Script",
    "globalName": "Global Name",
    "description": "Description",
    "enterGlobalRegexScriptName": "Default to use filename",
    "enterDescriptionForThisGlobalRegexScript": "Default to empty description",
    "importing": "Importing...",
    "importResults": "Import Results",
    "importedScripts": "Imported {count} scripts",
    "skippedScripts": "Skipped {count} scripts",
    "importErrors": "Import Errors",
    "noGlobalRegexScripts": "No global regex scripts available",
    "createGlobalRegexScriptFirst": "Create a global regex script first",
    "selectGlobalRegexScript": "Select Global Regex Script",
    "willUseEachFileName": "Each file's name will be used as the script name"
  },
  "dialogue": {
    "treeVisualization": "Context Manager",
    "node": "Dialogue Node",
    "systemMessage": "System Message",
    "jumpToNode": "Jump to Node",
    "expandNode": "Expand Node",
    "editNode": "Edit Node",
    "userInput": "User Input",
    "assistantResponse": "Assistant Response",
    "noCharacterSelected": "No Character Selected",
    "selectCharacterFirst": "Please select a character first",
    "loadingDialogue": "Loading dialogue data...",
    "noDialogueNodes": "No Dialogue Nodes",
    "startConversation": "Start a conversation to create a dialogue tree",
    "memorySummary": "Memory Summary",
    "nodeId": "Node ID",
    "startingPoint": "Opening Scene",
    "rootNodeCannotJump": "Root node is the starting point of the dialogue and cannot be jumped to",
    "response": "Response Content",
    "responsePlaceholder": "Edit the response content...",
    "resetLayout": "Reset Layout",
    "manualPositions": "Manual Positions"
  },
  "downloadModal": {
      "title": "Download Character from Community Repository",
      "loading": "Loading...",
      "fetchError": "Unable to fetch character list",
      "downloadFailed": "Download failed",
      "importFailed": "Import failed",
      "importing": "Importing...",
      "downloadAndImport": "Download and Import",
      "by": "By:",
      "unknownAuthor": "Anonymous"
  },
  "creatorInput": {
    "title": "Creator Studio",
    "subtitle": "Start creating epic stories",
    "placeholder": "Enter your creative ideas...",
    "sendMessage": "Send message",
    "enterToSend": "Press Enter to send, Shift + Enter for new line",
    "characterCount": "{count}/1000",
    "exampleStories": "Survival, Harry Potter, Lord of the Rings - any story at your will"
  },
  "tour": {
    "welcome": "Welcome to Narratium",
    "welcomeDescription": "Narratium is an intelligent character dialogue platform where you can have in-depth conversations with various AI characters and create unique story experiences. Let's explore the basic features.",
    "loginTitle": "First, Login to Your Account",
    "loginDescription": "Click here to login. Note: The username you enter may be used by AI characters as the protagonist's name, so we recommend using a name you'd like to use in stories.",
    "settingsTitle": "Configure AI Model",
    "settingsDescription": "After logging in, click the settings button in the top right corner to configure your AI model. You can choose OpenAI or Ollama and set the corresponding API keys and model parameters.",
    "worldbookTitle": "World Book Feature",
    "worldbookDescription": "World Book is used to define the character's background world, settings, and important information. AI will maintain character consistency based on the content in the World Book, making conversations more immersive.",
    "regexTitle": "Regex Scripts",
    "regexDescription": "Regex scripts allow you to customize the format and processing logic of AI replies. You can set special text replacement rules to make character expressions more unique.",
    "presetTitle": "Preset Management",
    "presetDescription": "Preset features let you save and manage different conversation settings, including character tone, style, and special instructions, making it easy to switch between different scenarios.",
    "chatTitle": "Start Conversation",
    "chatDescription": "Now you can enter messages in the input box and start exciting conversations with AI characters! AI will respond based on your World Book, regex scripts, and presets.",
    "next": "Next",
    "previous": "Previous",
    "skip": "Skip",
    "finish": "Finish",
    "resetTour": "Reset Tour"
  }
}
</file>

<file path="app/i18n/locales/zh.json">
{
  "common": {
    "save": "‰øùÂ≠ò",
    "cancel": "ÂèñÊ∂à",
    "close": "ÂÖ≥Èó≠",
    "return": "ËøîÂõû",
    "settings": "ËÆæÁΩÆ",
    "switchToEnglish": "ÂàáÊç¢‰∏∫Ëã±Êñá",
    "switchToChinese": "ÂàáÊç¢‰∏∫‰∏≠Êñá",
    "soundOn": "Â£∞Èü≥ÂºÄÂêØ",
    "soundOff": "Â£∞Èü≥ÂÖ≥Èó≠",
    "saving": "‰øùÂ≠ò‰∏≠...",
    "defaultAutoFillFileName": "ÈªòËÆ§ÔºöËá™Âä®Â°´ÂÜôÊñá‰ª∂Âêç",
    "exportData": "ÂØºÂá∫Êï∞ÊçÆ",
    "exportDataToGoogle": "ÂØºÂá∫Êï∞ÊçÆÂà∞Ë∞∑Ê≠å",
    "importData": "ÂØºÂÖ•Êï∞ÊçÆ",
    "importDataFromGoogle": "‰ªéË∞∑Ê≠åÂØºÂÖ•Êï∞ÊçÆ",
    "exportFailed": "ÂØºÂá∫Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "importFailed": "ÂØºÂÖ•Â§±Ë¥•ÔºåËØ∑ÈáçËØï"
  },
  "sidebar": {
    "home": "È¶ñÈ°µ",
    "gameArea": "Ê∏∏ÊàèÂå∫",
    "creator": "ÂàõÈÄ†ËÄÖ",
    "creationArea": "Âàõ‰ΩúÂå∫",
    "historyRecords": "ÂéÜÂè≤ËÆ∞ÂΩï",
    "newStory": "Êñ∞ÂÜíÈô©",
    "storyCollection": "ÊïÖ‰∫ãÈõÜ",
    "characterCards": "ËßíËâ≤Âç°",
    "characterMarket": "ËßíËâ≤Â∏ÇÂú∫",
    "login": "ÁôªÂΩïÂπ∂Êé¢Á¥¢Êõ¥Â§ö",
    "nologin": "ÂÆö‰πâ User ÂêçÁß∞",
    "logout": "ÈÄÄÂá∫ÁôªÂΩï",
    "collapseHome": "Êî∂Ëµ∑È¶ñÈ°µ",
    "expandHome": "Â±ïÂºÄÈ¶ñÈ°µ",
    "collapseCreation": "Êî∂Ëµ∑Ê∏∏ÊàèÂå∫",
    "expandCreation": "Â±ïÂºÄÊ∏∏ÊàèÂå∫",
    "collapseCreator": "Êî∂Ëµ∑Âàõ‰ΩúÂå∫",
    "expandCreator": "Â±ïÂºÄÂàõ‰ΩúÂå∫",
    "goToUpdate": "ÂâçÂæÄÊõ¥Êñ∞",
    "newVersionAvailable": "ÂèëÁé∞Êñ∞ÁâàÊú¨",
    "currentVersion": "ÂΩìÂâçÁâàÊú¨: v{version}"
  },
  "modelSettings": {
    "title": "Ê®°ÂûãËÆæÁΩÆ",
    "llmType": "LLM Á±ªÂûã",
    "baseUrl": "Base URL",
    "model": "Ê®°Âûã",
    "apiKey": "API Key",
    "language": "ËæìÂá∫ËØ≠Ë®Ä",
    "chinese": "‰∏≠Êñá",
    "english": "Ëã±Êñá",
    "saveSettings": "ÁÇπÂáªÂêØÁî®",
    "settingsSaved": "ËÆæÁΩÆÂ∑≤‰øùÂ≠ò",
    "commonModels": "Â∏∏Áî®Ê®°ÂûãÊé®Ëçê:",
    "modelList": "Ê®°ÂûãÂàóË°®",
    "selectModel": "ÈÄâÊã©Ê®°Âûã",
    "modelListUnavailable": "Ê®°ÂûãÂàóË°®‰∏çÂèØÁî®",
    "configurations": "API ÈÖçÁΩÆ",
    "newConfig": "Êñ∞Âª∫ÈÖçÁΩÆ",
    "configName": "ÈÖçÁΩÆÂêçÁß∞",
    "configNamePlaceholder": "ÊàëÁöÑ API ÈÖçÁΩÆ",
    "createConfig": "ÂàõÂª∫ÈÖçÁΩÆ",
    "nameRequired": "ÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫",
    "cannotDeleteLastConfig": "Êó†Ê≥ïÂà†Èô§ÊúÄÂêé‰∏Ä‰∏™ÈÖçÁΩÆ",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ÈÖçÁΩÆÂêóÔºü",
    "configCreated": "ÈÖçÁΩÆÂ∑≤ÂàõÂª∫",
    "noConfigs": "ÊöÇÊó†APIÈÖçÁΩÆ",
    "createFirstConfig": "ÂàõÂª∫‰Ω†ÁöÑÁ¨¨‰∏Ä‰∏™ÈÖçÁΩÆ",
    "getModelList": "Ëé∑ÂèñÊ®°ÂûãÂàóË°®",
    "getModelListSuccess": "Ëé∑ÂèñÊ®°ÂûãÂàóË°®ÊàêÂäü",
    "getModelListError": "Ëé∑ÂèñÊ®°ÂûãÂàóË°®Â§±Ë¥•",
    "doubleClickToEditName": "ÂèåÂáªÂèØ‰øÆÊîπÂêçÁß∞",
    "testModel": "ÊµãËØïÊ®°Âûã",
    "testing": "ÊµãËØï‰∏≠...",
    "testSuccess": "Ê®°ÂûãÊµãËØïÊàêÂäü",
    "testError": "Ê®°ÂûãÊµãËØïÂ§±Ë¥•",
    "apiTestFailed": "API ÊµãËØïÂ§±Ë¥•",
    "modelTestFailed": "Ê®°ÂûãÊµãËØïÂ§±Ë¥•"
  },
  "llmSettings": {
    "title": "ËÆæÁΩÆ",
    "modelType": "Ê®°ÂûãÁ±ªÂûã",
    "presets": "È¢ÑËÆæ",
    "creative": "ÂàõÊÑè",
    "balanced": "Âπ≥Ë°°",
    "precise": "Á≤æÁ°Æ",
    "commonParams": "Â∏∏Áî®ÂèÇÊï∞",
    "advancedParams": "È´òÁ∫ßÂèÇÊï∞",
    "temperature": "Ê∏©Â∫¶",
    "temperatureDescription": "ÊéßÂà∂ÁîüÊàêÊñáÊú¨ÁöÑÈöèÊú∫ÊÄß„ÄÇËæÉÈ´òÁöÑÂÄº‰ºö‰∫ßÁîüÊõ¥Â§öÊ†∑ÂåñÁöÑËæìÂá∫ÔºåËæÉ‰ΩéÁöÑÂÄº‰ºö‰∫ßÁîüÊõ¥Á°ÆÂÆöÁöÑËæìÂá∫„ÄÇ",
    "maxTokens": "ÊúÄÂ§ßÊ†áËÆ∞Êï∞",
    "maxTokensDescription": "ÁîüÊàêÊñáÊú¨ÁöÑÊúÄÂ§ßÊ†áËÆ∞Êï∞„ÄÇÁïôÁ©∫‰ΩøÁî®Ê®°ÂûãÈªòËÆ§ÂÄº„ÄÇ",
    "timeout": "Ë∂ÖÊó∂Êó∂Èó¥",
    "timeoutDescription": "API ËØ∑Ê±ÇÁöÑË∂ÖÊó∂Êó∂Èó¥ÔºàÊØ´ÁßíÔºâ„ÄÇÁïôÁ©∫‰ΩøÁî®ÈªòËÆ§ÂÄº„ÄÇ",
    "maxRetries": "ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞",
    "maxRetriesDescription": "ÂΩì API ËØ∑Ê±ÇÂ§±Ë¥•Êó∂ÁöÑÊúÄÂ§ßÈáçËØïÊ¨°Êï∞„ÄÇ",
    "topP": "Top P ÈááÊ†∑",
    "topPDescription": "ÈÄöËøáÊ†∏ÈááÊ†∑ÊéßÂà∂Â§öÊ†∑ÊÄß„ÄÇËæÉ‰ΩéÁöÑÂÄº‰ºöËÄÉËôëÊõ¥Â∞ëÁöÑÈ´òÊ¶ÇÁéáÈÄâÈ°π„ÄÇ",
    "frequencyPenalty": "È¢ëÁéáÊÉ©ÁΩö",
    "frequencyPenaltyDescription": "Ê†πÊçÆÊ†áËÆ∞Âú®ÊñáÊú¨‰∏≠ÁöÑÈ¢ëÁéáËøõË°åÊÉ©ÁΩö„ÄÇËæÉÈ´òÁöÑÂÄº‰ºöÂáèÂ∞ëÈáçÂ§ç„ÄÇ",
    "presencePenalty": "Â≠òÂú®ÊÉ©ÁΩö",
    "presencePenaltyDescription": "ÊÉ©ÁΩöÂ∑≤ÁªèÂá∫Áé∞Âú®ÊñáÊú¨‰∏≠ÁöÑÊ†áËÆ∞„ÄÇËæÉÈ´òÁöÑÂÄº‰ºöÈºìÂä±Êñ∞‰∏ªÈ¢ò„ÄÇ",
    "topK": "Top K ÈááÊ†∑",
    "topKDescription": "Â∞ÜÊ†áËÆ∞ÈÄâÊã©ÈôêÂà∂‰∏∫ K ‰∏™ÊúÄÂèØËÉΩÁöÑÊ†áËÆ∞„ÄÇËæÉ‰ΩéÁöÑÂÄº‰ΩøËæìÂá∫Êõ¥Âä†ÈõÜ‰∏≠„ÄÇ",
    "repeatPenalty": "ÈáçÂ§çÊÉ©ÁΩö",
    "repeatPenaltyDescription": "ÊÉ©ÁΩöÈáçÂ§çÁöÑÊ†áËÆ∞„ÄÇËæÉÈ´òÁöÑÂÄº‰ºöÂáèÂ∞ë Ollama Ê®°Âûã‰∏≠ÁöÑÈáçÂ§ç„ÄÇ",
    "optional": "ÂèØÈÄâÈ°πÔºåÁïôÁ©∫‰ΩøÁî®ÈªòËÆ§ÂÄº"
  },
  "sessionList": {
    "loading": "Âè¨Âî§ÂéÜÂè≤Âç∑ËΩ¥‰∏≠...",
    "noHistory": "ÊöÇÊó†ÂéÜÂè≤ËÆ∞ÂΩï",
    "continue": "ÁªßÁª≠Ê∏∏Êàè",
    "delete": "Âà†Èô§ËÆ∞ÂΩï"
  },
  "homePage": {
    "slogan": "Êàë‰ª¨ÊØè‰∏™‰∫∫ÁöÑÂøÉÈáåÔºåÈÉΩÊòØ‰∏ÄÂõ¢ÁÅ´ÁÑ∞",
    "newAdventure": "ÂºÄÂêØÊñ∞ÁöÑÂÜíÈô©",
    "continueJourney": "ÁªßÁª≠Êú™ÂÆåÁöÑÊóÖÁ®ã",
    "immediatelyStart": "Á´ãÂàªÂºÄÂßã"
  },
  "auth": {
    "username": "Áî®Êà∑Âêç",
    "password": "ÂØÜÁ†Å",
    "login": "ÁôªÂΩï",
    "register": "Ê≥®ÂÜå",
    "welcomeBack": "Ê¨¢ËøéÂõûÊù•",
    "continueJourney": "ÁôªÂΩï‰ª•ÁªßÁª≠ÊÇ®ÁöÑÊóÖÁ®ã",
    "emailPlaceholder": "ÂõûËΩ¶‰ª•Â∫îÁî®Áî®Êà∑Âêç",
    "passwordPlaceholder": "ËæìÂÖ•ÂØÜÁ†Å",
    "codePlaceholder": "ËæìÂÖ•È™åËØÅÁ†Å",
    "wizardQuestion": "‚ú® ÂãáËÄÖÔºåËØ∑Áïô‰∏ãÊÇ®ÁöÑÂßìÂêç",
    "spellQuestion": "üîÆ ËØ∑ÊñΩÂ±ïÊÇ®ÁöÑÂÆàÊä§ÂííËØ≠ÔºåÂÆÉÂ∞Ü‰øùÊä§ÊÇ®ÁöÑÂ•áÂπªÊóÖÁ®ãÔºÅ",
    "codeQuestion": "‚ö° ËæìÂÖ•ÊòüËæ∞Â§ßÊµ∑ÈÄÅÊù•ÁöÑÁ•ûÁßòÁ¨¶ÊñáÔºåËØÅÊòéÊÇ®ÁöÑË∫´‰ªΩÔºÅ",
    "getCode": "Ëé∑ÂèñÈ™åËØÅÁ†Å",
    "openingMagicDoor": "Ê≠£Âú®ÂºÄÂêØÈ≠îÊ≥ï‰πãÈó®...",
    "magicSpell": "ÂØÜÁ†ÅÁôªÂΩï",
    "starCode": "È™åËØÅÁ†ÅÁôªÂΩï",
    "agreementText": "ÁªßÁª≠Âç≥Ë°®Á§∫ÊÇ®ÂêåÊÑè",
    "termsOfService": "ÊúçÂä°Êù°Ê¨æ",
    "privacyPolicy": "ÈöêÁßÅÊîøÁ≠ñ"
  },
  "storiesPage": {
    "title": "ÊàëÁöÑÊïÖ‰∫ã",
    "createNewStory": "ÂàõÂª∫Êñ∞ÊïÖ‰∫ã",
    "loading": "Ê≠£Âú®Âä†ËΩΩÊïÖ‰∫ã...",
    "noStories": "‰Ω†ËøòÊ≤°ÊúâÂàõÂª∫‰ªª‰ΩïÊïÖ‰∫ã",
    "createFirstStory": "ÂàõÂª∫Á¨¨‰∏Ä‰∏™ÊïÖ‰∫ã",
    "recentlyCreated": "ÊúÄËøëÂàõÂª∫",
    "fetchError": "Ëé∑ÂèñÊïÖ‰∫ãÂàóË°®Â§±Ë¥•",
    "edit": "ÁºñËæë",
    "delete": "Âà†Èô§",
    "deleteConfirm": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÊïÖ‰∫ãÂêóÔºü",
    "deleteSuccess": "ÊïÖ‰∫ãÂ∑≤Âà†Èô§",
    "deleteFailed": "Âà†Èô§ÊïÖ‰∫ãÂ§±Ë¥•",
    "play": "ÂºÄÂßãÊ∏∏Êàè"
  },
  "newStory": {
    "title": "ÂàõÂª∫Êñ∞ÊïÖ‰∫ã",
    "editTitle": "ÁºñËæëÊïÖ‰∫ã",
    "storyTitle": "ÊïÖ‰∫ãÊ†áÈ¢ò",
    "storyFramework": "ÊïÖ‰∫ãËÉåÊôØ",
    "characterInfo": "ËßíËâ≤‰ø°ÊÅØ",
    "questionTitle": "‚ú® ‰º†Â•áÂÜíÈô©ÁöÑ‰∏ªÈ¢ò",
    "questionFramework": "‚ú® ‰Ω†ÁöÑÂÜíÈô©Â∞ÜÂú®ÊÄéÊ†∑Á•ûÂ•áÁöÑ‰ΩçÈù¢Â±ïÂºÄÔºü",
    "questionCharacter": "‚ú® Âú®ËøôÊÆµ‰∏çÊúΩ‰º†Â•á‰∏≠Ôºå‰Ω†ÂåñË∫´‰∏∫‰ΩïÁ≠âÂ≠òÂú®Ôºü",
    "titlePlaceholder": "‰∏∫‰Ω†ÁöÑÂè≤ËØóÂëΩÂêç",
    "frameworkPlaceholder": "ÊèèÁªò‰Ω†ÁöÑÂ•áÂπª‰∏ñÁïå",
    "characterPlaceholder": "Êè≠Á§∫‰Ω†ÁöÑËã±ÈõÑË∫´‰ªΩ",
    "create": "ÂºÄÂêØ‰º†Â•á‰πãÊóÖ",
    "creating": "Ê≠£Âú®ÁºñÁªáÊÇ®ÁöÑ‰º†Â•áÊïÖ‰∫ã...",
    "update": "Êõ¥Êñ∞ÊïÖ‰∫ã",
    "updating": "Êõ¥Êñ∞‰∏≠...",
    "cancel": "ÂèñÊ∂à",
    "fillAllFields": "ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖÂ°´Â≠óÊÆµ",
    "createFailed": "ÂàõÂª∫ÊïÖ‰∫ãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "updateFailed": "Êõ¥Êñ∞ÊïÖ‰∫ãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "updateSuccess": "ÊïÖ‰∫ãÊõ¥Êñ∞ÊàêÂäü"
  },
  "notFound": {
    "title": "ÂâçÊñπÁöÑÈÅìË∑ØÂ∞öÊú™ÂºÄÊîæ",
    "subtitle": "ËøôÁâáÂ•áÂπªÈ¢ÜÂüü‰ªçÂú®Âª∫ËÆæ‰∏≠",
    "message": "Â∞äÊï¨ÁöÑÂÜ•ÊÉ≥ÂÆ∂ÔºåÊÇ®ÊâÄÂØªÊâæÁöÑÈ≠îÊ≥ïÂç∑ËΩ¥‰ºº‰πéÂ∑≤Ë¢´ÈÅóÂ§±ÊàñÂ∞öÊú™Ë¢´ÂàõÈÄ†„ÄÇ",
    "backToHome": "ËøîÂõû",
    "exploreMore": "Á®çÂêéÂÜçÊù•Êé¢Á¥¢"
  },
  "game": {
    "fetchStoryFailed": "Ëé∑ÂèñÊïÖ‰∫ãËØ¶ÊÉÖÂ§±Ë¥•",
    "fetchStoryFailedRetry": "Ëé∑ÂèñÊïÖ‰∫ãËØ¶ÊÉÖÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "loadSessionFailed": "Âä†ËΩΩÂéÜÂè≤‰ºöËØùÂ§±Ë¥•",
    "loadSessionFailedRetry": "Âä†ËΩΩÂéÜÂè≤‰ºöËØùÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "initializeFailed": "Ê∏∏ÊàèÂàùÂßãÂåñÂ§±Ë¥•",
    "setupFailed": "Ê∏∏ÊàèËÆæÁΩÆÂ§±Ë¥•",
    "cannotReadResponseStream": "Êó†Ê≥ïËØªÂèñÂìçÂ∫îÊµÅ",
    "generatingStory": "Ê≠£Âú®ÁîüÊàêÊïÖ‰∫ã...",
    "actionFailed": "Ê∏∏ÊàèÊìç‰ΩúÂ§±Ë¥•",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÊïÖ‰∫ãÂêóÔºüËøô‰∏™Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
    "deleteFailed": "Âà†Èô§ÊïÖ‰∫ãÂ§±Ë¥•",
    "deleteFailedRetry": "Âà†Èô§ÊïÖ‰∫ãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "storyNotExist": "ÂéÜÂè≤ËÆ∞ÂΩïÊâÄÂ±ûÁöÑÊïÖ‰∫ã‰∏çÂ≠òÂú®",
    "cannotFindStory": "Êó†Ê≥ïÊâæÂà∞ID‰∏∫ {id} ÁöÑÊïÖ‰∫ã",
    "backToStoryList": "ËøîÂõûÊïÖ‰∫ãÂàóË°®",
    "expandSidebar": "Â±ïÂºÄ‰æßËæπÊ†è",
    "collapseSidebar": "Êî∂Ëµ∑‰æßËæπÊ†è",
    "storySummary": "ÊïÖ‰∫ãÊ¶ÇË¶Å",
    "storyFramework": "ÊïÖ‰∫ãÊ°ÜÊû∂",
    "characterInfo": "ËßíËâ≤‰ø°ÊÅØ",
    "starting": "ÂêØÂä®‰∏≠...",
    "startAdventure": "ÂºÄÂßãÂÜíÈô©",
    "inputCustomAction": "ËæìÂÖ•Ëá™ÂÆö‰πâÊìç‰Ωú...",
    "execute": "ÊâßË°å",
    "deleting": "Âà†Èô§‰∏≠...",
    "deleteStory": "Âà†Èô§ÊïÖ‰∫ã",
    "gameInfo": "Ê∏∏Êàè‰ø°ÊÅØ",
    "memoryManagement": "ËÆ∞ÂøÜÁÆ°ÁêÜ",
    "navigation": "ÂØºËà™",
    "collapse": "Êî∂Ëµ∑",
    "expand": "Â±ïÂºÄ",
    "memoryPlaceholder": "ËøôÈáåÂ∞ÜÊòæÁ§∫Ê∏∏ÊàèËÆ∞ÂøÜ",
    "memoryDescription": "ËÆ∞ÂøÜÁÆ°ÁêÜÂÖÅËÆ∏ÊÇ®Êü•ÁúãÂíåÁºñËæëÊ∏∏Êàè‰∏≠ÁöÑËÆ∞ÂøÜÁâáÊÆµ",
    "memoryInstructions": "ÁÇπÂáªËäÇÁÇπÊü•ÁúãÂÆåÊï¥ÂÜÖÂÆπÔºåËøûÁ∫øÊòæÁ§∫ÊÇ®ÁöÑÊìç‰Ωú",
    "editMemory": "ÁºñËæëËÆ∞ÂøÜ",
    "memorySummary": "ËÆ∞ÂøÜÊ¶ÇË¶Å",
    "fullMemoryContent": "ÂÆåÊï¥ËÆ∞ÂøÜÂÜÖÂÆπ",
    "editMemoryPlaceholder": "ÁºñËæëÊÇ®ÁöÑÊ∏∏ÊàèËÆ∞ÂøÜ...",
    "noSessionFound": "Êú™ÊâæÂà∞‰ºöËØù",
    "startSessionFirst": "ËØ∑ÂÖàÂºÄÂßã‰∏Ä‰∏™Ê∏∏Êàè‰ºöËØùÊâçËÉΩÊü•ÁúãËÆ∞ÂøÜ",
    "loadingMemories": "Ê≠£Âú®Âä†ËΩΩËÆ∞ÂøÜ...",
    "jumpToNode": "Ë∑≥ËΩ¨Âà∞Ê≠§ËäÇÁÇπ",
    "expandMemory": "Â±ïÂºÄËÆ∞ÂøÜÂÜÖÂÆπ"
  },
  "characterCardsPage": {
    "title": "ËßíËâ≤Âç°",
    "importCharacter": "ÂØºÂÖ•ËßíËâ≤",
    "importFirstCharacter": "ÂØºÂÖ•‰Ω†ÁöÑÁ¨¨‰∏Ä‰∏™ËßíËâ≤",
    "noCharacters": "‰Ω†ËøòÊ≤°Êúâ‰ªª‰ΩïËßíËâ≤",
    "loading": "Âä†ËΩΩ‰∏≠...",
    "downloadingPresets": "Ê≠£Âú®‰∏ãËΩΩÈ¢ÑËÆæËßíËâ≤...",
    "fetchError": "Ëé∑ÂèñËßíËâ≤Â§±Ë¥•",
    "deleteFailed": "Âà†Èô§ËßíËâ≤Â§±Ë¥•",
    "delete": "Âà†Èô§",
    "edit": "ÁºñËæë",
    "chat": "ËÅäÂ§©",
    "recentlyCreated": "ÊúÄËøëÂàõÂª∫",
    "downloadCharacter": "Á§æÂå∫‰∏ãËΩΩËßíËâ≤"
  },
  "editCharacterModal": {
    "title": "ÁºñËæëËßíËâ≤",
    "name": "ÂêçÁß∞",
    "description": "ÊèèËø∞",
    "personality": "ÊÄßÊ†º",
    "scenario": "Âú∫ÊôØ",
    "firstMessage": "ÂºÄÂú∫ÁôΩ",
    "mesExample": "Ê∂àÊÅØÁ§∫‰æã",
    "creatorComment": "ÂàõÂª∫ËÄÖÂ§áÊ≥®",
    "save": "‰øùÂ≠ò",
    "cancel": "ÂèñÊ∂à"
  },
  "importCharacterModal": {
    "title": "ÂØºÂÖ•ËßíËâ≤",
    "description": "ÈÄâÊã©ÊàñÊãñÊîæ SillyTavern Ê†ºÂºèÁöÑ PNG ËßíËâ≤Âç°Êñá‰ª∂ËøõË°åÂØºÂÖ•",
    "dragOrClick": "ÊãñÊîæÊñá‰ª∂Âà∞Ê≠§Â§ÑÊàñÁÇπÂáªÈÄâÊã©",
    "pngFormat": "‰ªÖÊîØÊåÅ SillyTavern Ê†ºÂºèÁöÑ PNG ËßíËâ≤Âç°Êñá‰ª∂",
    "pngOnly": "ËØ∑ÈÄâÊã© SillyTavern Ê†ºÂºèÁöÑ PNG Êñá‰ª∂",
    "noFileSelected": "ËØ∑ÂÖàÈÄâÊã©Êñá‰ª∂",
    "uploadFailed": "‰∏ä‰º†Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
    "import": "ÂØºÂÖ•",
    "uploading": "Ê≠£Âú®‰∏ä‰º†..."
  },
  "characterMarketPage": {
    "description": "Êé¢Á¥¢ÂêÑÁßçÁ≤æÂΩ©ËßíËâ≤Ôºå‰∏∫ÊÇ®ÁöÑÊïÖ‰∫ãÂ¢ûÊ∑ªÁîüÊú∫",
    "searchPlaceholder": "ÊêúÁ¥¢ËßíËâ≤ÂêçÁß∞ÊàñÊèèËø∞",
    "allTags": "ÂÖ®ÈÉ®",
    "loading": "Ê≠£Âú®Âä†ËΩΩËßíËâ≤...",
    "noResults": "Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑËßíËâ≤",
    "clearFilters": "Ê∏ÖÈô§Á≠õÈÄâÊù°‰ª∂",
    "by": "‰ΩúËÄÖÔºö",
    "download": "‰∏ãËΩΩËßíËâ≤",
    "viewDetails": "Êü•ÁúãËØ¶ÊÉÖ"
  },
  "characterChat": {
    "navigation": "ÂØºËà™",
    "characterInfo": "ËßíËâ≤‰ø°ÊÅØ",
    "actions": "Êìç‰Ωú",
    "expandSidebar": "Â±ïÂºÄ‰æßËæπÊ†è",
    "collapseSidebar": "Êî∂Ëµ∑‰æßËæπÊ†è",
    "backToCharacters": "ËøîÂõûËßíËâ≤ÂàóË°®",
    "Conversation": "ÂâßÊÉÖÂàÜÊîØÁÆ°ÁêÜ",
    "noPersonality": "Êú™ÂÆö‰πâÊÄßÊ†º",
    "typeMessage": "ËæìÂÖ•Ê∂àÊÅØ...",
    "startConversation": "ÂºÄÂßãÂØπËØù...",
    "send": "ÂèëÈÄÅ",
    "isTyping": "Ê≠£Âú®ËæìÂÖ•...",
    "suggestedResponse1": "ÂëäËØâÊàëÊõ¥Â§ö",
    "suggestedResponse2": "Êé•‰∏ãÊù•ÂèëÁîü‰∫Ü‰ªÄ‰πàÔºü",
    "suggestedResponse3": "‰Ω†ÂØπÊ≠§Êúâ‰ªÄ‰πàÊÑüÊÉ≥Ôºü",
    "promptMode": "ÊèêÁ§∫ËØçÊ®°Âºè",
    "companionMode": "ÂâßÊÉÖÊé®ËøõÊ®°Âºè",
    "nsfwMode": "‰∫≤ÂØÜÈô™‰º¥Ê®°Âºè",
    "explicitMode": "NSFWÊ®°Âºè",
    "customMode": "Ëá™ÂÆö‰πâÊ®°Âºè",
    "innerThought": "ÂÜÖÂøÉÊÉ≥Ê≥ï",
    "speech": "ÂØπËØù",
    "screen": "Âú∫ÊôØ",
    "nextPrompt": "‰∏ã‰∏ÄÊ≠•",
    "storyProgress": "ÂâßÊÉÖÊé®Ëøõ",
    "storyProgressHint": "Ôºà‰∏ã‰∏ÄÊ≠•Ê†πÊçÆÂÖ®ÈÉ®ÊúâÊïà‰ø°ÊÅØÊé®ËøõÊïÖ‰∫ãÂèëÂ±ïÔºâ",
    "perspective": "ËßÜËßíËÆæËÆ°",
    "novelPerspective": "Â∞èËØ¥ËßÜËßí",
    "protagonistPerspective": "‰∏ªËßíËßÜËßí",
    "novelPerspectiveHint": "Ôºà‰∏ãÊ¨°‰ª•Â∞èËØ¥‰∏äÂ∏ùËßÜËßíÂõûÂ§çÔºåÂøÖÈ°ªÂåÖÂê´ÂâßÈÄèÂßìÂêçÔºâ",
    "protagonistPerspectiveHint": "Ôºà‰∏ãÊ¨°‰ª•‰∏ªËßíËßÜËßíÂõûÂ§çÔºåÂøÖÈ°ª‰ΩøÁî®ÊàëÊàñËÄÖ‰∏ªËßíÁöÑÂÆûÈôÖÂêçÁß∞Ôºâ",
    "sceneTransition": "Âú∫ÊôØËøáÊ∏°",
    "sceneTransitionHint": "Ôºà‰∏ã‰∏ÄÊ¨°ËøõË°åËá™ÁÑ∂ÁöÑÂú∫ÊôØËøáÊ∏°ÔºåÂÆûÁé∞Âú∫ÊôØÂàáÊç¢Ôºâ",
    "screenPlaceholder": "ÊèèËø∞Âú∫ÊôØÊàñÂä®‰Ωú...",
    "speechPlaceholder": "ËßíËâ≤ËØ¥ÁöÑËØù...",
    "innerThoughtPlaceholder": "ËßíËâ≤ÂøÉÈáåÊÉ≥‰∫Ü‰ªÄ‰πà...",
    "playerInput": "Áé©ÂÆ∂ËæìÂÖ•Êåá‰ª§",
    "characterStatus": "ËßíËâ≤Áä∂ÊÄÅ",
    "responseInstructions": "ÂõûÂ§çÊèêÁ§∫",
    "responseLength": "Ê®°ÂûãÂõûÂ§çÈïøÂ∫¶",
    "customPrompt": "Ëá™ÂÆö‰πâÊèêÁ§∫ËØç",
    "customPromptFor": "Ëá™ÂÆö‰πâÊèêÁ§∫ËØç",
    "presets": "È¢ÑËÆæ",
    "presetEditor": "È¢ÑËÆæÁºñËæëÂô®",
    "githubPresets": "ÊèêÁ§∫ËØçÈÄâÊã©",
    "noPresets": "Ê≤°ÊúâÂèØÁî®ÁöÑÈ¢ÑËÆæ",
    "prefixPrompt": "ÂâçÁºÄÊèêÁ§∫ËØç",
    "chainOfThoughtPrompt": "ÊÄùÁª¥ÈìæÊèêÁ§∫ËØç",
    "suffixPrompt": "ÂêéÁºÄÊèêÁ§∫ËØç",
    "prefixPromptDescription": "ÂâçÁºÄÊèêÁ§∫ËØçÂ∞ÜÊîæÁΩÆÂú®ÊèêÁ§∫ËØçÁöÑÂºÄÂ§¥ÔºåÁî®‰∫éËÆæÁΩÆËßíËâ≤ÁöÑÂü∫Êú¨Ë°å‰∏∫ÂíåËÉåÊôØ„ÄÇ",
    "chainOfThoughtPromptDescription": "ÊÄùÁª¥ÈìæÊèêÁ§∫ËØçÂ∞ÜÊîæÁΩÆÂú®ÊèêÁ§∫ËØçÁöÑ‰∏≠Èó¥ÔºåÁî®‰∫éÊåáÂØºËßíËâ≤ÁöÑÊÄùËÄÉËøáÁ®ã„ÄÇ",
    "suffixPromptDescription": "ÂêéÁºÄÊèêÁ§∫ËØçÂ∞ÜÊîæÁΩÆÂú®ÊèêÁ§∫ËØçÁöÑÁªìÂ∞æÔºåÁî®‰∫éË°•ÂÖÖÈ¢ùÂ§ñÁöÑÊåáÂØºÂíåÈôêÂà∂„ÄÇ",
    "prefixPromptPlaceholder": "ËæìÂÖ•ÂâçÁºÄÊèêÁ§∫ËØç...",
    "chainOfThoughtPromptPlaceholder": "ËæìÂÖ•ÊÄùÁª¥ÈìæÊèêÁ§∫ËØç...",
    "suffixPromptPlaceholder": "ËæìÂÖ•ÂêéÁºÄÊèêÁ§∫ËØç...",
    "autoSaveEnabled": "Ëá™Âä®‰øùÂ≠òÂ∑≤ÂêØÁî®",
    "initializing": "Ê≠£Âú®ÂàùÂßãÂåñËßíËâ≤...",
    "extractingTemplate": "ÊèêÂèñÁä∂ÊÄÅÊ®°Êùø‰∏≠ÔºåËØ∑Á®çÂÄô...",
    "loadingTimeHint": "È¶ñÊ¨°Âä†ËΩΩÊó∂Èó¥Âú® 5-40 Áßí‰πãÈó¥ÔºåËßíËâ≤Âç°ÂÜÖÂÆπË∂äÂ§ßÂä†ËΩΩÊó∂Èó¥Ë∂äÈïøÔºåÂ¶ÇÊûúÈïøÊó∂Èó¥Êú™Âä†ËΩΩÔºåËØ∑Ê£ÄÊü• API ÈÖçÁΩÆÊòØÂê¶Ê≠£Á°Æ",
    "error": "ÈîôËØØ",
    "characterNotFound": "Êú™ÊâæÂà∞ËßíËâ≤",
    "loading":"Âä†ËΩΩ‰∏≠‚Ä¶‚Ä¶Ê≠£Âú®Ëß£ÊûêÁä∂ÊÄÅÔºåËØ∑Á®çÁ≠â‚Ä¶‚Ä¶",
    "worldBook": "‰∏ñÁïå‰π¶",
    "regex": "Ê≠£ÂàôËÑöÊú¨",
    "preset": "È¢ÑËÆæ",
    "enabled": "ÂêØÁî®",
    "disabled": "Á¶ÅÁî®",
    "filtered": "Á≠õÈÄâ",
    "advancedSettings": "È´òÁ∫ßËÆæÁΩÆ",
    "tagColorEditor": "Ê†áÁ≠æÈ¢úËâ≤ÁºñËæëÂô®",
    "enterTagName": "ËæìÂÖ•Ê†áÁ≠æÂêçÁß∞...",
    "add": "Ê∑ªÂä†",
    "saveChanges": "‰øùÂ≠òÊõ¥Êîπ",
    "enterSymbol": "ÂΩìËæìÂÖ• tag Êó∂ÔºåÂ∞ÜÂØπ<tag>...</tag>ËøõË°åÂåπÈÖç",
    "enableStreaming": "ÂêØÁî®ÊµÅÂºèËæìÂá∫",
    "disableStreaming": "Á¶ÅÁî®ÊµÅÂºèËæìÂá∫",
    "jumpToMessage": "Ë∑≥ËΩ¨Âà∞Ê≠§Ê∂àÊÅØ",
    "regenerateMessage": "ÈáçÊñ∞ÁîüÊàêÊ∂àÊÅØ",
    "enableFastModel": "ÂºÄÂêØÂø´ÈÄüÊ®°Âºè",
    "disableFastModel": "ÂÖ≥Èó≠Âø´ÈÄüÊ®°Âºè"
  },
  "preset": {
    "title": "È¢ÑËÆæÁºñËæëÂô®",
    "createPreset": "ÂàõÂª∫È¢ÑËÆæ",
    "importPreset": "ÂØºÂÖ•È¢ÑËÆæ",
    "sortBy": "ÊéíÂ∫èÊñπÂºè",
    "sortOrder": "ÊéíÂ∫èÈ°∫Â∫è",
    "filterBy": "Á≠õÈÄâÊñπÂºè",
    "ascending": "ÂçáÂ∫è",
    "descending": "ÈôçÂ∫è",
    "asc": "ÂçáÂ∫è",
    "desc": "ÈôçÂ∫è",
    "all": "ÂÖ®ÈÉ®",
    "active": "ÊúâÊèêÁ§∫ËØç",
    "empty": "Á©∫ÁôΩ",
    "name": "ÂêçÁß∞",
    "promptCount": "ÊèêÁ§∫ËØçÊï∞Èáè",
    "lastUpdated": "ÊúÄÂêéÊõ¥Êñ∞",
    "status": "Áä∂ÊÄÅ",
    "prompts": "ÊèêÁ§∫ËØç",
    "updated": "Êõ¥Êñ∞Êó∂Èó¥",
    "actions": "Êìç‰Ωú",
    "active_status": "Ê¥ªË∑É",
    "empty_status": "Á©∫ÁôΩ",
    "total": "ÊÄªËÆ°",
    "enabled": "ÂêØÁî®",
    "disabled": "Á¶ÅÁî®",
    "filtered": "Á≠õÈÄâÁªìÊûú",
    "loading": "Âä†ËΩΩÈ¢ÑËÆæ‰∏≠...",
    "noPresetsFound": "Êú™ÊâæÂà∞È¢ÑËÆæ",
    "createFirstPreset": "ÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™È¢ÑËÆæÂºÄÂßã‰ΩøÁî®",
    "enterPresetName": "ËæìÂÖ•È¢ÑËÆæÂêçÁß∞Ôºö",
    "createSuccess": "È¢ÑËÆæÂàõÂª∫ÊàêÂäü",
    "createFailed": "ÂàõÂª∫È¢ÑËÆæÂ§±Ë¥•",
    "deleteConfirm": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™È¢ÑËÆæÂêóÔºü",
    "deleteSuccess": "È¢ÑËÆæÂà†Èô§ÊàêÂäü",
    "deleteFailed": "Âà†Èô§È¢ÑËÆæÂ§±Ë¥•",
    "loadFailed": "Âä†ËΩΩÈ¢ÑËÆæÂ§±Ë¥•",
    "loadDetailsFailed": "Âä†ËΩΩÈ¢ÑËÆæËØ¶ÊÉÖÂ§±Ë¥•",
    "expandDetails": "Â±ïÂºÄËØ¶ÊÉÖ",
    "collapseDetails": "Êî∂Ëµ∑ËØ¶ÊÉÖ",
    "promptsTitle": "ÊèêÁ§∫ËØç",
    "addPrompt": "Ê∑ªÂä†ÊèêÁ§∫ËØç",
    "enterPromptName": "ËæìÂÖ•ÊèêÁ§∫ËØçÂêçÁß∞Ôºö",
    "addPromptSuccess": "ÊèêÁ§∫ËØçÊ∑ªÂä†ÊàêÂäü",
    "addPromptFailed": "Ê∑ªÂä†ÊèêÁ§∫ËØçÂ§±Ë¥•",
    "deletePromptConfirm": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÊèêÁ§∫ËØçÂêóÔºü",
    "deletePromptSuccess": "ÊèêÁ§∫ËØçÂà†Èô§ÊàêÂäü",
    "deletePromptFailed": "Âà†Èô§ÊèêÁ§∫ËØçÂ§±Ë¥•",
    "noPromptsInPreset": "Ê≠§È¢ÑËÆæ‰∏≠Ê≤°ÊúâÊèêÁ§∫ËØç",
    "enabled_prompt": "Â∑≤ÂêØÁî®",
    "disabled_prompt": "Â∑≤Á¶ÅÁî®",
    "system": "Á≥ªÁªü",
    "deletePrompt": "Âà†Èô§ÊèêÁ§∫ËØç",
    "promptEnabledSuccess": "ÊèêÁ§∫ËØçÂ∑≤ÊàêÂäüÂêØÁî®",
    "promptDisabledSuccess": "ÊèêÁ§∫ËØçÂ∑≤ÊàêÂäüÁ¶ÅÁî®",
    "togglePromptFailed": "ÂàáÊç¢ÊèêÁ§∫ËØçÁä∂ÊÄÅÂ§±Ë¥•",
    "applyPresetSuccess": "È¢ÑËÆæÂ∫îÁî®ÊàêÂäü",
    "applyPresetFailed": "Â∫îÁî®È¢ÑËÆæÂ§±Ë¥•",
    "applyPreset": "Â∫îÁî®È¢ÑËÆæ",
    "presetApplied": "È¢ÑËÆæÂ∑≤ÊøÄÊ¥ª",
    "cannotApplyEmpty": "Êó†Ê≥ïÂ∫îÁî®Á©∫È¢ÑËÆæ",
    "enablePreset": "ÂêØÁî®È¢ÑËÆæ",
    "disablePreset": "Á¶ÅÁî®È¢ÑËÆæ",
    "presetEnabledSuccess": "È¢ÑËÆæÂ∑≤ÊàêÂäüÂêØÁî®",
    "presetEnabledExclusiveSuccess": "È¢ÑËÆæÂ∑≤ÊàêÂäüÂêØÁî®ÔºàÂÖ∂‰ªñÈ¢ÑËÆæÂ∑≤Ëá™Âä®Á¶ÅÁî®Ôºâ",
    "presetDisabledSuccess": "È¢ÑËÆæÂ∑≤ÊàêÂäüÁ¶ÅÁî®",
    "togglePresetFailed": "ÂàáÊç¢È¢ÑËÆæÁä∂ÊÄÅÂ§±Ë¥•",
    "presetDisabled": "È¢ÑËÆæÂ∑≤Á¶ÅÁî®",
    "cannotApplyDisabled": "Êó†Ê≥ïÂ∫îÁî®Â∑≤Á¶ÅÁî®ÁöÑÈ¢ÑËÆæ",
    "toggle": "ÂºÄÂÖ≥",
    "presetName": "È¢ÑËÆæÂêçÁß∞",
    "presetNamePlaceholder": "ËæìÂÖ•È¢ÑËÆæÂêçÁß∞",
    "presetNameRequired": "È¢ÑËÆæÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫",
    "creating": "ÂàõÂª∫‰∏≠...",
    "create": "ÂàõÂª∫",
    "cancel": "ÂèñÊ∂à",
    "editPrompt": "ÁºñËæëÊèêÁ§∫ËØç",
    "promptContent": "ÊèêÁ§∫ËØçÂÜÖÂÆπ",
    "saving": "‰øùÂ≠ò‰∏≠"
  },
  "importPreset": {
    "title": "ÂØºÂÖ•È¢ÑËÆæ",
    "dragDropFile": "ÂØºÂÖ•È¢ÑËÆæÊñá‰ª∂",
    "dropFileHere": "Â∞ÜÊñá‰ª∂ÊãñÊãΩÂà∞ËøôÈáå",
    "browseFiles": "ÊµèËßàÊñá‰ª∂",
    "dragAndDrop": "ÊãñÊãΩJSONÈ¢ÑËÆæÊñá‰ª∂Âà∞Ê≠§Â§ÑÔºåÊàñÁÇπÂáªÊµèËßà",
    "importing": "ÂØºÂÖ•‰∏≠...",
    "importSuccess": "ÂØºÂÖ•ÊàêÂäü",
    "importFailed": "ÂØºÂÖ•Â§±Ë¥•",
    "presetImported": "È¢ÑËÆæÂ∑≤ÊàêÂäüÂØºÂÖ•ÔºÅ",
    "importError": "ÂØºÂÖ•ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ",
    "customizePreset": "Ëá™ÂÆö‰πâÈ¢ÑËÆæ",
    "presetName": "È¢ÑËÆæÂêçÁß∞",
    "presetNameDesc": "ÁïôÁ©∫‰ª•‰ΩøÁî®Êñá‰ª∂ÂéüÂßãÂêçÁß∞",
    "confirmImport": "Á°ÆËÆ§ÂØºÂÖ•",
    "guidelines": "ÂØºÂÖ•ÊåáÂçó",
    "jsonFormat": "È¢ÑËÆæÊñá‰ª∂ÂøÖÈ°ª‰∏∫JSONÊ†ºÂºè",
    "validStructure": "Êñá‰ª∂Â∫îÂåÖÂê´ÊúâÊïàÁöÑÈ¢ÑËÆæÁªìÊûÑÂíåÊèêÁ§∫ËØç",
    "noOverwrite": "‰∏ç‰ºöË¶ÜÁõñÂêåÂêçÁöÑÁé∞ÊúâÈ¢ÑËÆæ",
    "maxFileSize": "ÊúÄÂ§ßÊñá‰ª∂Â§ßÂ∞èÔºö10MB",
    "selectJsonFile": "ËØ∑ÈÄâÊã©JSONÊñá‰ª∂",
    "failedToImport": "ÂØºÂÖ•Â§±Ë¥•",
    "cancel": "ÂèñÊ∂à",
    "save": "‰øùÂ≠ò"
  },
  "dialogue": {
    "treeVisualization": "ÂâßÊÉÖÂàÜÊîØÁÆ°ÁêÜ",
    "node": "ÂØπËØùËäÇÁÇπ",
    "systemMessage": "Á≥ªÁªüÊ∂àÊÅØ",
    "jumpToNode": "Ë∑≥ËΩ¨Âà∞ËäÇÁÇπ",
    "expandNode": "Â±ïÂºÄËäÇÁÇπ",
    "editNode": "ÁºñËæëËäÇÁÇπ",
    "userInput": "Áî®Êà∑ËæìÂÖ•",
    "assistantResponse": "Âä©ÊâãÂõûÂ§ç",
    "noCharacterSelected": "Êú™ÈÄâÊã©ËßíËâ≤",
    "selectCharacterFirst": "ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ËßíËâ≤",
    "loadingDialogue": "Ê≠£Âú®Âä†ËΩΩÂØπËØùÊï∞ÊçÆ...",
    "noDialogueNodes": "Ê≤°ÊúâÂØπËØùËäÇÁÇπ",
    "startConversation": "ÂºÄÂßãÂØπËØù‰ª•ÂàõÂª∫ÂØπËØùÊ†ë",
    "memorySummary": "ËÆ∞ÂøÜÊëòË¶Å",
    "nodeId": "ËäÇÁÇπID",
    "startingPoint": "ÂºÄÂ±Ä",
    "rootNodeCannotJump": "Ê†πËäÇÁÇπÊòØÂØπËØùÁöÑËµ∑ÁÇπÔºå‰∏çËÉΩË∑≥ËΩ¨",
    "response": "ÂõûÂ§çÂÜÖÂÆπ",
    "responsePlaceholder": "ÁºñËæëÂõûÂ§çÂÜÖÂÆπ...",
    "resetLayout": "ÈáçÁΩÆÂ∏ÉÂ±Ä",
    "manualPositions": "ÊâãÂä®‰ΩçÁΩÆ"
  },  
  "downloadModal": {
      "title": "‰ªéÁ§æÂå∫‰ªìÂ∫ì‰∏ãËΩΩËßíËâ≤",
      "loading": "Âä†ËΩΩ‰∏≠‚Ä¶",
      "fetchError": "Êó†Ê≥ïËé∑ÂèñËßíËâ≤ÂàóË°®",
      "downloadFailed": "‰∏ãËΩΩÂ§±Ë¥•",
      "importFailed": "ÂØºÂÖ•Â§±Ë¥•",
      "importing": "ÂØºÂÖ•‰∏≠‚Ä¶",
      "downloadAndImport": "‰∏ãËΩΩÂπ∂ÂØºÂÖ•",
      "by": "‰ΩúËÄÖÔºö",
      "unknownAuthor": "‰ΩöÂêç"
  },
  "creatorInput": {
    "title": "Creator Studio",
    "subtitle": "ÂºÄÂßãÂàõ‰ΩúÂè≤ËØóÁ∫ßÁöÑÊïÖ‰∫ã",
    "placeholder": "ËæìÂÖ•ÊÇ®ÁöÑÂàõ‰ΩúÊÉ≥Ê≥ï...",
    "sendMessage": "ÂèëÈÄÅÊ∂àÊÅØ",
    "enterToSend": "Êåâ Enter ÂèëÈÄÅÔºåShift + Enter Êç¢Ë°å",
    "characterCount": "{count}/1000",
    "exampleStories": "„ÄäËçíÈáéÊ±ÇÁîü„Äã„ÄÅ„ÄäÂìàÂà©Ê≥¢Áâπ„Äã„ÄÅ„ÄäÈ≠îÊàí„ÄãÔºå‰ªª‰ΩïÊïÖ‰∫ãÈöèÂøÉËÄåÂä®"
  },
  "worldBook": {
    "title": "‰∏ñÁïå‰π¶",
    "addEntry": "Ê∑ªÂä†Êù°ÁõÆ",
    "sortBy": "ÊéíÂ∫èÊñπÂºè",
    "sortOrder": "ÊéíÂ∫èÈ°∫Â∫è",
    "asc": "ÂçáÂ∫è",
    "desc": "ÈôçÂ∫è",
    "importing": "ÂØºÂÖ•‰∏≠",
    "imported": "ÂÖ®Â±Ä",
    "importedAt": "ÂØºÂÖ•Êó∂Èó¥:",
    "saveAsGlobalWorldBook": "‰øùÂ≠ò‰∏∫ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "globalName": "ÂÖ®Â±ÄÂêçÁß∞",
    "description": "ÊèèËø∞ÔºàÂèØÈÄâÔºâ",
    "enterGlobalWorldBookName": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÊñá‰ª∂ÂêçÁß∞",
    "enterDescriptionForThisGlobalWorldBook": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÁ©∫ÊèèËø∞",
    "importWorldBook": "ÂØºÂÖ•‰∏ñÁïå‰π¶",
    "dragDropJson": "ÊãñÊãΩJSONÊñá‰ª∂Âà∞Ê≠§Â§Ñ",
    "jsonFileOnly": "‰ªÖÊîØÊåÅJSONÊñá‰ª∂",
    "importResults": "ÂØºÂÖ•ÁªìÊûú",
    "importedEntries": "Â∑≤ÂØºÂÖ• {count} ‰∏™Êù°ÁõÆ",
    "skippedEntries": "Ë∑≥Ëøá {count} ‰∏™Êù°ÁõÆ",
    "importErrors": "ÂØºÂÖ•ÈîôËØØ",
    "loading": "Âä†ËΩΩ‰∏ñÁïå‰π¶Êï∞ÊçÆ...",
    "noEntries": "ÊöÇÊó†‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "noEntriesDescription": "ÁÇπÂáªÊñ∞Âª∫Êù°ÁõÆÂºÄÂßãÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "createEntry": "Êñ∞Âª∫Êù°ÁõÆ",
    "editEntry": "ÁºñËæë‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "newEntry": "Êñ∞Âª∫‰∏ñÁïå‰π¶Êù°ÁõÆ",
    "deleteEntry": "Âà†Èô§Êù°ÁõÆ",
    "bulkOperations": "ÊâπÈáèÊìç‰Ωú",
    "enableAll": "ÂÖ®ÈÉ®ÂêØÁî®",
    "disableAll": "ÂÖ®ÈÉ®Á¶ÅÁî®",
    "enableDisabled": "ÂêØÁî®Á¶ÅÁî®ÁöÑ",
    "disableEnabled": "Á¶ÅÁî®ÂêØÁî®ÁöÑ",
    "enabledAll": "Â∑≤ÂêØÁî®ÂÖ®ÈÉ®",
    "disabledAll": "Â∑≤Á¶ÅÁî®ÂÖ®ÈÉ®",
    "noEntriesWithStatus": "Ê≤°ÊúâÊâæÂà∞Áä∂ÊÄÅ‰∏∫{status}ÁöÑÊù°ÁõÆ",
    "bulkEnable": "ÊâπÈáèÂêØÁî®",
    "bulkDisable": "ÊâπÈáèÁ¶ÅÁî®",
    "bulkDelete": "ÊâπÈáèÂà†Èô§",
    "selectAll": "ÂÖ®ÈÄâ",
    "selectEntriesFirst": "ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÊìç‰ΩúÁöÑÊù°ÁõÆ",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Êù°ÁõÆÂêóÔºü",
    "saveSuccess": "‰øùÂ≠òÊàêÂäü",
    "saveFailed": "‰øùÂ≠òÂ§±Ë¥•",
    "deleteSuccess": "Âà†Èô§ÊàêÂäü",
    "deleteFailed": "Âà†Èô§Â§±Ë¥•",
    "bulkOperationFailed": "ÊâπÈáèÊìç‰ΩúÂ§±Ë¥•",
    "toggleFailed": "ÂàáÊç¢Áä∂ÊÄÅÂ§±Ë¥•",
    "enableEntry": "ÂêØÁî®Êù°ÁõÆ",
    "disableEntry": "Á¶ÅÁî®Êù°ÁõÆ",
    "toggle": "ÂºÄÂÖ≥",
    "item": "Êù°",
    "confirmBulkDisable": "Ê≠§Êìç‰ΩúÂ∞ÜÁ¶ÅÁî®ÊâÄÊúâÊù°ÁõÆ",
    "keywordRequired": "Ëá≥Â∞ëÈúÄË¶Å‰∏Ä‰∏™ÂÖ≥ÈîÆËØç",
    "contentRequired": "ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫",
    "totalCount": "ÊÄªËÆ°:",
    "enabledCount": "ÂêØÁî®:",
    "disabledCount": "Á¶ÅÁî®:",
    "selectedItems": "Â∑≤ÈÄâÊã©",
    "items": "È°π",
    "contextWindow": "‰∏ä‰∏ãÊñáÁ™óÂè£:",
    "status": "Áä∂ÊÄÅ",
    "comment": "Ê≥®Èáä",
    "keywords": "ÂÖ≥ÈîÆËØç",
    "position": "‰ΩçÁΩÆ",
    "depth": "Ê∑±Â∫¶",
    "characterCount": "Â≠óÁ¨¶Êï∞",
    "priority": "‰ºòÂÖàÁ∫ß",
    "actions": "Êìç‰Ωú",
    "enabled": "ÂêØÁî®",
    "disabled": "Á¶ÅÁî®",
    "regex": "Ê≠£Âàô",
    "constant": "Â∏∏Èáè",
    "noComment": "Êó†Ê≥®Èáä",
    "edit": "ÁºñËæë",
    "delete": "Âà†Èô§",
    "contentPreview": "ÂÜÖÂÆπÈ¢ÑËßà",
    "noContent": "Êó†ÂÜÖÂÆπ",
    "secondaryKeywords": "Ê¨°Ë¶ÅÂÖ≥ÈîÆËØç",
    "selectiveMatching": "ÈÄâÊã©ÊÄßÂåπÈÖç:",
    "tokenCount": "‰ª§ÁâåÊï∞:",
    "lastUpdated": "ÊúÄÂêéÊõ¥Êñ∞:",
    "totalKeywords": "ÂÖ≥ÈîÆËØçÊÄªÊï∞:",
    "notCalculated": "Êú™ËÆ°ÁÆó",
    "yes": "ÊòØ",
    "no": "Âê¶",
    "commentTitle": "Ê≥®Èáä/Ê†áÈ¢ò",
    "commentPlaceholder": "ËæìÂÖ•Ê≥®ÈáäÊàñÊ†áÈ¢ò",
    "insertionOrder": "ÊèíÂÖ•È°∫Â∫è",
    "primaryKeywords": "‰∏ªË¶ÅÂÖ≥ÈîÆËØç",
    "keywordPlaceholder": "ËæìÂÖ•ÂÖ≥ÈîÆËØç",
    "addKeyword": "Ê∑ªÂä†ÂÖ≥ÈîÆËØç",
    "removeKeyword": "ÁßªÈô§ÂÖ≥ÈîÆËØç",
    "depthLabel": "Ê∑±Â∫¶",
    "enabledLabel": "ÂêØÁî®",
    "regexLabel": "Ê≠£ÂàôË°®ËææÂºè",
    "selectiveLabel": "ÈÄâÊã©ÊÄßÂåπÈÖç",
    "constantLabel": "Â∏∏ÈáèÊù°ÁõÆ",
    "contentLabel": "ÂÜÖÂÆπ",
    "contentPlaceholder": "ËæìÂÖ•‰∏ñÁïå‰π¶ÂÜÖÂÆπ...",
    "characters": "Â≠óÁ¨¶",
    "save": "‰øùÂ≠ò",
    "cancel": "ÂèñÊ∂à",
    "saving": "‰øùÂ≠ò‰∏≠...",
    "positionOptions": {
      "systemPromptStart": "Á≥ªÁªüÊèêÁ§∫ÂºÄÂ§¥",
      "afterSystemPrompt": "Á≥ªÁªüÊèêÁ§∫‰πãÂêé",
      "userMessageStart": "Áî®Êà∑Ê∂àÊÅØÂºÄÂ§¥",
      "afterResponseMode": "ÂìçÂ∫îÊ®°ÂºèÂ£∞Êòé‰πãÂêé",
      "basedOnDepth": "Âü∫‰∫éÊ∑±Â∫¶"
    },
    "importFromJson": "‰ªéJSONÂØºÂÖ•",
    "importValidationFailed": "ÂØºÂÖ•È™åËØÅÂ§±Ë¥•",
    "selectJsonFile": "ÈÄâÊã©JSONÊñá‰ª∂",
    "importFromGlobal": "‰ªéÂÖ®Â±Ä‰∏ñÁïå‰π¶ÂØºÂÖ•",
    "noGlobalWorldBooks": "ÊöÇÊó†ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "createGlobalWorldBookFirst": "ËØ∑ÂÖàÂàõÂª∫ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "selectGlobalWorldBook": "ÈÄâÊã©ÂÖ®Â±Ä‰∏ñÁïå‰π¶",
    "entryCount": "Êù°ÁõÆÊï∞Èáè",
    "createdAt": "ÂàõÂª∫Êó∂Èó¥",
    "sourceCharacter": "Êù•Ê∫êËßíËâ≤",
    "filterBy": "Á≠õÈÄâÊñπÂºè",
    "filterAll": "ÂÖ®ÈÉ®",
    "filterEnabled": "Â∑≤ÂêØÁî®",
    "filterDisabled": "Â∑≤Á¶ÅÁî®",
    "filterImported": "ÂÖ®Â±Ä",
    "filteredCount": "Á≠õÈÄâÁªìÊûú",
    "ascending": "ÂçáÂ∫è",
    "descending": "ÈôçÂ∫è",
    "fullscreenContent": "Â§ßÁ™óÂè£ÁºñËæë",
    "exitFullscreen": "ÂÖ≥Èó≠ÁºñËæëÂô®"
  },
  "regexScriptEditor": {
    "title": "Ê≠£ÂàôËÑöÊú¨ÁºñËæëÂô®",
    "close": "ÂÖ≥Èó≠",
    "settings": "ËÆæÁΩÆ",
    "enableProcessing": "ÂêØÁî®Ê≠£ÂàôÂ§ÑÁêÜ",
    "applyToPrompts": "Â∫îÁî®Âà∞ÊèêÁ§∫ËØç",
    "applyToResponses": "Â∫îÁî®Âà∞ÂõûÂ§ç",
    "addNewScript": "Ê∑ªÂä†Êñ∞ËÑöÊú¨",
    "existingScripts": "Áé∞ÊúâËÑöÊú¨",
    "noScripts": "ÊöÇÊó†ËÑöÊú¨",
    "noScriptsDescription": "ÁÇπÂáªÊ∑ªÂä†Êñ∞ËÑöÊú¨ÂºÄÂßãÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™Ê≠£ÂàôËÑöÊú¨",
    "priority": "‰ºòÂÖàÁ∫ß",
    "edit": "ÁºñËæë",
    "enable": "ÂêØÁî®",
    "disable": "Á¶ÅÁî®",
    "delete": "Âà†Èô§",
    "replace": "ÊõøÊç¢",
    "findRegex": "Êü•ÊâæÊ≠£Âàô",
    "replaceString": "ÊõøÊç¢Â≠óÁ¨¶‰∏≤",
    "trimStrings": "‰øÆÂâ™Â≠óÁ¨¶‰∏≤",
    "confirmDelete": "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ËÑöÊú¨ÂêóÔºü",
    "deleteError": "Âà†Èô§ËÑöÊú¨Â§±Ë¥•",
    "newScript": "Êñ∞Âª∫ËÑöÊú¨",
    "editScript": "ÁºñËæëËÑöÊú¨",
    "scriptName": "ËÑöÊú¨ÂêçÁß∞",
    "scriptNamePlaceholder": "ËæìÂÖ•ËÑöÊú¨ÂêçÁß∞",
    "findRegexPlaceholder": "/pattern/flags Êàñ pattern",
    "replaceStringPlaceholder": "ÊõøÊç¢ÊñáÊú¨ (‰ΩøÁî® $1, $2 Ë°®Á§∫ÂàÜÁªÑ)",
    "disabled": "Á¶ÅÁî®",
    "enabled": "ÂêØÁî®",
    "cancel": "ÂèñÊ∂à",
    "save": "‰øùÂ≠ò",
    "saving": "‰øùÂ≠ò‰∏≠...",
    "loading": "Âä†ËΩΩ‰∏≠...",
    "requiredFields": "ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖÂ°´Â≠óÊÆµ",
    "saveError": "‰øùÂ≠òËÑöÊú¨Â§±Ë¥•",
    "totalCount": "ÊÄªËÆ°",
    "enabledCount": "ÂêØÁî®",
    "disabledCount": "Á¶ÅÁî®",
    "filteredCount": "Á≠õÈÄâÁªìÊûú",
    "sortBy": "ÊéíÂ∫èÊñπÂºè",
    "sortOrder": "ÊéíÂ∫èÈ°∫Â∫è",
    "asc": "ÂçáÂ∫è",
    "desc": "ÈôçÂ∫è",
    "ascending": "ÂçáÂ∫è",
    "descending": "ÈôçÂ∫è",
    "filterBy": "Á≠õÈÄâÊñπÂºè",
    "filterAll": "ÂÖ®ÈÉ®",
    "filterEnabled": "Â∑≤ÂêØÁî®",
    "filterDisabled": "Â∑≤Á¶ÅÁî®",
    "filterImported": "ÂÖ®Â±Ä",
    "name": "ÂêçÁß∞",
    "status": "Áä∂ÊÄÅ",
    "globalEnabled": "ÂÖ®Â±ÄÂêØÁî®",
    "applyToPrompt": "Â∫îÁî®Âà∞ÊèêÁ§∫ËØç",
    "applyToResponse": "Â∫îÁî®Âà∞ÂõûÂ§ç",
    "yes": "ÊòØ",
    "no": "Âê¶",
    "importScript": "ÂØºÂÖ•ËÑöÊú¨",
    "importRegexScript": "ÂØºÂÖ•Ê≠£ÂàôËÑöÊú¨",
    "importFromJson": "‰ªéJSONÂØºÂÖ•",
    "importFromGlobal": "‰ªéÂÖ®Â±ÄÂØºÂÖ•",
    "dragDropJson": "ÊãñÊãΩJSONÊñá‰ª∂Âà∞Ê≠§Â§Ñ",
    "jsonFileOnly": "‰ªÖÊîØÊåÅJSONÊñá‰ª∂",
    "saveAsGlobalRegexScript": "‰øùÂ≠ò‰∏∫ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "globalName": "ÂÖ®Â±ÄÂêçÁß∞",
    "description": "ÊèèËø∞",
    "enterGlobalRegexScriptName": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÊñá‰ª∂ÂêçÁß∞",
    "enterDescriptionForThisGlobalRegexScript": "ÈªòËÆ§Ëá™Âä®Â°´ÂÜôÁ©∫ÊèèËø∞",
    "importing": "ÂØºÂÖ•‰∏≠...",
    "importResults": "ÂØºÂÖ•ÁªìÊûú",
    "importedScripts": "Â∑≤ÂØºÂÖ• {count} ‰∏™ËÑöÊú¨",
    "skippedScripts": "Ë∑≥Ëøá {count} ‰∏™ËÑöÊú¨",
    "importErrors": "ÂØºÂÖ•ÈîôËØØ",
    "noGlobalRegexScripts": "ÊöÇÊó†ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "createGlobalRegexScriptFirst": "ËØ∑ÂÖàÂàõÂª∫ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "selectGlobalRegexScript": "ÈÄâÊã©ÂÖ®Â±ÄÊ≠£ÂàôËÑöÊú¨",
    "willUseEachFileName": "Â∞Ü‰ΩøÁî®ÊØè‰∏™Êñá‰ª∂ÁöÑÂêçÁß∞‰Ωú‰∏∫ËÑöÊú¨ÂêçÁß∞"
  },
  "tour": {
    "welcome": "Ê¨¢Ëøé‰ΩøÁî® Narratium",
    "welcomeDescription": "Narratium ÊòØ‰∏Ä‰∏™Êô∫ËÉΩËßíËâ≤ÂØπËØùÂπ≥Âè∞ÔºåÊÇ®ÂèØ‰ª•‰∏éÂêÑÁßçAIËßíËâ≤ËøõË°åÊ∑±Â∫¶ÂØπËØùÔºåÂàõÈÄ†Áã¨ÁâπÁöÑÊïÖ‰∫ã‰ΩìÈ™å„ÄÇËÆ©Êàë‰ª¨ÂÖà‰∫ÜËß£‰∏Ä‰∏ãÂü∫Êú¨ÂäüËÉΩ„ÄÇ",
    "loginTitle": "È¶ñÂÖàÁôªÂΩïË¥¶Êà∑",
    "loginDescription": "ÁÇπÂáªËøôÈáåÁôªÂΩï„ÄÇËØ∑Ê≥®ÊÑèÔºöÊÇ®ËæìÂÖ•ÁöÑÁî®Êà∑ÂêçÂèØËÉΩ‰ºöË¢´AIËßíËâ≤Áî®‰Ωú‰∏ªËßíÂêçÁß∞ÔºåÊâÄ‰ª•Âª∫ËÆÆ‰ΩøÁî®ÊÇ®Â∏åÊúõÂú®ÊïÖ‰∫ã‰∏≠‰ΩøÁî®ÁöÑÂêçÂ≠ó„ÄÇ",
    "settingsTitle": "ÈÖçÁΩÆAIÊ®°Âûã",
    "settingsDescription": "ÁôªÂΩïÂêéÔºåÁÇπÂáªÂè≥‰∏äËßíÁöÑËÆæÁΩÆÊåâÈíÆÊù•ÈÖçÁΩÆÊÇ®ÁöÑAIÊ®°Âûã„ÄÇÊÇ®ÂèØ‰ª•ÈÄâÊã©OpenAIÊàñOllamaÔºåÂπ∂ËÆæÁΩÆÁõ∏Â∫îÁöÑAPIÂØÜÈí•ÂíåÊ®°ÂûãÂèÇÊï∞„ÄÇ",
    "worldbookTitle": "‰∏ñÁïå‰π¶ÂäüËÉΩ",
    "worldbookDescription": "‰∏ñÁïå‰π¶Áî®‰∫éÂÆö‰πâËßíËâ≤ÁöÑËÉåÊôØ‰∏ñÁïå„ÄÅËÆæÂÆöÂíåÈáçË¶Å‰ø°ÊÅØ„ÄÇAI‰ºöÊ†πÊçÆ‰∏ñÁïå‰π¶‰∏≠ÁöÑÂÜÖÂÆπÊù•‰øùÊåÅËßíËâ≤ËÆæÂÆöÁöÑ‰∏ÄËá¥ÊÄßÔºåËÆ©ÂØπËØùÊõ¥Âä†Ê≤âÊµ∏„ÄÇ",
    "regexTitle": "Ê≠£ÂàôËÑöÊú¨",
    "regexDescription": "Ê≠£ÂàôËÑöÊú¨ÂÖÅËÆ∏ÊÇ®Ëá™ÂÆö‰πâAIÂõûÂ§çÁöÑÊ†ºÂºèÂíåÂ§ÑÁêÜÈÄªËæë„ÄÇÊÇ®ÂèØ‰ª•ËÆæÁΩÆÁâπÊÆäÁöÑÊñáÊú¨ÊõøÊç¢ËßÑÂàôÔºåËÆ©ËßíËâ≤ÁöÑË°®ËææÊñπÂºèÊõ¥Âä†Áã¨Áâπ„ÄÇ",
    "presetTitle": "È¢ÑËÆæÁÆ°ÁêÜ",
    "presetDescription": "È¢ÑËÆæÂäüËÉΩËÆ©ÊÇ®ÂèØ‰ª•‰øùÂ≠òÂíåÁÆ°ÁêÜ‰∏çÂêåÁöÑÂØπËØùËÆæÁΩÆÔºåÂåÖÊã¨ËßíËâ≤ÁöÑËØ≠Ê∞î„ÄÅÈ£éÊ†ºÂíåÁâπÊÆäÊåá‰ª§ÔºåÊñπ‰æøÂú®‰∏çÂêåÂú∫ÊôØ‰∏ãÂø´ÈÄüÂàáÊç¢„ÄÇ",
    "chatTitle": "ÂºÄÂßãÂØπËØù",
    "chatDescription": "Áé∞Âú®ÊÇ®ÂèØ‰ª•Âú®ËæìÂÖ•Ê°Ü‰∏≠ËæìÂÖ•Ê∂àÊÅØÔºåÂºÄÂßã‰∏éAIËßíËâ≤ÁöÑÁ≤æÂΩ©ÂØπËØù‰∫ÜÔºÅAI‰ºöÊ†πÊçÆÊÇ®ËÆæÁΩÆÁöÑ‰∏ñÁïå‰π¶„ÄÅÊ≠£ÂàôËÑöÊú¨ÂíåÈ¢ÑËÆæÊù•ÂõûÂ∫î„ÄÇ",
    "next": "‰∏ã‰∏ÄÊ≠•",
    "previous": "‰∏ä‰∏ÄÊ≠•",
    "skip": "Ë∑≥Ëøá",
    "finish": "ÂÆåÊàê",
    "resetTour": "ÈáçÁΩÆÂºïÂØº"
  }
}
</file>

<file path="app/i18n/fonts.ts">
import { Language } from "./index";
‚ãÆ----
export const getLanguageFont = (language: Language): string =>
export const getLanguageSerifFont = (language: Language): string =>
export const getLanguageTitleFont = (language: Language): string =>
</file>

<file path="app/i18n/FontWrapper.tsx">
import { ReactNode } from "react";
import { useLanguage } from "./index";
interface FontWrapperProps {
  children: ReactNode;
}
export function FontWrapper(
export function TitleFontWrapper(
</file>

<file path="app/i18n/index.ts">
import { createContext, useContext } from "react";
‚ãÆ----
export type Language = typeof LANGUAGES[number];
‚ãÆ----
type LanguageContextType = {
  language: Language;
  setLanguage: (language: Language) => void;
  t: (key: string) => string;
  fontClass: string;
  titleFontClass: string;
  serifFontClass: string;
};
‚ãÆ----
export const useLanguage = () =>
export const getTranslation = (language: Language, key: string): string =>
export const getClientLanguage = (): Language =>
</file>

<file path="app/i18n/LanguageProvider.tsx">
import { ReactNode, useEffect, useState } from "react";
import { DEFAULT_LANGUAGE, Language, LANGUAGES, LanguageContext, getTranslation, getClientLanguage } from "./index";
import { getLanguageFont, getLanguageTitleFont, getLanguageSerifFont } from "./fonts";
import LoadingTransition from "@/components/LoadingTransition";
interface LanguageProviderProps {
  children: ReactNode;
}
export function LanguageProvider(
‚ãÆ----
const setLanguage = (newLanguage: Language) =>
const t = (key: string) =>
</file>

<file path="app/styles/fantasy-ui.css">
.fantasy-bg {
.magic-border {
.magic-border::before {
.logo-magic-container {
.logo-magic-container::after {
.logo-magic-container:hover::after {
.menu-item {
.menu-item::before {
.menu-item:hover::before {
.menu-item.active::before {
.menu-item:hover svg,
.menu-divider {
.menu-divider::before,
.menu-divider::before {
.menu-divider::after {
.session-card {
.session-card::before {
.session-card:hover {
.session-card:hover::before {
.user-avatar {
.user-avatar::after {
.user-avatar:hover::after {
.fantasy-scrollbar::-webkit-scrollbar {
.fantasy-scrollbar::-webkit-scrollbar-track {
.fantasy-scrollbar::-webkit-scrollbar-thumb {
.fantasy-scrollbar::-webkit-scrollbar-thumb:hover {
.magical-text {
.magical-login-text {
.magical-login-text span {
.login-fantasy-bg {
.login-fantasy-bg::after {
.login-fantasy-bg::before {
‚ãÆ----
.magical-input {
.magical-input::after {
.magical-input:focus-within::after {
.portal-button {
.portal-button::before {
.portal-button:hover {
.portal-button:hover::before {
.toggle-button {
.toggle-button::after {
.toggle-button:hover::after {
.fade-truncate {
.fade-truncate::after {
‚ãÆ----
.animate-pulse-slow {
‚ãÆ----
.animate-ring-pulse {
‚ãÆ----
.breathing-bg {
</file>

<file path="app/styles/fonts.css">
.font-source-sans {
.font-source-serif {
.font-cinzel {
.font-noto-sans-sc {
.font-noto-serif-sc {
html[lang="zh"] .font-sans {
html[lang="en"] .font-sans {
html[lang="zh"] .font-serif {
html[lang="en"] .font-serif {
html[lang="zh"] .font-title {
html[lang="en"] .font-title {
html[lang="zh"] .text-adjust {
html[lang="en"] .text-adjust {
body {
.font-serif,
</file>

<file path="app/styles/local-fonts.css">
@font-face {
‚ãÆ----
:root {
</file>

<file path="app/globals.css">
:root {
body {
html, body {
h1,
a {
a:hover {
button,
input,
input:focus,
.story-text {
.user-input {
::-webkit-scrollbar {
::-webkit-scrollbar-track {
::-webkit-scrollbar-thumb {
::-webkit-scrollbar-thumb:hover {
‚ãÆ----
.animate-gradient-x {
‚ãÆ----
.h-safe-area-inset-bottom {
‚ãÆ----
.mobile-bottom-nav {
</file>

<file path="app/layout.tsx">
import type { Metadata, Viewport } from "next";
‚ãÆ----
import MainLayout from "@/components/MainLayout";
import { LanguageProvider } from "@/app/i18n/LanguageProvider";
import { SoundProvider } from "@/contexts/SoundContext";
import GoogleAnalytics from "@/components/GoogleAnalytics";
import { Analytics } from "@vercel/analytics/react";
‚ãÆ----
export default function RootLayout({
  children,
}:
</file>

<file path="app/metadata.ts">
import { Metadata } from "next";
</file>

<file path="app/not-found.tsx">
import Link from "next/link";
import { motion } from "framer-motion";
import { useLanguage } from "./i18n";
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="app/page.tsx">
import { homeMetadata } from "./metadata";
‚ãÆ----
import { Suspense } from "react";
import HomeContent from "@/components/HomeContent";
‚ãÆ----
function HomeLoading()
</file>

<file path="components/__tests__/ChatHtmlBubble.test.ts">
import { describe, it, expect } from "vitest";
function processText(str: string): string
</file>

<file path="components/AdvancedSettingsEditor.tsx">
import React, { useState, useRef, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { TagColorEditor } from "@/components/TagColorEditor";
‚ãÆ----
interface AdvancedSettingsEditorProps {
  isOpen: boolean;
  onClose: () => void;
  onViewSwitch?: () => void;
}
‚ãÆ----
const handleClickOutside = (event: MouseEvent) =>
</file>

<file path="components/CharacterAvatarBackground.tsx">
import { useEffect, useState } from "react";
import { getBlob } from "@/lib/data/local-storage";
export function CharacterAvatarBackground(
‚ãÆ----
async function loadImage()
</file>

<file path="components/CharacterCardCarousel.tsx">
import React from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
interface CharacterCardCarouselProps {
  characters: Character[];
  onEditClick: (character: Character, e: React.MouseEvent) => void;
  onDeleteClick: (characterId: string) => void;
}
‚ãÆ----
const handleRotateLeft = () =>
const handleRotateRight = () =>
‚ãÆ----
onClick=
‚ãÆ----
trackButtonClick("delete_character_btn", "Âà†Èô§ËßíËâ≤");
e.stopPropagation();
onDeleteClick(character.id);
‚ãÆ----
e.preventDefault();
‚ãÆ----
handleRotateLeft();
‚ãÆ----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
</file>

<file path="components/CharacterCardGrid.tsx">
import React from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import Tilt from "react-parallax-tilt";
import { useLanguage } from "@/app/i18n";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality: string;
  scenario?: string;
  first_mes?: string;
  creatorcomment?: string;
  created_at: string;
  avatar_path?: string;
}
interface CharacterCardGridProps {
  characters: Character[];
  onEditClick: (character: Character, e: React.MouseEvent) => void;
  onDeleteClick: (characterId: string) => void;
}
</file>

<file path="components/CharacterChatHeader.tsx">
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick } from "@/utils/google-analytics";
import { useLanguage } from "@/app/i18n";
interface Props {
  character: {
    name: string;
    avatar_path?: string;
  };
  serifFontClass: string;
  sidebarCollapsed: boolean;
  activeView: "chat" | "worldbook" | "regex" | "preset";
  toggleSidebar: () => void;
  onSwitchToView: (view: "chat" | "worldbook" | "regex" | "preset") => void;
  onToggleView: () => void;
  onToggleRegexEditor: () => void;
}
</file>

<file path="components/CharacterChatPanel.tsx">
import { useEffect, useRef, useState } from "react";
import ChatHtmlBubble from "@/components/ChatHtmlBubble";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { trackButtonClick, trackFormSubmit } from "@/utils/google-analytics";
interface Character {
  id: string;
  name: string;
  personality?: string;
  avatar_path?: string;
}
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp?: string;
  isUser?: boolean;
}
interface Props {
  character: Character;
  messages: Message[];
  userInput: string;
  setUserInput: (val: string) => void;
  isSending: boolean;
  suggestedInputs: string[];
  onSubmit: (e: React.FormEvent) => void;
  onSuggestedInput: (input: string) => void;
  onTruncate: (id: string) => void;
  onRegenerate: (id: string) => void;
  fontClass: string;
  serifFontClass: string;
  t: (key: string) => string;
  activeModes: Record<string, any>;
  setActiveModes: React.Dispatch<React.SetStateAction<Record<string, any>>>;
}
‚ãÆ----
const scrollToBottom = () =>
const maybeScrollToBottom = (threshold = 120) =>
‚ãÆ----
const shouldShowRegenerateButton = (message: Message, index: number) =>
‚ãÆ----
trackFormSubmit("page", "Êèê‰∫§Ë°®Âçï");
onSubmit(event);
‚ãÆ----
onChange=
</file>

<file path="components/CharacterSidebar.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import Link from "next/link";
import DialogueTreeModal from "@/components/DialogueTreeModal";
import { trackButtonClick } from "@/utils/google-analytics";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
import { getAvailableGithubPresets, isPresetDownloaded, downloadPresetFromGithub, doesPresetExist, getPresetDisplayName, getPresetDescription } from "@/function/preset/download";
import AdvancedSettingsEditor from "@/components/AdvancedSettingsEditor";
interface CharacterSidebarProps {
  character: {
    id: string;
    name: string;
    personality?: string;
    avatar_path?: string;
    scenario?: string;
  };
  isCollapsed: boolean;
  toggleSidebar: () => void;
  responseLength?: number;
  onResponseLengthChange?: (length: number) => void;
  onDialogueEdit?: () => void;
  onViewSwitch?: () => void;
}
‚ãÆ----
const handleResponseLengthChange = (event: React.ChangeEvent<HTMLInputElement>) =>
const handleOpenPromptEditor = () =>
const handleDownloadAndEnablePreset = async (presetName: string) =>
‚ãÆ----
const loadGithubPresets = async () =>
‚ãÆ----
const handleResize = () =>
‚ãÆ----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 50 50">
‚ãÆ----
<span>
</file>

<file path="components/ChatHtmlBubble.tsx">
import { useEffect, useRef, memo, useState, useCallback, useMemo } from "react";
import { useSymbolColorStore } from "@/contexts/SymbolColorStore";
import { useLanguage } from "@/app/i18n";
class VirtualRenderQueue
‚ãÆ----
enqueue(task: () => void)
private scheduleProcessing()
private processQueue()
clear()
get length()
getNextTask()
‚ãÆ----
function convertMarkdown(str: string): string
function isCompleteHtmlDocument(str: string): boolean
function detectHtmlTags(str: string)
function generatePalette(uniqueTags: string[]): Record<string, string>
function replaceTags(html: string)
‚ãÆ----
function processHtml(htmlStr: string): string
function processSelfClosingTags(htmlStr: string): string
‚ãÆ----
interface Props {
  html: string;
  isLoading?: boolean;
  serifFontClass?: string;
  forceFullDocument?: boolean;
  enableStreaming?: boolean;
  onContentChange?: () => void;
}
‚ãÆ----
// Virtual queue integration for rendering optimization
‚ãÆ----
// Memoized HTML processing to prevent unnecessary recalculations
‚ãÆ----
// Batched update function using virtual queue
‚ãÆ----
// Queue the update if already processing
‚ãÆ----
// Clear any pending timeout
‚ãÆ----
// Batch the update with a small delay to collect multiple changes
‚ãÆ----
// Process any queued updates
‚ãÆ----
}, 16); // ~60fps
‚ãÆ----
// Optimized height adjustment using virtual queue
‚ãÆ----
// Silent error handling
‚ãÆ----
const handler = (e: MessageEvent) =>
‚ãÆ----
// Use virtual queue for height updates
‚ãÆ----
const resizeHandler = () =>
</file>

<file path="components/CreatePresetModal.tsx">
import { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { createPreset } from "@/function/preset/global";
import { toast } from "react-hot-toast";
interface CreatePresetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: () => void;
}
‚ãÆ----
const handleSubmit = async (e: React.FormEvent) =>
const handleClose = () =>
</file>

<file path="components/DialogueTreeModal.tsx">
import { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { useLanguage } from "@/app/i18n";
import ReactFlow, {
  MiniMap,
  Background,
  useNodesState,
  useEdgesState,
  Node,
  Edge,
  NodeTypes,
  ConnectionLineType,
  Panel,
  Handle,
  Position,
  NodeProps,
  ReactFlowInstance,
} from "reactflow";
‚ãÆ----
import ELK from "elkjs/lib/elk.bundled.js";
import { trackButtonClick } from "@/utils/google-analytics";
import { switchDialogueBranch } from "@/function/dialogue/truncate";
import { getCharacterDialogue } from "@/function/dialogue/info";
import { getIncrementalDialogue } from "@/function/dialogue/incremental-info";
import { editDialaogueNodeContent } from "@/function/dialogue/edit";
interface DialogueTreeModalProps {
  isOpen: boolean;
  onClose: () => void;
  characterId?: string;
  onDialogueEdit?: () => void;
}
interface ELKNode {
  id: string;
  width?: number;
  height?: number;
  x?: number;
  y?: number;
  children?: ELKNode[];
}
interface ELKEdge {
  id: string;
  sources: string[];
  targets: string[];
}
interface ELKGraph {
  id: string;
  children: ELKNode[];
  edges: ELKEdge[];
}
interface DialogueNode extends Node {
  data: {
    label: string;
    fullContent: string;
    userInput: string;
    assistantResponse: string;
    parsedContent: any;
    onEditClick: (id: string) => void;
    onJumpClick: (id: string) => void;
    isCurrentPath: boolean;
    characterId: string;
  };
}
‚ãÆ----
const handleNodeClick = () =>
const handleToggleExpand = (event: React.MouseEvent) =>
const handleJumpClick = async (event: React.MouseEvent) =>
‚ãÆ----
onClick=
‚ãÆ----
title=
‚ãÆ----
function handleClickOutside(event: MouseEvent)
‚ãÆ----
function handleEditModalClickOutside(event: MouseEvent)
‚ãÆ----
const fetchIncrementalDialogueData = async (characterId: string) =>
const fetchDialogueData = async (characterId: string) =>
‚ãÆ----
position: { x: 0, y: 0 }, // Temporary position
‚ãÆ----
// Create edges first (for ELK layout calculation)
‚ãÆ----
const processIncrementalNodes = async (incrementalResponse: any, characterId: string) =>
‚ãÆ----
position: { x: 0, y: 0 }, // Temporary position
‚ãÆ----
// Create edges for new nodes
‚ãÆ----
const saveEditContent = async () =>
‚ãÆ----
<li key=
‚ãÆ----
aria-label=
</file>

<file path="components/DownloadCharacterModal.tsx">
import React, { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { handleCharacterUpload } from "@/function/character/import";
import { useLanguage } from "@/app/i18n";
‚ãÆ----
interface DownloadCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
interface GithubFile {
  name: string;
  download_url: string;
}
interface CharacterInfo {
  displayName: string;
  author: string;
}
‚ãÆ----
const handleDownloadAndImport = async (file: GithubFile) =>
const extractCharacterInfo = (fileName: string): CharacterInfo =>
</file>

<file path="components/EditCharacterModal.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { motion, AnimatePresence } from "framer-motion";
import { trackButtonClick } from "@/utils/google-analytics";
import { updateCharacter } from "@/function/dialogue/update";
import { CharacterAvatarBackground } from "@/components/CharacterAvatarBackground";
interface EditCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  characterId: string;
  characterData: {
    name: string;
    personality?: string;
    scenario?: string;
    first_mes?: string;
    creatorcomment?: string;
    avatar_path?: string;
  };
  onSave: () => void;
}
‚ãÆ----
const handleSubmit = async (e: React.FormEvent) =>
‚ãÆ----
onClick=
‚ãÆ----
xmlns="http://www.w3.org/2000/svg"
</file>

<file path="components/EditPromptModal.tsx">
import React, { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { updatePromptInPreset } from "@/function/preset/edit";
interface PresetPromptData {
  identifier: string;
  name: string;
  system_prompt?: boolean;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  injection_position?: number;
  injection_depth?: number;
  forbid_overrides?: boolean;
  contentLength: number;
}
interface EditPromptModalProps {
  isOpen: boolean;
  onClose: () => void;
  presetId: string;
  prompt: PresetPromptData | null;
  onSave: () => void;
}
‚ãÆ----
const handleSave = async () =>
</file>

<file path="components/GoogleAnalytics.tsx">
import Script from "next/script";
import { useEffect, Suspense } from "react";
import { usePathname, useSearchParams } from "next/navigation";
import { GA_MEASUREMENT_ID, initGA, pageview } from "@/utils/google-analytics";
function GoogleAnalyticsContent()
‚ãÆ----
src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
‚ãÆ----
export default function GoogleAnalytics()
</file>

<file path="components/HomeContent.tsx">
import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import Link from "next/link";
import { useLanguage } from "../app/i18n";
import UserTour from "@/components/UserTour";
import { useTour } from "@/hooks/useTour";
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
‚ãÆ----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="components/ImportCharacterModal.tsx">
import { useState, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
import { handleCharacterUpload } from "@/function/character/import";
interface ImportCharacterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
‚ãÆ----
const handleDragOver = (e: React.DragEvent<HTMLDivElement>) =>
const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) =>
const handleDrop = (e: React.DragEvent<HTMLDivElement>) =>
const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleUpload = async () =>
const resetForm = () =>
const handleClose = () =>
</file>

<file path="components/ImportPresetModal.tsx">
import React, { useState, useRef } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importPresetFromJson } from "@/function/preset/import";
interface ImportPresetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
}
‚ãÆ----
const handleFileSelect = async (file: File) =>
‚ãÆ----
// ‰∏çÁ´ãÂç≥ÂØºÂÖ•ÔºåÊòæÁ§∫È¢ÑËßàÂíåËá™ÂÆö‰πâË°®Âçï
‚ãÆ----
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleImport = async () =>
const handleClose = () =>
</file>

<file path="components/ImportRegexScriptModal.tsx">
import React, { useState, useRef, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importRegexScriptFromJson } from "@/function/regex/import";
import { listGlobalRegexScripts, importFromGlobalRegexScript, GlobalRegexScript, deleteGlobalRegexScript } from "@/function/regex/global";
interface ImportRegexScriptModalProps {
  isOpen: boolean;
  characterId: string;
  onClose: () => void;
  onImportSuccess: () => void;
}
‚ãÆ----
const loadGlobalRegexScripts = async () =>
const handleImportFromGlobal = async () =>
const handleFilesSelect = async (files: File[]) =>
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleClose = () =>
const handleDeleteGlobalScript = async (globalId: string, event: React.MouseEvent) =>
‚ãÆ----
onChange=
‚ãÆ----
onClick=
</file>

<file path="components/ImportWorldBookModal.tsx">
import React, { useState, useRef, useEffect } from "react";
import { toast } from "react-hot-toast";
import { useLanguage } from "@/app/i18n";
import { importWorldBookFromJson } from "@/function/worldbook/import";
import { listGlobalWorldBooks, importFromGlobalWorldBook, GlobalWorldBook, deleteGlobalWorldBook } from "@/function/worldbook/global";
interface ImportWorldBookModalProps {
  isOpen: boolean;
  characterId: string;
  onClose: () => void;
  onImportSuccess: () => void;
}
‚ãÆ----
const loadGlobalWorldBooks = async () =>
const handleImportFromGlobal = async () =>
const handleFileSelect = async (file: File) =>
const handleDragOver = (e: React.DragEvent) =>
const handleDragLeave = (e: React.DragEvent) =>
const handleDrop = (e: React.DragEvent) =>
const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleClose = () =>
const handleDeleteGlobalWorldBook = async (globalId: string, event: React.MouseEvent) =>
‚ãÆ----
onChange=
‚ãÆ----
onClick=
</file>

<file path="components/LoadingTransition.tsx">
import { useEffect, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import gsap from "gsap";
import { useSoundContext } from "@/contexts/SoundContext";
interface LoadingTransitionProps {
  onAnimationComplete?: () => void;
  redirectUrl?: string;
  autoRedirect?: boolean;
  duration?: number;
}
‚ãÆ----
const startAnimation = () =>
const finishAnimation = () =>
const fadeOut = () =>
</file>

<file path="components/LoginModal.tsx">
import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useLanguage } from "@/app/i18n";
interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
}
‚ãÆ----
const handleClickOutside = (event: MouseEvent) =>
const handleEscape = (event: KeyboardEvent) =>
‚ãÆ----
const handleNext = () =>
const handlePrev = () =>
const handleKeyPress = (e: React.KeyboardEvent) =>
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleLogin = async (e: React.FormEvent) =>
const handleSendVerificationCode = () =>
‚ãÆ----
<a href="#" className="text-[#c0a480] hover:text-[#f9c86d] transition-colors text-xs">
</file>

<file path="components/MainLayout.tsx">
import { useState, useEffect } from "react";
import Sidebar from "@/components/Sidebar";
import ModelSidebar from "@/components/ModelSidebar";
import SettingsDropdown from "@/components/SettingsDropdown";
import LoginModal from "@/components/LoginModal";
import MobileBottomNav from "@/components/MobileBottomNav";
‚ãÆ----
const checkIfMobile = () =>
‚ãÆ----
const toggleSidebar = () =>
const toggleModelSidebar = () =>
</file>

<file path="components/MobileBottomNav.tsx">
import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter, usePathname } from "next/navigation";
import { useLanguage } from "@/app/i18n";
‚ãÆ----
interface MobileBottomNavProps {
  openLoginModal: () => void;
}
‚ãÆ----
const checkIfMobile = () =>
‚ãÆ----
const handleLogout = () =>
const isActive = (path: string) =>
</file>

<file path="components/ModelSidebar.tsx">
import { useState, useEffect } from "react";
‚ãÆ----
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
interface ModelSidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
}
type LLMType = "openai" | "ollama";
interface APIConfig {
  id: string;
  name: string;
  type: LLMType;
  baseUrl: string;
  model: string;
  apiKey?: string;
}
‚ãÆ----
/**
   * Loads saved configurations from localStorage and initializes the component state
   * Handles error cases and sets up initial active configuration
   */
‚ãÆ----
/**
   * Loads a configuration into the form fields
   * @param {APIConfig} config - The configuration to load
   */
const loadConfigToForm = (config: APIConfig) =>
/**
   * Generates a unique ID for new configurations
   * @returns {string} A unique identifier
   */
const generateId = () => `api_$
/**
   * Initiates the creation of a new configuration
   * Resets form fields and shows the new configuration form
   */
const handleCreateConfig = () =>
/**
   * Cancels the creation of a new configuration
   * Restores the previous state if available
   */
const handleCancelCreate = () =>
/**
   * Saves the current configuration
   * Handles both new configurations and updates to existing ones
   * Persists changes to localStorage
   */
const handleSave = () =>
const generateConfigName = (type: LLMType, model: string): string =>
const handleDeleteConfig = (id: string) =>
/**
   * Switches to a different configuration
   * @param {string} id - The ID of the configuration to switch to
   */
const handleSwitchConfig = (id: string) =>
const handleGetModelList = async (baseUrl: string, apiKey: string) =>
const handleStartEditName = (config: APIConfig, e: React.MouseEvent) =>
const handleSaveName = () =>
/**
   * Handles keyboard events during name editing
   * @param {React.KeyboardEvent} e - The keyboard event
   */
const handleKeyDown = (e: React.KeyboardEvent) =>
/**
   * Tests the current model configuration using LangChain
   * Sends a test request to verify the configuration works
   * Uses a minimal test prompt to check model connectivity and response
   */
const handleTestModel = async () =>
‚ãÆ----
// Initialize the appropriate LangChain client based on LLM type
‚ãÆ----
onChange=
‚ãÆ----
onClick=
</file>

<file path="components/PresetEditor.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { getAllPresets, getPreset, deletePreset, togglePresetEnabled, getPromptsForDisplay } from "@/function/preset/global";
import { deletePromptFromPreset, togglePromptEnabled } from "@/function/preset/edit";
import { useLanguage } from "@/app/i18n";
import ImportPresetModal from "@/components/ImportPresetModal";
import CreatePresetModal from "@/components/CreatePresetModal";
‚ãÆ----
import React from "react";
import EditPromptModal from "@/components/EditPromptModal";
interface PresetEditorProps {
  onClose: () => void;
  characterName?: string;
  characterId?: string;
}
interface PresetData {
  id: string;
  name: string;
  enabled?: boolean;
  prompts: PresetPromptData[];
  created_at?: string;
  updated_at?: string;
  totalPrompts: number;
  enabledPrompts: number;
  lastUpdated: number;
}
interface PresetPromptData {
  identifier: string;
  name: string;
  system_prompt?: boolean;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  injection_position?: number;
  injection_depth?: number;
  forbid_overrides?: boolean;
  contentLength: number;
}
‚ãÆ----
const loadSortPreferences = () =>
const loadFilterPreferences = () =>
const saveSortPreferences = (newSortBy: string, newSortOrder: "asc" | "desc") =>
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const saveFilterPreferences = (newFilterBy: string) =>
‚ãÆ----
const loadPresetData = async () =>
const filterPresets = (presets: PresetData[], filterBy: string) =>
const sortPresets = (presets: PresetData[], sortBy: string, sortOrder: "asc" | "desc") =>
‚ãÆ----
const handleCreatePreset = async () =>
const handleDeletePreset = async (presetId: string) =>
const handleSelectPreset = async (presetId: string) =>
const toggleRowExpansion = (presetId: string) =>
const handleDeletePrompt = async (presetId: string, promptIdentifier: string) =>
const handleEditPrompt = (prompt: PresetPromptData) =>
const handleCloseEditModal = () =>
const handleSaveEditPrompt = async () =>
const handleTogglePrompt = async (presetId: string, promptIdentifier: string, enableState: boolean) =>
const handleTogglePreset = async (presetId: string, enableState: boolean) =>
</file>

<file path="components/PromptEditor.tsx">
import React, { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { trackButtonClick } from "@/utils/google-analytics";
interface PromptEditorProps {
  isOpen: boolean;
  onClose: () => void;
  characterId: string;
  characterName: string;
  onSave: (prompts: {
    prefixPrompt: string;
    chainOfThoughtPrompt: string;
    suffixPrompt: string;
  }) => void;
  initialPrompts?: {
    prefixPrompt: string;
    chainOfThoughtPrompt: string;
    suffixPrompt: string;
  };
}
‚ãÆ----
const handleResize = () =>
‚ãÆ----
const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) =>
const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) =>
const handleMouseUp = () =>
const handleSave = () =>
‚ãÆ----
onClick=
‚ãÆ----
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
</file>

<file path="components/RegexScriptEditor.tsx">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { RegexScript, RegexScriptSettings } from "@/lib/models/regex-script-model";
import { trackButtonClick } from "@/utils/google-analytics";
import RegexScriptEntryEditor from "@/components/RegexScriptEntryEditor";
import ImportRegexScriptModal from "@/components/ImportRegexScriptModal";
import { updateRegexScriptSettings } from "@/function/regex/update-setting";
import { getRegexScripts } from "@/function/regex/get";
import { getRegexScriptSettings } from "@/function/regex/get-setting";
import { addRegexScript } from "@/function/regex/add";
import { updateRegexScript } from "@/function/regex/update";
import { deleteRegexScript } from "@/function/regex/delete";
interface Props {
  onClose: () => void;
  characterName: string;
  characterId: string;
}
‚ãÆ----
const loadScriptsAndSettings = async () =>
const handleSaveScript = async (script: Partial<RegexScript &
const handleDeleteScript = async (scriptId: string) =>
const handleToggleScript = async (scriptId: string) =>
const handleUpdateSettings = async (updates: Partial<RegexScriptSettings>) =>
const toggleScriptExpansion = (scriptId: string) =>
const filterScripts = (scripts: Record<string, RegexScript>, filterBy: string) =>
const sortScripts = (scriptEntries: [string, RegexScript][], sortBy: string, sortOrder: "asc" | "desc") =>
‚ãÆ----
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const truncateText = (text: string, maxLength: number = 50) =>
</file>

<file path="components/RegexScriptEntryEditor.tsx">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { RegexScript } from "@/lib/models/regex-script-model";
import { toast } from "react-hot-toast";
interface RegexScriptEntryEditorProps {
  isOpen: boolean;
  editingScript: Partial<RegexScript> | null;
  isSaving: boolean;
  onClose: () => void;
  onSave: (script: Partial<RegexScript>) => Promise<void>;
  onScriptChange: (script: Partial<RegexScript>) => void;
}
‚ãÆ----
const updateScript = (updates: Partial<RegexScript>) =>
const handleSave = async () =>
‚ãÆ----
onChange=
‚ãÆ----
</file>

<file path="components/SettingsDropdown.tsx">
import { useState, useRef, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
import { useSoundContext } from "@/contexts/SoundContext";
import { useTour } from "@/hooks/useTour";
import { exportDataToFile, importDataFromFile, generateExportFilename, downloadFile } from "@/function/data/export-import";
import { backupToGoogle, getFolderList, getGoogleCodeByUrl, getGoogleLoginUrl, getBackUpFile } from "@/function/data/google-control";
interface SettingsDropdownProps {
  toggleModelSidebar: () => void;
}
‚ãÆ----
function handleClickOutside(event: MouseEvent)
‚ãÆ----
const toggleLanguage = () =>
const openModelSettings = () =>
const handleExportData = async () =>
const handleImportData = async () =>
async function handleImportDataFromGoogle()
async function handleExportDataToGoogle()
</file>

<file path="components/Sidebar.tsx">
import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useLanguage } from "@/app/i18n";
import { isUpdateAvailable, fetchLatestRelease } from "@/utils/version-compare";
‚ãÆ----
interface SidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
  openLoginModal: () => void;
}
‚ãÆ----
const checkIfMobile = () =>
‚ãÆ----
const checkForUpdates = async () =>
‚ãÆ----
const handleLogout = () =>
</file>

<file path="components/TagColorEditor.tsx">
import React, { useState } from "react";
import { useLanguage } from "@/app/i18n";
import { SketchPicker } from "react-color";
import { useSymbolColorStore } from "@/contexts/SymbolColorStore";
import { toast } from "react-hot-toast";
interface SymbolColor {
  symbol: string;
  color: string;
}
interface TagColorEditorProps {
  onSave: (colors: SymbolColor[]) => void;
  onViewSwitch?: () => void;
}
‚ãÆ----
const handleAddSymbol = () =>
const handleColorChange = (symbol: string, color: string) =>
const handleSave = async () =>
const handleDeleteSymbol = (symbolToDelete: string) =>
const handlePredefinedColorSelect = (symbol: string, color: string) =>
‚ãÆ----
onChange=
placeholder=
</file>

<file path="components/UserTour.tsx">
import { useState, useEffect, useRef } from "react";
import { useLanguage } from "@/app/i18n";
interface TourStep {
  target: string;
  title: string;
  content: string;
  position: "top" | "bottom" | "left" | "right";
  allowSkip?: boolean;
  isLanguageSelection?: boolean;
}
interface UserTourProps {
  steps: TourStep[];
  isVisible: boolean;
  onComplete: () => void;
  onSkip: () => void;
}
‚ãÆ----
const updateTargetPosition = () =>
‚ãÆ----
const nextStep = () =>
const prevStep = () =>
const skipTour = () =>
‚ãÆ----
const getTooltipPosition = () =>
</file>

<file path="components/WorldBookEditor.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";
import { getWorldBookEntries } from "@/function/worldbook/info";
import { deleteWorldBookEntry } from "@/function/worldbook/delete";
import { saveAdvancedWorldBookEntry } from "@/function/worldbook/edit";
import { bulkToggleWorldBookEntries } from "@/function/worldbook/bulk-operations";
import { getWorldBookSettings } from "@/function/worldbook/settings";
import { useLanguage } from "@/app/i18n";
import WorldBookEntryEditor from "@/components/WorldBookEntryEditor";
import ImportWorldBookModal from "@/components/ImportWorldBookModal";
‚ãÆ----
import React from "react";
import { v4 as uuidv4 } from "uuid";
interface WorldBookEditorProps {
  onClose: () => void;
  characterName: string;
  characterId: string;
}
interface WorldBookEntryData {
  entry_id: string;
  id?: number;
  content: string;
  keys: string[];
  secondary_keys: string[];
  selective: boolean;
  constant: boolean;
  position: string | number;
  insertion_order: number;
  enabled: boolean;
  use_regex: boolean;
  depth: number;
  comment: string;
  tokens?: number;
  extensions?: any;
  primaryKey: string;
  keyCount: number;
  secondaryKeyCount: number;
  contentLength: number;
  isActive: boolean;
  lastUpdated: number;
  isImported: boolean;
  importedAt: number | null;
}
interface EditingEntry {
  entry_id: string;
  id?: number;
  comment: string;
  keys: string[];
  secondary_keys: string[];
  content: string;
  position: number;
  depth: number;
  enabled: boolean;
  use_regex: boolean;
  selective: boolean;
  constant: boolean;
  insertion_order: number;
}
‚ãÆ----
const loadSortPreferences = () =>
const loadFilterPreferences = () =>
const saveSortPreferences = (newSortBy: string, newSortOrder: "asc" | "desc") =>
const cleanupOldSortPreferences = () =>
const handleSortByChange = (newSortBy: string) =>
const handleSortOrderChange = () =>
const handleFilterByChange = (newFilterBy: string) =>
const saveFilterPreferences = (newFilterBy: string) =>
‚ãÆ----
const loadWorldBookData = async () =>
const loadSettings = async () =>
const filterEntries = (entries: WorldBookEntryData[], filterBy: string) =>
const sortEntries = (entries: WorldBookEntryData[], sortBy: string, sortOrder: "asc" | "desc") =>
‚ãÆ----
const handleEditEntry = (entry?: WorldBookEntryData) =>
const handleSaveEntry = async () =>
const toggleRowExpansion = (entryId: string) =>
const getPositionText = (position: string | number) =>
const handleBulkToggleAll = async (enabled: boolean) =>
const handleDeleteEntry = async (entryId: string) =>
const handleToggleEntry = async (entryId: string, newEnabled: boolean) =>
‚ãÆ----
<span className="block truncate text-[10px] sm:text-sm" title=
‚ãÆ----
onClick=
</file>

<file path="components/WorldBookEntryEditor.tsx">
import { useLanguage } from "@/app/i18n";
import { useState } from "react";
interface EditingEntry {
  entry_id: string;
  id?: number;
  comment: string;
  keys: string[];
  secondary_keys: string[];
  content: string;
  position: number;
  depth: number;
  enabled: boolean;
  use_regex: boolean;
  selective: boolean;
  constant: boolean;
  insertion_order: number;
}
interface WorldBookEntryEditorProps {
  isOpen: boolean;
  editingEntry: EditingEntry | null;
  isSaving: boolean;
  onClose: () => void;
  onSave: () => void;
  onEntryChange: (entry: EditingEntry) => void;
}
‚ãÆ----
const handleKeywordChange = (index: number, value: string) =>
const handleRemoveKeyword = (index: number) =>
const handleAddKeyword = () =>
const handleSecondaryKeywordChange = (index: number, value: string) =>
const handleRemoveSecondaryKeyword = (index: number) =>
const handleAddSecondaryKeyword = () =>
‚ãÆ----
onChange=
‚ãÆ----
placeholder=
‚ãÆ----
<span className="text-sm text-[#eae6db] group-hover:text-amber-200 transition-colors duration-300">
‚ãÆ----
<span className="text-sm text-[#eae6db] group-hover:text-green-200 transition-colors duration-300">
</file>

<file path="contexts/SoundContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
interface SoundContextType {
  soundEnabled: boolean;
  toggleSound: () => void;
}
‚ãÆ----
export function useSoundContext()
interface SoundProviderProps {
  children: ReactNode;
}
export function SoundProvider(
‚ãÆ----
const toggleSound = () =>
</file>

<file path="contexts/SymbolColorStore.ts">
import { create } from "zustand";
import { persist } from "zustand/middleware";
export interface SymbolColor {
  symbol: string;
  color: string;
}
‚ãÆ----
interface SymbolColorStore {
  symbolColors: SymbolColor[];
  updateSymbolColors: (colors: SymbolColor[]) => void;
  getColorForSymbol: (symbol: string) => string | undefined;
  getColorForHtmlTag: (tagName: string, className?: string) => string | undefined;
  getPredefinedColors: (symbol: string) => string[];
  addCustomTag: (tagName: string, color?: string) => void;
}
</file>

<file path="docs/GETTING_STARTED.md">
# Getting Started with Narratium.ai

This guide will help you get Narratium.ai up and running on your system.

## Prerequisites

- Node.js (v16 or higher)
- pnpm (recommended) or npm
- Git

## Installation Steps

### 1. Clone the project

```bash
git clone https://github.com/Narratium/Narratium.ai.git
cd Narratium
```

### 2. Install dependencies

```bash
pnpm install
```

### 3. Run the project

```bash
pnpm run dev
```

Once the development server starts, visit: [http://localhost:3000](http://localhost:3000)

## Self-packaging

If you want to create a standalone application:

1. First, install the pake-cli globally:
```bash
npm install -g pake-cli
```

2. Then, depending on your operating system, run one of the following commands:

For Docker:
```bash
docker-compose up --build
```

For macOS:
```bash
pnpm pake-mac
```

For Linux:
```bash
pnpm pake-linux
```

For Windows:
```bash
pnpm pake-win
```

### Troubleshooting

#### macOS Installation Fix

If you encounter a "damaged" display after installation on macOS, run this command in terminal:

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```

## Next Steps

- Check out our [documentation](https://deepwiki.com/Narratium/Narratium.ai/) for detailed guides
- Join our community for support and updates
- Star the repository to stay updated with new releases
</file>

<file path="docs/PROBLEM.md">
mac ÂÆâË£ÖÂêéÊòæÁ§∫ÊçüÂùèËß£ÂÜ≥ÊñπÊ°àÔºöÊâìÂºÄÂëΩ‰ª§Ë°åÔºåËæìÂÖ•Ôºö

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```

Solution for "damaged" display after macOS installation: Open the terminal and enter:

```bash
xattr -d com.apple.quarantine /Applications/Narratium.app
```
</file>

<file path="docs/VERCEL_DEPLOYMENT.md">
# Vercel Deployment Guide / Vercel ÈÉ®ÁΩ≤ÊåáÂçó

## English

### Quick Deploy
Click the button below to deploy Narratium.ai to Vercel with one click:

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/Narratium.ai)

### Manual Deployment Steps

1. **Fork the Repository**
   - Fork this repository to your GitHub account

2. **Import to Vercel**
   - Go to [vercel.com](https://vercel.com)
   - Click "New Project"
   - Import your forked repository

3. **Configure Build Settings**
   - Framework Preset: `Next.js`
   - Build Command: `pnpm build` (or leave default)
   - Output Directory: `.next` (default)

4. **Environment Variables** (if needed)
   - Add any required environment variables in Vercel dashboard
   - Common variables: API keys, database URLs, etc.

5. **Deploy**
   - Click "Deploy"
   - Your app will be available at `your-project.vercel.app`

### Auto-Deploy
Once connected, Vercel will automatically deploy when you push to your main branch.

**Please make sure to review the LICENSE file for fork permissions and restrictions, especially regarding brand elements and generated content.**

### Support

For deployment issues, check [Vercel Documentation](https://vercel.com/docs)

---

## ‰∏≠Êñá

### Âø´ÈÄüÈÉ®ÁΩ≤
ÁÇπÂáª‰∏ãÊñπÊåâÈíÆ‰∏ÄÈîÆÈÉ®ÁΩ≤ Narratium.ai Âà∞ VercelÔºö

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/Narratium.ai)

### ÊâãÂä®ÈÉ®ÁΩ≤Ê≠•È™§

1. **Fork ‰ªìÂ∫ì**
   - Â∞ÜÊ≠§‰ªìÂ∫ì Fork Âà∞ÊÇ®ÁöÑ GitHub Ë¥¶Êà∑

2. **ÂØºÂÖ•Âà∞ Vercel**
   - ËÆøÈóÆ [vercel.com](https://vercel.com)
   - ÁÇπÂáª "New Project"
   - ÂØºÂÖ•ÊÇ® Fork ÁöÑ‰ªìÂ∫ì

3. **ÈÖçÁΩÆÊûÑÂª∫ËÆæÁΩÆ**
   - Ê°ÜÊû∂È¢ÑËÆæÔºö`Next.js`
   - ÊûÑÂª∫ÂëΩ‰ª§Ôºö`pnpm build`ÔºàÊàñ‰øùÊåÅÈªòËÆ§Ôºâ
   - ËæìÂá∫ÁõÆÂΩïÔºö`.next`ÔºàÈªòËÆ§Ôºâ

4. **ÁéØÂ¢ÉÂèòÈáè**ÔºàÂ¶ÇÈúÄË¶ÅÔºâ
   - Âú® Vercel ÊéßÂà∂Âè∞Ê∑ªÂä†ÊâÄÈúÄÁöÑÁéØÂ¢ÉÂèòÈáè
   - Â∏∏ËßÅÂèòÈáèÔºöAPI ÂØÜÈí•„ÄÅÊï∞ÊçÆÂ∫ì URL Á≠â

5. **ÈÉ®ÁΩ≤**
   - ÁÇπÂáª "Deploy"
   - ÊÇ®ÁöÑÂ∫îÁî®Â∞ÜÂú® `your-project.vercel.app` ÂèØÁî®

### Ëá™Âä®ÈÉ®ÁΩ≤
ËøûÊé•ÂêéÔºåÊØèÂΩìÊÇ®Êé®ÈÄÅÂà∞‰∏ªÂàÜÊîØÊó∂ÔºåVercel Â∞ÜËá™Âä®ÈÉ®ÁΩ≤„ÄÇ

**ËØ∑Âä°ÂøÖÊü•ÈòÖ LICENSE Êñá‰ª∂Ôºå‰∫ÜËß£ fork ÊùÉÈôêÂíåÈôêÂà∂ÔºåÁâπÂà´ÊòØÂÖ≥‰∫éÂìÅÁâåÂÖÉÁ¥†ÂíåÁîüÊàêÂÜÖÂÆπÁöÑÁõ∏ÂÖ≥ËßÑÂÆö„ÄÇ**

### ÊîØÊåÅ

ÈÉ®ÁΩ≤ÈóÆÈ¢òËØ∑Êü•Áúã [Vercel ÊñáÊ°£](https://vercel.com/docs)
</file>

<file path="function/character/delete.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { deleteBlob } from "@/lib/data/local-storage";
export async function deleteCharacter(character_id: string): Promise<
</file>

<file path="function/character/import.ts">
import { parseCharacterCard } from "@/utils/character-parser";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { setBlob } from "@/lib/data/local-storage";
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
import { v4 as uuidv4 } from "uuid";
export async function handleCharacterUpload(file: File)
</file>

<file path="function/character/list.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { adaptCharacterData } from "@/lib/adapter/tagReplacer";
export async function getAllCharacters(language: "en" | "zh", username?: string)
</file>

<file path="function/data/export-import.ts">
import { exportAllData, importAllData } from "@/lib/data/local-storage";
export async function exportDataToFile(): Promise<Blob>
export async function importDataFromFile(file: File): Promise<void>
export function generateExportFilename(): string
export function downloadFile(blob: Blob, filename: string): void
</file>

<file path="function/data/google-control.ts">
import { createRequest } from "@/function/data/google-request";
‚ãÆ----
export function getGoogleLoginUrl()
export function getGoogleToken(code: string)
export function refreshGoogleToken()
export async function getGoogleCodeByUrl(url: Location)
export async function backupToGoogle(info:
export async function getFolderList()
async function createDefaultFolder()
export async function getBackUpFile(folderId:string)
</file>

<file path="function/data/google-request.ts">
import { refreshGoogleToken } from "./google-control";
export async function createRequest<T = any>(url: string, info: Partial<RequestInit &
</file>

<file path="function/dialogue/chat.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { PromptType } from "@/lib/models/character-prompts-model";
import { ParsedResponse } from "@/lib/models/parsed-response";
import { DialogueWorkflow, DialogueWorkflowParams } from "@/lib/workflow/examples/DialogueWorkflow";
export async function handleCharacterChatRequest(payload: {
  username?: string;
  characterId: string;
  message: string;
  modelName: string;
  baseUrl: string;
  apiKey: string;
  llmType?: string;
  streaming?: boolean;
  language?: "zh" | "en";
  promptType?: PromptType;
  number?: number;
  nodeId: string;
  fastModel: boolean;
}): Promise<Response>
async function processPostResponseAsync({
  characterId,
  message,
  fullResponse,
  screenContent,
  event,
  nextPrompts,
  nodeId,
}: {
  characterId: string;
  message: string;
  fullResponse: string;
  screenContent: string;
  event: string;
  nextPrompts: string[];
  nodeId: string;
})
</file>

<file path="function/dialogue/delete.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
interface DeleteDialogueNodeOptions {
  characterId: string;
  nodeId: string;
}
export async function deleteDialogueNode(
</file>

<file path="function/dialogue/edit.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { CharacterDialogue } from "@/lib/core/character-dialogue";
import { parseEvent } from "@/utils/response-parser";
import { DialogueNode } from "@/lib/models/node-model";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
interface EditDialogueNodeRequest {
  characterId: string;
  nodeId: string;
  assistantResponse: string;
  model_name: string;
  api_key: string;
  base_url: string;
  llm_type: string;
  language: string;
}
export async function editDialaogueNodeContent(input: EditDialogueNodeRequest)
</file>

<file path="function/dialogue/incremental-info.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
interface IncrementalDialogueParams {
  characterId: string;
  lastKnownNodeIds?: string[];
  lastUpdateTime?: string;
  language?: "en" | "zh";
}
interface IncrementalDialogueResponse {
  success: boolean;
  hasNewData: boolean;
  newNodes: any[];
  updatedNodes: any[];
  deletedNodeIds: string[];
  currentNodeId: string;
  totalNodeCount: number;
  lastUpdateTime: string;
}
export async function getIncrementalDialogue(params: IncrementalDialogueParams): Promise<IncrementalDialogueResponse>
export async function hasNewDialogueNodes(characterId: string, lastKnownNodeCount: number): Promise<boolean>
</file>

<file path="function/dialogue/info.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
export async function getCharacterDialogue(characterId: string, language: "en" | "zh" = "zh", username?: string)
</file>

<file path="function/dialogue/init.ts">
import { Character } from "@/lib/core/character";
import { CharacterDialogue } from "@/lib/core/character-dialogue";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { PromptType } from "@/lib/models/character-prompts-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
import { RegexProcessor } from "@/lib/core/regex-processor";
interface InitCharacterDialogueOptions {
  username?: string;
  characterId: string;
  language?: "zh" | "en";
  modelName: string;
  baseUrl: string;
  apiKey: string;
  llmType: "openai" | "ollama";
}
export async function initCharacterDialogue(options: InitCharacterDialogueOptions)
</file>

<file path="function/dialogue/save-prompts.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
interface SaveCharacterPromptsOptions {
  characterId: string;
  prompts: any;
}
export async function saveCharacterPrompts(
</file>

<file path="function/dialogue/truncate.ts">
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
interface SwitchDialogueBranchOptions {
  characterId: string;
  nodeId: string;
}
export async function switchDialogueBranch(
</file>

<file path="function/dialogue/update.ts">
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
export async function updateCharacter(
  character_id: string,
  character_data: any,
): Promise<
</file>

<file path="function/preset/download.ts">
import { importPresetFromJson } from "@/function/preset/import";
import { PresetOperations } from "@/lib/data/preset-operation";
interface GithubPreset {
  name: string;
  displayName: {
    zh: string;
    en: string;
  };
  description: {
    zh: string;
    en: string;
  };
  filename: string;
}
‚ãÆ----
export function getAvailableGithubPresets(): GithubPreset[]
export function getPresetDisplayName(presetName: string, language: "zh" | "en" = "zh"): string
export function getPresetDescription(presetName: string, language: "zh" | "en" = "zh"): string
export async function isPresetDownloaded(presetName: string): Promise<boolean>
export async function doesPresetExist(presetName: string): Promise<boolean>
export async function downloadPresetFromGithub(presetName: string, language: "zh" | "en" = "zh"): Promise<
function markPresetAsDownloaded(presetName: string): void
</file>

<file path="function/preset/edit.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
export async function deletePromptFromPreset(
  presetId: string,
  promptIdentifier: string,
)
export async function togglePromptEnabled(
  presetId: string,
  promptIdentifier: string,
  enabled: boolean,
)
export async function updatePromptInPreset(
  presetId: string,
  promptIdentifier: string,
  updates: { content?: string; enabled?: boolean; position?: number },
)
</file>

<file path="function/preset/global.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
import { Preset } from "@/lib/models/preset-model";
export async function getAllPresets()
export async function getPreset(presetId: string)
export async function createPreset(preset: Preset)
export async function deletePreset(presetId: string)
export async function togglePresetEnabled(presetId: string, enabled: boolean)
export async function getPromptsForDisplay(presetId: string)
</file>

<file path="function/preset/import.ts">
import { PresetOperations } from "@/lib/data/preset-operation";
export async function importPresetFromJson(jsonContent: string, customName?: string): Promise<
</file>

<file path="function/regex/add.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function addRegexScript(characterId: string, script: RegexScript): Promise<string | null>
</file>

<file path="function/regex/delete.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function deleteRegexScript(characterId: string, scriptId: string): Promise<boolean>
</file>

<file path="function/regex/get-setting.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function getRegexScriptSettings(characterId: string): Promise<RegexScriptSettings>
</file>

<file path="function/regex/get.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function getRegexScripts(characterId: string): Promise<Record<string, RegexScript> | null>
</file>

<file path="function/regex/global.ts">
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
export interface GlobalRegexScript {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  scriptCount: number;
  sourceCharacterId?: string;
  sourceCharacterName?: string;
}
export interface GlobalRegexScriptResult {
  success: boolean;
  message: string;
  globalId?: string;
  regexScript?: GlobalRegexScript;
}
export interface ListGlobalRegexScriptsResult {
  success: boolean;
  globalRegexScripts: GlobalRegexScript[];
  message?: string;
}
export async function getNextGlobalId(): Promise<string>
export async function listGlobalRegexScripts(): Promise<ListGlobalRegexScriptsResult>
export async function getGlobalRegexScript(globalId: string): Promise<
export async function importFromGlobalRegexScript(
  characterId: string,
  globalId: string,
): Promise<
export async function deleteGlobalRegexScript(globalId: string): Promise<
</file>

<file path="function/regex/import.ts">
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
import { RegexScript } from "@/lib/models/regex-script-model";
import { v4 as uuidv4 } from "uuid";
export interface ImportRegexScriptResult {
  success: boolean;
  message: string;
  importedCount: number;
  skippedCount: number;
  errors: string[];
  globalId?: string;
  successfulFiles?: string[];
  failedFiles?: string[];
}
export async function importRegexScriptFromJson(
  characterId: string,
  jsonData: any,
  options?: {
    saveAsGlobal?: boolean;
    globalName?: string;
    globalDescription?: string;
    sourceCharacterName?: string;
  },
): Promise<ImportRegexScriptResult>
export function validateRegexScriptJson(jsonData: any):
</file>

<file path="function/regex/update-setting.ts">
import { RegexScriptSettings } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function updateRegexScriptSettings(
  characterId: string,
  updates: Partial<RegexScriptSettings>,
): Promise<RegexScriptSettings>
</file>

<file path="function/regex/update.ts">
import { RegexScript } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export async function updateRegexScript(
  characterId: string,
  scriptId: string,
  updates: Partial<RegexScript>,
): Promise<boolean>
</file>

<file path="function/worldbook/bulk-operations.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function bulkToggleWorldBookEntries(
  characterId: string,
  entryIds: string[],
  enabled: boolean,
)
</file>

<file path="function/worldbook/delete.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function deleteWorldBookEntry(characterId: string, entryId: string)
</file>

<file path="function/worldbook/edit.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export async function saveAdvancedWorldBookEntry(
  characterId: string,
  entry: Partial<WorldBookEntry> & {
    entry_id: string;
    keys: string[];
    content: string;
  },
)
</file>

<file path="function/worldbook/global.ts">
import { WorldBookOperations, WorldBookSettings } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface GlobalWorldBook {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  entryCount: number;
  sourceCharacterId?: string;
  sourceCharacterName?: string;
}
export interface GlobalWorldBookResult {
  success: boolean;
  message: string;
  globalId?: string;
  worldBook?: GlobalWorldBook;
}
export interface ListGlobalWorldBooksResult {
  success: boolean;
  globalWorldBooks: GlobalWorldBook[];
  message?: string;
}
export async function getNextGlobalId(): Promise<string>
export async function saveAsGlobalWorldBook(
  characterId: string,
  name: string,
  description?: string,
  sourceCharacterName?: string,
): Promise<GlobalWorldBookResult>
export async function listGlobalWorldBooks(): Promise<ListGlobalWorldBooksResult>
export async function getGlobalWorldBook(globalId: string): Promise<
export async function importFromGlobalWorldBook(
  characterId: string,
  globalId: string,
): Promise<
export async function deleteGlobalWorldBook(globalId: string): Promise<
</file>

<file path="function/worldbook/import.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { v4 as uuidv4 } from "uuid";
import { saveAsGlobalWorldBook } from "./global";
export interface ImportWorldBookResult {
  success: boolean;
  message: string;
  importedCount: number;
  skippedCount: number;
  errors: string[];
  globalId?: string;
}
export async function importWorldBookFromJson(
  characterId: string,
  jsonData: any,
  options?: {
    saveAsGlobal?: boolean;
    globalName?: string;
    globalDescription?: string;
    sourceCharacterName?: string;
  },
): Promise<ImportWorldBookResult>
export function validateWorldBookJson(jsonData: any):
</file>

<file path="function/worldbook/info.ts">
import { WorldBookOperations } from "@/lib/data/world-book-operation";
export async function getWorldBookEntries(characterId: string)
</file>

<file path="function/worldbook/settings.ts">
import { WorldBookOperations, WorldBookSettings } from "@/lib/data/world-book-operation";
export async function getWorldBookSettings(characterId: string)
export async function updateWorldBookSettings(
  characterId: string,
  updates: Partial<WorldBookSettings>,
)
</file>

<file path="hooks/useTour.ts">
import { useState, useEffect } from "react";
import { useLanguage } from "@/app/i18n";
export interface TourStep {
  target: string;
  title: string;
  content: string;
  position: "top" | "bottom" | "left" | "right";
  allowSkip?: boolean;
  isLanguageSelection?: boolean;
}
‚ãÆ----
export function useTour()
‚ãÆ----
const startHomeTour = () =>
const startCharacterTour = () =>
const completeTour = () =>
const skipTour = () =>
const resetTour = () =>
</file>

<file path="lib/adapter/tagReplacer.ts">
export function adaptText(text: string, language: "en" | "zh", username?: string, charName?: string): string
export function adaptCharacterData(
  characterData: any,
  language: "en" | "zh",
  username?: string,
): any
</file>

<file path="lib/core/agent-engine.ts">
import {
  AgentConversation,
  AgentStep,
  AgentMessage,
  AgentTaskStatus,
  AgentCapability,
  AgentExecutionContext,
  AgentTool,
} from "@/lib/models/agent-model";
import {
  AgentConversationOperations,
  AgentToolOperations,
} from "@/lib/data/agent-operation";
import {
  AgentToolRegistry,
  registerAllTools,
} from "@/lib/core/agent-tools";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { v4 as uuidv4 } from "uuid";
interface AgentDecision {
  action: "use_tool" | "ask_user" | "complete_task" | "request_clarification";
  toolId?: string;
  toolInput?: any;
  message?: string;
  reasoning?: string;
  isComplete?: boolean;
  result?: any;
}
export class AgentEngine
‚ãÆ----
constructor(conversationId: string, llmConfig: {
    modelName: string;
    apiKey: string;
    baseUrl?: string;
    llmType: "openai" | "ollama";
    temperature?: number;
})
async initialize(): Promise<void>
async executeWorkflow(userInput: string): Promise<
async continueWorkflow(userResponse: string): Promise<
private async getNextDecision(): Promise<AgentDecision>
private async executeDecision(decision: AgentDecision, stepsExecuted: AgentStep[]): Promise<
private async executeStep(capability: AgentCapability, input: any, reasoning?: string): Promise<AgentStep>
private async getLLM()
private getCurrentStatus(): string
private updateWorkingMemoryFromTool(toolId: string, output: any): void
private finalizeOutput(): void
private formatStepMessage(capability: AgentCapability, output: any): string
getContext(): AgentExecutionContext
getWorkingMemory(): Record<string, any>
</file>

<file path="lib/core/agent-service.ts">
import { AgentEngine } from "./agent-engine";
import { AgentConversationOperations } from "@/lib/data/agent-operation";
import { AgentConversation, AgentTaskStatus } from "@/lib/models/agent-model";
export class AgentService
‚ãÆ----
async startGeneration(
    title: string,
    userInput: string,
    llmConfig: {
      modelName: string;
      apiKey: string;
      baseUrl?: string;
      llmType: "openai" | "ollama";
      temperature?: number;
    },
): Promise<
async continueGeneration(
    conversationId: string,
    userResponse: string,
): Promise<
async getConversationStatus(conversationId: string): Promise<
async listConversations(): Promise<AgentConversation[]>
async deleteConversation(conversationId: string): Promise<boolean>
async exportConversation(conversationId: string): Promise<
async getGenerationStats(): Promise<
async cleanup(conversationId: string): Promise<void>
getEngine(conversationId: string): AgentEngine | undefined
</file>

<file path="lib/core/agent-tools.ts">
import { AgentTool, AgentCapability, AgentExecutionContext } from "@/lib/models/agent-model";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
export class AgentToolRegistry
‚ãÆ----
static register(tool: AgentTool): void
static get(toolId: string): AgentTool | undefined
static getAll(): AgentTool[]
static getByCapability(capability: AgentCapability): AgentTool[]
static clear(): void
‚ãÆ----
export abstract class BaseTool implements AgentTool
‚ãÆ----
abstract execute(input: any, context: AgentExecutionContext): Promise<any>;
protected async getLLM(context: AgentExecutionContext)
protected async callLLM(
    systemPrompt: string,
    userPrompt: string,
    context: AgentExecutionContext,
): Promise<string>
‚ãÆ----
export class AnalyzeTool extends BaseTool
‚ãÆ----
async execute(input: any, context: AgentExecutionContext): Promise<any>
‚ãÆ----
export class AskTool extends BaseTool
‚ãÆ----
private formatQuestions(questions: string[], context?: string): string
‚ãÆ----
export class SearchTool extends BaseTool
/**
 * PLAN Tool - Creates generation plan and structure
 */
export class PlanTool extends BaseTool
export class OutputTool extends BaseTool
‚ãÆ----
private async generateCharacter(input: any, context: AgentExecutionContext): Promise<any>
private async generateWorldbook(input: any, context: AgentExecutionContext): Promise<any>
‚ãÆ----
// Fallback if JSON parsing fails
‚ãÆ----
private async generateIntegrationNotes(result: any, context: AgentExecutionContext): Promise<string>
‚ãÆ----
/**
 * VALIDATE Tool - Validates content quality and consistency
 */
export class ValidateTool extends BaseTool
‚ãÆ----
private async validateCharacter(characterData: any, requirements: any, context: AgentExecutionContext): Promise<any>
private async validateWorldbook(worldbookData: any[], requirements: any, context: AgentExecutionContext): Promise<any>
private async validateIntegration(characterData: any, worldbookData: any[], context: AgentExecutionContext): Promise<any>
‚ãÆ----
export class RefineTool extends BaseTool
‚ãÆ----
private async refineCharacter(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private async refineWorldbook(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private async refineIntegration(originalContent: any, validationResults: any, userFeedback: string, context: AgentExecutionContext): Promise<any>
private extractRemainingIssues(validationResults: any): string[]
private extractAddressedIssues(validationResults: any): string[]
‚ãÆ----
export function registerAllTools(): void
</file>

<file path="lib/core/character-dialogue.ts">
import { Character } from "@/lib/core/character";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { PromptAssembler } from "@/lib/core/prompt-assembler";
import { RunnablePassthrough } from "@langchain/core/runnables";
import { PromptType } from "@/lib/models/character-prompts-model";
import { getCharacterCompressorPromptZh, getCharacterCompressorPromptEn } from "@/lib/prompts/character-prompts";
import { CharacterHistory } from "@/lib/core/character-history";
import { DialogueOptions } from "@/lib/models/character-dialogue-model";
export class CharacterDialogue
‚ãÆ----
constructor(character: Character)
async initialize(options?: DialogueOptions): Promise<void>
async getFirstMessage(): Promise<string[]>
setupLLM(options?: DialogueOptions): void
‚ãÆ----
type LLMSettings = {
      temperature: number;
      maxTokens?: number;
      timeout?: number;
      maxRetries: number;
      topP?: number;
      frequencyPenalty?: number;
      presencePenalty?: number;
      topK?: number;
      repeatPenalty?: number;
    };
‚ãÆ----
setupDialogueChain(): void
async compressStory(userInput: string, story: string): Promise<string>
</file>

<file path="lib/core/character-history.ts">
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
class DialogueStory
‚ãÆ----
constructor(language: string, userInput: string[] | null = null, responses: string[] | null = null)
getStory(startIndex: number | null = null, endIndex: number | null = null): string
‚ãÆ----
export class CharacterHistory
‚ãÆ----
constructor(language: string, systemMessage: string = "", memLen: number = 10)
getRecentHistory(): string
getCompressedHistory(): string
getSystemMessage(): string
getMessages(): DialogueMessage[]
</file>

<file path="lib/core/character.ts">
import { CharacterRecord } from "@/lib/data/character-record-operation";
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { CharacterData } from "@/lib/models/character-model";
import { adaptCharacterData } from "@/lib/adapter/tagReplacer";
export class Character
‚ãÆ----
constructor(characterRecord: CharacterRecord)
private processCharacterBook(characterBook: any): WorldBookEntry[] | Record<string, WorldBookEntry>
async getFirstMessage(): Promise<string[]>
getData(language: "en" | "zh" = "zh", username?: string): CharacterData
getSystemPrompt(language: "en" | "zh" = "zh", username?: string): string
</file>

<file path="lib/core/preset-assembler.ts">
import { PresetPrompt } from "@/lib/models/preset-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
import { MULTI_MODE_PROMPT, MULTI_MODE_CHAIN_OF_THOUGHT, OUTPUT_STRUCTURE_SOFT_GUIDE } from "@/lib/prompts/preset-prompts";
export class PresetAssembler
‚ãÆ----
static assemblePrompts(
    prompts: PresetPrompt[],
    language: "zh" | "en" = "zh",
    fastModel:boolean,
    contextData: { username?: string; charName?: string; number?: number } = {},
):
private static _getDefaultFramework(language: "zh" | "en" = "zh", contextData:
private static _formatPromptContent(
    prompt: PresetPrompt,
    language: "zh" | "en",
    contextData: { username?: string; charName?: string; number?: number },
): string
</file>

<file path="lib/core/prompt-assembler.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { WorldBookManager } from "@/lib/core/world-book";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { adaptText } from "@/lib/adapter/tagReplacer";
export interface PromptAssemblerOptions {
  language: "zh" | "en";
  contextWindow?: number;
}
export class PromptAssembler
‚ãÆ----
constructor(options: PromptAssemblerOptions)
assemblePrompt(
    worldBook: WorldBookEntry[] | Record<string, WorldBookEntry> | undefined,
    baseSystemMessage: string,
    userMessage: string,
    chatHistory: DialogueMessage[],
    currentUserInput: string,
    username?: string,
    charName?: string,
):
private formatWorldBookEntries(
    entries: WorldBookEntry[],
    username?: string,
    charName?: string,
): string
private adjustChatHistoryByTurns(chatHistory: DialogueMessage[]): DialogueMessage[]
</file>

<file path="lib/core/regex-processor.ts">
import { RegexReplacementResult } from "@/lib/models/regex-script-model";
import { RegexScriptOperations } from "@/lib/data/regex-script-operation";
export interface RegexProcessorOptions {
  ownerId: string;
}
export class RegexProcessor
‚ãÆ----
private static handleEscapeSequences(pattern: string): string
static async processFullContext(
    fullContext: string,
    options: RegexProcessorOptions,
): Promise<RegexReplacementResult>
</file>

<file path="lib/core/world-book.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
export interface WorldBookJson {
  entries: Record<string, WorldBookEntry> | WorldBookEntry[];
}
export class WorldBookManager
‚ãÆ----
static getMatchingEntries(
    worldBook: WorldBookEntry[] | Record<string, WorldBookEntry> | undefined,
    message: string,
    chatHistory: DialogueMessage[],
    options: {
      contextWindow?: number;
    } = {},
): WorldBookEntry[]
static normalizeWorldBookEntries(worldBook: any): WorldBookEntry[]
static organizeEntriesByPosition(
    entries: WorldBookEntry[],
): Record<number, WorldBookEntry[]>
</file>

<file path="lib/data/agent-operation.ts">
import {
  readData,
  writeData,
  AGENT_CONVERSATIONS_FILE,
} from "@/lib/data/local-storage";
import {
  AgentConversation,
  AgentStep,
  AgentMessage,
  AgentTaskStatus,
  AgentCapability,
} from "@/lib/models/agent-model";
import { v4 as uuidv4 } from "uuid";
export class AgentConversationOperations
‚ãÆ----
static async createConversation(title: string): Promise<AgentConversation>
static async getConversationById(id: string): Promise<AgentConversation | null>
static async getAllConversations(): Promise<AgentConversation[]>
static async addMessage(
    conversationId: string,
    message: Omit<AgentMessage, "id" | "timestamp">,
): Promise<AgentMessage>
static async addStep(
    conversationId: string,
    step: Omit<AgentStep, "id" | "timestamp">,
): Promise<AgentStep>
static async updateStatus(conversationId: string, status: AgentTaskStatus): Promise<AgentConversation | null>
static async updateOutput(
    conversationId: string,
    output: { characterData?: any; worldbookData?: any; combinedData?: any },
): Promise<AgentConversation | null>
static async updateMetadata(
    conversationId: string,
    metadata: Partial<AgentConversation["metadata"]>,
): Promise<AgentConversation | null>
static async updateContext(
    conversationId: string,
    context: Partial<AgentConversation["context"]>,
): Promise<AgentConversation | null>
static async updateConversation(conversation: AgentConversation): Promise<AgentConversation>
static async clearCurrentSteps(conversationId: string): Promise<AgentConversation | null>
static async getConversationHistory(conversationId: string, limit?: number): Promise<AgentMessage[]>
static async getCurrentSteps(conversationId: string): Promise<AgentStep[]>
static async getStepByCapability(conversationId: string, capability: AgentCapability): Promise<AgentStep | null>
static async deleteConversation(id: string): Promise<boolean>
static async cleanupOldConversations(daysOld: number = 30): Promise<number>
static async getConversationStats(): Promise<
‚ãÆ----
export class AgentToolOperations
‚ãÆ----
static async recordToolUsage(
    conversationId: string,
    toolId: string,
    input: any,
    output: any,
    stepId: string,
    executionTime?: number,
): Promise<void>
static async getToolUsageStats(conversationId: string): Promise<
static async getAvailableTools(conversationId: string): Promise<string[]>
static async setAvailableTools(conversationId: string, toolIds: string[]): Promise<void>
static async clearToolHistory(conversationId: string): Promise<void>
static async getGlobalToolMetrics(): Promise<
</file>

<file path="lib/data/character-dialogue-operation.ts">
import { readData, writeData, CHARACTER_DIALOGUES_FILE } from "@/lib/data/local-storage";
import { DialogueNode, DialogueTree } from "@/lib/models/node-model";
import { v4 as uuidv4 } from "uuid";
import { ParsedResponse } from "@/lib/models/parsed-response";
export class LocalCharacterDialogueOperations
‚ãÆ----
static async createDialogueTree(characterId: string): Promise<DialogueTree>
static async getDialogueTreeById(dialogueId: string): Promise<DialogueTree | null>
static async addNodeToDialogueTree(
    dialogueId: string,
    parentNodeId: string,
    userInput: string,
    assistantResponse: string,
    fullResponse: string,
    parsedContent?: ParsedResponse,
    nodeId?: string,
): Promise<string>
static async updateDialogueTree(dialogueId: string, updatedDialogue: DialogueTree): Promise<boolean>
static async updateNodeInDialogueTree(
    dialogueId: string,
    nodeId: string,
    updates: Partial<DialogueNode>,
): Promise<DialogueTree | null>
static async switchBranch(dialogueId: string, nodeId: string): Promise<DialogueTree | null>
static async clearDialogueHistory(dialogueId: string): Promise<DialogueTree | null>
static async deleteDialogueTree(dialogueId: string): Promise<boolean>
static async deleteNode(dialogueId: string, nodeId: string): Promise<DialogueTree | null>
‚ãÆ----
const collectNodesToDelete = (currentNodeId: string) =>
‚ãÆ----
static async getDialoguePathToNode(dialogueId: string, nodeId: string): Promise<DialogueNode[]>
static async getChildNodes(dialogueId: string, parentNodeId: string): Promise<DialogueNode[]>
static async getAllDialoguesForCharacter(characterId: string): Promise<DialogueTree[]>
private static convertToDialogueTree(data: any): DialogueTree
static async getSystemMessage(characterId: string): Promise<string>
static async getLastNodeId(characterId: string): Promise<string>
static async nodeExists(characterId: string, nodeId: string): Promise<boolean>
</file>

<file path="lib/data/character-record-operation.ts">
import { readData, writeData, CHARACTERS_RECORD_FILE } from "@/lib/data/local-storage";
import { RawCharacterData } from "@/lib/models/rawdata-model";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
export interface CharacterRecord {
  id: string;
  data: RawCharacterData;
  imagePath: string;
  created_at: string;
  updated_at: string;
}
export class LocalCharacterRecordOperations
‚ãÆ----
static async createCharacter(characterId: string, rawCharacterData: RawCharacterData, imagePath: string): Promise<CharacterRecord>
static async getAllCharacters(): Promise<CharacterRecord[]>
static async getCharacterById(characterId: string): Promise<CharacterRecord>
static async updateCharacter(characterId: string, characterData: Partial<RawCharacterData>): Promise<CharacterRecord | null>
static async deleteCharacter(characterId: string): Promise<boolean>
</file>

<file path="lib/data/local-storage.ts">
function openDB(): Promise<IDBDatabase>
export async function readData(storeName: string): Promise<any[]>
export async function writeData(storeName: string, data: any[]): Promise<void>
export async function initializeDataFiles(): Promise<void>
export async function setBlob(key: string, blob: Blob): Promise<void>
export async function getBlob(key: string): Promise<Blob | null>
export async function deleteBlob(key: string): Promise<void>
export async function exportAllData(): Promise<Record<string, any>>
export async function importAllData(data: Record<string, any>): Promise<void>
async function blobToBase64(blob: Blob): Promise<string>
async function base64ToBlob(base64: string): Promise<Blob>
</file>

<file path="lib/data/preset-operation.ts">
import { readData, writeData, PRESET_FILE } from "@/lib/data/local-storage";
import { Preset, PresetPrompt } from "@/lib/models/preset-model";
export class PresetOperations
‚ãÆ----
static async getPresets(): Promise<Record<string, any>>
private static async savePresets(presets: Record<string, any>): Promise<void>
static async getAllPresets(): Promise<Preset[]>
static async getPreset(presetId: string): Promise<Preset | null>
static async createPreset(preset: Preset): Promise<string | null>
static async updatePreset(presetId: string, updates: Partial<Preset>): Promise<boolean>
static async deletePreset(presetId: string): Promise<boolean>
static async importPreset(jsonData: string | object, customName?: string): Promise<string | null>
static async getOrderedPrompts(presetId: string): Promise<PresetPrompt[]>
static async getPromptsOrderedForDisplay(presetId: string): Promise<PresetPrompt[]>
static async updateCharacterPrompt(
    presetId: string,
    characterId: string | number,
    promptData: {
      identifier: string;
      name: string;
      content?: string;
      enabled?: boolean;
      position?: number;
      [key: string]: any;
    },
): Promise<boolean>
</file>

<file path="lib/data/regex-script-operation.ts">
import { readData, writeData, REGEX_SCRIPTS_FILE } from "@/lib/data/local-storage";
import { RegexScript } from "@/lib/models/regex-script-model";
export interface RegexScriptSettings {
  enabled: boolean;
  applyToPrompt: boolean;
  applyToResponse: boolean;
  metadata?: any;
}
‚ãÆ----
export class RegexScriptOperations
‚ãÆ----
private static async getRegexScriptStore(): Promise<Record<string, any>>
private static async saveRegexScriptStore(store: Record<string, any>): Promise<boolean>
static async getRegexScripts(ownerId: string): Promise<Record<string, RegexScript> | null>
static async updateRegexScript(
    ownerId: string,
    scriptId: string,
    updates: Partial<RegexScript>,
): Promise<boolean>
static async addRegexScript(
    ownerId: string,
    script: RegexScript,
): Promise<string | null>
static async deleteRegexScript(ownerId: string, scriptId: string): Promise<boolean>
private static async updateOwnerScripts(ownerId: string, scripts: Record<string, RegexScript>): Promise<boolean>
static async updateRegexScripts(
    ownerId: string,
    regexScripts: Record<string, RegexScript> | RegexScript[],
): Promise<boolean>
‚ãÆ----
const processScript = (script: RegexScript): RegexScript =>
‚ãÆ----
static async getRegexScriptSettings(ownerId: string): Promise<RegexScriptSettings>
static async updateRegexScriptSettings(
    ownerId: string,
    updates: Partial<RegexScriptSettings>,
): Promise<RegexScriptSettings>
static async getAllScriptsForProcessing(
    ownerId: string,
): Promise<RegexScript[]>
</file>

<file path="lib/data/world-book-operation.ts">
import { readData, writeData, WORLD_BOOK_FILE } from "@/lib/data/local-storage";
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface WorldBookSettings {
  enabled: boolean;
  maxEntries: number;
  contextWindow: number;
  metadata?: any;
}
‚ãÆ----
export class WorldBookOperations
‚ãÆ----
static async getWorldBooks(): Promise<Record<string, any>>
private static async saveWorldBooks(worldBooks: Record<string, any>): Promise<void>
static async getWorldBook(characterId: string): Promise<Record<string, WorldBookEntry> | null>
static async updateWorldBook(
    characterId: string,
    worldBook: Record<string, WorldBookEntry> | WorldBookEntry[],
): Promise<boolean>
‚ãÆ----
const processEntry = (entry: WorldBookEntry): WorldBookEntry =>
‚ãÆ----
static async addWorldBookEntry(
    characterId: string,
    entry: WorldBookEntry,
): Promise<string | null>
static async updateWorldBookEntry(
    characterId: string,
    entryId: string,
    updates: Partial<WorldBookEntry>,
): Promise<boolean>
static async deleteWorldBookEntry(characterId: string, entryId: string): Promise<boolean>
static async getWorldBookSettings(characterId: string): Promise<WorldBookSettings>
static async updateWorldBookSettings(
    characterId: string,
    updates: Partial<WorldBookSettings>,
): Promise<WorldBookSettings>
</file>

<file path="lib/models/agent-model.ts">
export enum AgentCapability {
  SEARCH = "search",
  PLAN = "plan",
  OUTPUT = "output",
  ASK = "ask",
  VALIDATE = "validate",
  REFINE = "refine",
  ANALYZE = "analyze"
}
export enum AgentTaskStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed",
  FAILED = "failed",
  WAITING_FOR_USER = "waiting_for_user"
}
export interface AgentStep {
  id: string;
  capability: AgentCapability;
  input: any;
  output: any;
  reasoning?: string;
  status: AgentTaskStatus;
  executionOrder: number;
  timestamp: string;
  userQuestion?: string;
  userResponse?: any;
  isWaitingForUser?: boolean;
}
export interface AgentMessage {
  id: string;
  role: "user" | "agent" | "system";
  content: string;
  messageType: "text" | "task_request" | "task_result" | "step_update" | "user_question" | "user_response";
  metadata?: {
    capability?: AgentCapability;
    reasoning?: string;
    attachments?: any[];
    questionId?: string;
    stepId?: string;
  };
  timestamp: string;
}
export interface AgentTool {
  id: string;
  name: string;
  description: string;
  capabilities: AgentCapability[];
  inputSchema: any;
  outputSchema: any;
  execute: (input: any, context: AgentExecutionContext) => Promise<any>;
}
export interface AgentConversation {
  id: string;
  title: string;
  status: AgentTaskStatus;
  messages: AgentMessage[];
  currentSteps: AgentStep[];
  availableTools: string[];
  output?: {
    characterData?: any;
    worldbookData?: any;
    combinedData?: any;
  };
  metadata: {
    iterations: number;
    totalTokens?: number;
    executionTime?: number;
    modelUsed?: string;
    temperature?: number;
    toolsUsed?: string[];
  };
  context: {
    userPreferences?: any;
    referenceData?: any;
    constraints?: any;
    pendingQuestions?: Array<{
      id: string;
      question: string;
      stepId: string;
      timestamp: string;
    }>;
    toolUsageHistory?: Array<{
      toolId: string;
      stepId: string;
      input: any;
      output: any;
      timestamp: string;
      executionTime: number;
    }>;
  };
  created_at: string;
  updated_at: string;
}
export interface AgentExecutionContext {
  conversationId: string;
  currentStepIndex: number;
  workingMemory: Record<string, any>;
  availableTools: AgentTool[];
  constraints: {
    maxTokens?: number;
    timeoutMs?: number;
    maxSteps?: number;
  };
  llmConfig?: {
    modelName: string;
    apiKey: string;
    baseUrl?: string;
    llmType: "openai" | "ollama";
    temperature?: number;
  };
}
</file>

<file path="lib/models/character-dialogue-model.ts">
import { ParsedResponse } from "@/lib/models/parsed-response";
import { PromptType } from "@/lib/models/character-prompts-model";
export interface DialogueMessage {
  role: "user" | "assistant" | "system" | "sample";
  content: string;
  parsedContent?: ParsedResponse;
  id: number;
}
export interface DialogueOptions {
  modelName: string;
  apiKey: string;
  baseUrl: string;
  llmType: "openai" | "ollama";
  temperature?: number;
  maxTokens?: number;
  streaming?: boolean;
  language?: "zh" | "en";
  promptType?: PromptType;
  contextWindow?: number;
}
</file>

<file path="lib/models/character-model.ts">
export interface CharacterData {
  name: string;
  description: string;
  personality: string;
  first_mes: string;
  scenario: string;
  mes_example: string;
  creatorcomment: string;
  avatar: string;
  creator_notes?: string;
  imagePath?: string;
  alternate_greetings:string[];
}
</file>

<file path="lib/models/character-prompts-model.ts">
export interface CharacterPromptParams {
  username?: string;
  name: string;
  number: number;
  prefixPrompt?: string;
  chainOfThoughtPrompt?: string;
  suffixPrompt?: string;
  language?: "zh" | "en";
  systemPrompt?: string;
  storyHistory?: string;
  conversationHistory?: string;
  userInput?: string;
  sampleStatus?: string;
}
export enum PromptType {
  COMPANION = "companion",
  NSFW = "nsfw",
  EXPLICIT = "explicit",
  CUSTOM = "custom"
}
</file>

<file path="lib/models/node-model.ts">
import { ParsedResponse } from "@/lib/models/parsed-response";
export class DialogueNode
‚ãÆ----
constructor(
    node_id: string,
    parent_node_id: string,
    user_input: string,
    assistant_response: string,
    full_response: string,
    parsed_content?: ParsedResponse,
    created_at: string = new Date().toISOString(),
)
‚ãÆ----
export class DialogueTree
‚ãÆ----
constructor(
    id: string,
    character_id: string,
    nodes: DialogueNode[] = [],
    current_node_id: string = "root",
    created_at: string = new Date().toISOString(),
    updated_at: string = new Date().toISOString(),
)
</file>

<file path="lib/models/parsed-response.ts">
export interface ParsedResponse {
    regexResult?: string;
    nextPrompts?: string[];
    compressedContent?: string;
  }
</file>

<file path="lib/models/preset-model.ts">
export interface PresetPrompt {
  identifier: string;
  name: string;
  enabled?: boolean;
  marker?: boolean;
  role?: string;
  content?: string;
  forbid_overrides?: boolean;
  group_id?: string | number;
  position?: number;
}
export interface Preset {
  id?: string;
  name: string;
  enabled?: boolean;
  prompts: PresetPrompt[];
  created_at?: string;
  updated_at?: string;
}
</file>

<file path="lib/models/rawdata-model.ts">
import { WorldBookEntry } from "@/lib/models/world-book-model";
export interface RawCharacterData {
  id: any;
  name: string;
  description: string;
  personality: string;
  first_mes: string;
  scenario: string;
  mes_example: string;
  creatorcomment: string;
  avatar: string;
  sample_status: string;
  data:{
    name: string;
    description: string;
    personality: string;
    first_mes: string;
    scenario: string;
    mes_example: string;
    creator_notes: string;
    system_prompt: string;
    post_history_instructions: string;
    tags: string[];
    creator: string;
    character_version: string;
    alternate_greetings: string[];
    character_book:{
      entries: {
        comment: string;
        content: string;
        disable?: boolean;
        position?: number;
        constant?: boolean;
        key?: string[];
        order?: number;
        depth?: number;
      }[] | Record<string, WorldBookEntry>;
    }
  },
}
</file>

<file path="lib/models/regex-script-model.ts">
export interface RegexScript {
  scriptKey: string;
  id?: string;
  scriptName: string;
  findRegex: string;
  replaceString?: string | null;
  trimStrings: string[];
  placement: number[];
  disabled?: boolean;
  extensions?: {
    imported?: boolean;
    importedAt?: number;
    globalSource?: boolean;
    globalSourceId?: string;
    globalSourceName?: string;
  };
}
export enum RegexScriptOwnerType {
  CHARACTER = "character",
  GLOBAL = "global",
  CONVERSATION = "conversation"
}
export interface RegexReplacementResult {
  originalText: string;
  replacedText: string;
  appliedScripts: string[];
  success: boolean;
}
export interface RegexScriptSettings {
  enabled: boolean;
  applyToPrompt: boolean;
  applyToResponse: boolean;
  metadata?: any;
}
</file>

<file path="lib/models/world-book-model.ts">
interface WorldBookEntryExtensions {
  position?: number;
  [key: string]: any;
}
export interface WorldBookEntry {
  entry_id?: string;
  id?: number;
  content: string;
  keys: string[];
  secondary_keys?: string[];
  selective: boolean;
  constant: boolean;
  position: string | number;
  insertion_order?: number;
  enabled?: boolean;
  use_regex?: boolean;
  depth?: number;
  comment?: string;
  tokens?: number;
  extensions?: WorldBookEntryExtensions;
}
</file>

<file path="lib/nodeflow/ContextNode/ContextNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { ContextNodeTools } from "./ContextNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class ContextNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/ContextNode/ContextNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
export class DialogueStory
‚ãÆ----
constructor(language: string, userInput: string[] | null = null, responses: string[] | null = null)
getStory(startIndex: number | null = null, endIndex: number | null = null): string
‚ãÆ----
export class ContextNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async assembleChatHistory(
    userMessage: string,
    characterId: string,
    memoryLength: number = 10,
): Promise<
static async loadCharacterHistory(
    characterId: string,
): Promise<
static formatChatHistory(
    historyData: {
      systemMessage: string;
      recentDialogue: DialogueStory;
      historyDialogue: DialogueStory;
    },
    memoryLength: number,
): string
static getRecentHistory(dialogue: DialogueStory, memLen: number): string
static getCompressedHistory(dialogue: DialogueStory, memLen: number): string
</file>

<file path="lib/nodeflow/LLMNode/LLMNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { LLMNodeTools } from "./LLMNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class LLMNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/LLMNode/LLMNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { ChatOpenAI } from "@langchain/openai";
import { ChatOllama } from "@langchain/ollama";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { RunnablePassthrough } from "@langchain/core/runnables";
export interface LLMConfig {
  modelName: string;
  apiKey: string;
  baseUrl?: string;
  llmType: "openai" | "ollama";
  temperature?: number;
  maxTokens?:number;
  maxRetries?: number,
  topP?: number,
  frequencyPenalty?: number,
  presencePenalty?: number,
  topK?: number,
  repeatPenalty?: number,
  streaming?: boolean;
  streamUsage?: boolean;
  language?: "zh" | "en";
}
export class LLMNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async invokeLLM(
    systemMessage: string,
    userMessage: string,
    config: LLMConfig,
): Promise<string>
private static createLLM(config: LLMConfig): ChatOpenAI | ChatOllama
private static createDialogueChain(llm: ChatOpenAI | ChatOllama): any
</file>

<file path="lib/nodeflow/OutputNode/OutputNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
export class OutputNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/PresetNode/PresetNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { PresetNodeTools } from "./PresetNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class PresetNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/PresetNode/PresetNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { PresetOperations } from "@/lib/data/preset-operation";
import { PresetAssembler } from "@/lib/core/preset-assembler";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { Character } from "@/lib/core/character";
export class PresetNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async buildPromptFramework(
    characterId: string,
    language: "zh" | "en" = "zh",
    username?: string,
    charName?: string,
    number?: number,
    fastModel: boolean = false,
): Promise<
private static enrichPromptsWithCharacterInfo(
    prompts: any[],
    character: Character,
): any[]
</file>

<file path="lib/nodeflow/RegexNode/RegexNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { RegexNodeTools } from "./RegexNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class RegexNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/RegexNode/RegexNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { RegexProcessor } from "@/lib/core/regex-processor";
export class RegexNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async processRegex(
    response: string,
    characterId: string,
): Promise<
</file>

<file path="lib/nodeflow/UserInputNode/UserInputNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
export class UserInputNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async beforeExecute(input: NodeInput): Promise<void>
protected async afterExecute(output: NodeOutput): Promise<void>
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/WorldBookNode/WorldBookNode.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeConfig, NodeInput, NodeOutput, NodeCategory } from "@/lib/nodeflow/types";
import { WorldBookNodeTools } from "./WorldBookNodeTools";
import { NodeToolRegistry } from "../NodeTool";
export class WorldBookNode extends NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getDefaultCategory(): NodeCategory
protected async _call(input: NodeInput): Promise<NodeOutput>
</file>

<file path="lib/nodeflow/WorldBookNode/WorldBookNodeTools.ts">
import { NodeTool } from "@/lib/nodeflow/NodeTool";
import { Character } from "@/lib/core/character";
import { PromptAssembler } from "@/lib/core/prompt-assembler";
import { DialogueMessage } from "@/lib/models/character-dialogue-model";
import { LocalCharacterRecordOperations } from "@/lib/data/character-record-operation";
import { LocalCharacterDialogueOperations } from "@/lib/data/character-dialogue-operation";
export class WorldBookNodeTools extends NodeTool
‚ãÆ----
static getToolType(): string
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
static async assemblePromptWithWorldBook(
    characterId: string,
    baseSystemMessage: string,
    userMessage: string,
    currentUserInput: string,
    language: "zh" | "en" = "zh",
    contextWindow: number = 5,
    username?: string,
    charName?: string,
): Promise<
private static async getChatHistory(characterId: string, contextWindow: number = 5): Promise<DialogueMessage[]>
</file>

<file path="lib/nodeflow/NodeBase.ts">
import { NodeConfig, NodeInput, NodeOutput, NodeExecutionStatus, NodeExecutionResult, NodeCategory } from "@/lib/nodeflow/types";
import { NodeContext } from "@/lib/nodeflow/NodeContext";
import { NodeTool, NodeToolRegistry } from "@/lib/nodeflow/NodeTool";
export abstract class NodeBase
‚ãÆ----
constructor(config: NodeConfig)
protected getInitParams(): string[]
protected getInputFields(): string[]
protected getOutputFields(): string[]
protected getConfigValue<T>(key: string, defaultValue?: T): T | undefined
protected getState<T>(key: string, defaultValue?: T): T | undefined
protected setState<T>(key: string, value: T): void
protected abstract getDefaultCategory(): NodeCategory;
getCategory(): NodeCategory
isEntryNode(): boolean
isExitNode(): boolean
isMiddleNode(): boolean
protected initializeTools(): void
protected async executeTool(methodName: string, ...params: any[]): Promise<any>
getId(): string
getName(): string
getNext(): string[]
protected async resolveInput(context: NodeContext): Promise<NodeInput>
protected async publishOutput(output: NodeOutput, context: NodeContext): Promise<void>
‚ãÆ----
const storeData = (key: string, value: any) =>
‚ãÆ----
async execute(context: NodeContext): Promise<NodeExecutionResult>
protected async beforeExecute(input: NodeInput): Promise<void>
protected async afterExecute(output: NodeOutput): Promise<void>
protected async _call(input: NodeInput): Promise<NodeOutput>
getStatus(): Record<string, any>
toJSON(): NodeConfig
</file>

<file path="lib/nodeflow/NodeContext.ts">
export class NodeContext
‚ãÆ----
constructor(inputData?: Record<string, any>, cacheData?: Record<string, any>, outputData?: Record<string, any>)
setCache(key: string, value: any): void
getCache(key: string): any
hasCache(key: string): boolean
setInput(key: string, value: any): void
getInput(key: string): any
hasInput(key: string): boolean
setOutput(key: string, value: any): void
getOutput(key: string): any
hasOutput(key: string): boolean
clearOutput(): void
clearInput(): void
clearCache(): void
clear(): void
toJSON(): Record<string, any>
static fromJSON(json: Record<string, any>): NodeContext
</file>

<file path="lib/nodeflow/NodeTool.ts">
export abstract class NodeTool
‚ãÆ----
static getToolType(): string
static getVersion(): string
protected static logExecution(methodName: string, params?: any): void
protected static handleError(error: Error, methodName: string): never
static getAvailableMethods(): string[]
static async executeMethod(methodName: string, ...params: any[]): Promise<any>
‚ãÆ----
export interface ToolMetadata {
  type: string;
  version: string;
  methods: string[];
}
export interface ToolMethodDescriptor {
  name: string;
  description: string;
  parameters: ToolParameterDescriptor[];
  returnType: string;
}
export interface ToolParameterDescriptor {
  name: string;
  type: string;
  required: boolean;
  description?: string;
  defaultValue?: any;
}
export function ToolMethod(description: string, parameters: ToolParameterDescriptor[] = [])
export class NodeToolRegistry
‚ãÆ----
static register(toolClass: typeof NodeTool): void
static get(toolType: string): typeof NodeTool | undefined
static isRegistered(toolClass: typeof NodeTool): boolean
static getRegisteredTypes(): string[]
</file>

<file path="lib/nodeflow/types.ts">
export enum NodeCategory {
  ENTRY = "entry",
  MIDDLE = "middle",
  EXIT = "exit"
}
export interface NodeConfig {
  id: string;
  name: string;
  category: NodeCategory;
  next?: string[];
  initParams?: string[];
  inputFields?: string[];
  outputFields?: string[];
  inputMapping?: Record<string, string>;
}
export type NodeInput = Record<string, any>;
export type NodeOutput = Record<string, any>;
export enum NodeExecutionStatus {
  PENDING = "pending",
  RUNNING = "running",
  COMPLETED = "completed",
  FAILED = "failed",
  SKIPPED = "skipped"
}
export interface NodeExecutionResult {
  nodeId: string;
  status: NodeExecutionStatus;
  input: NodeInput;
  output?: NodeOutput;
  error?: Error;
  startTime: Date;
  endTime?: Date;
}
export interface WorkflowConfig {
  id: string;
  name: string;
  nodes: NodeConfig[];
}
export interface WorkflowExecutionResult {
  workflowId: string;
  status: NodeExecutionStatus;
  results: NodeExecutionResult[];
  outputData?: Record<string, any>;
  startTime: Date;
  endTime?: Date;
}
export interface NodeRegistryEntry {
  nodeClass: any;
}
export type NodeRegistry = Record<string, NodeRegistryEntry>;
</file>

<file path="lib/nodeflow/WorkflowEngine.ts">
import { NodeBase } from "@/lib/nodeflow/NodeBase";
import { NodeContext } from "@/lib/nodeflow/NodeContext";
import {
  NodeInput,
  NodeOutput,
  NodeRegistry,
  WorkflowConfig,
  NodeExecutionStatus,
  WorkflowExecutionResult,
} from "@/lib/nodeflow/types";
export class WorkflowEngine
‚ãÆ----
constructor(
    config: WorkflowConfig,
    registry: NodeRegistry,
    context: NodeContext,
)
private initializeNodes(context: NodeContext): void
private getEntryNodes(): NodeBase[]
private getNextNodes(nodeId: string): NodeBase[]
private async executeNode(
    node: NodeBase,
    context: NodeContext,
): Promise<NodeOutput>
private async executeParallel(
    nodes: NodeBase[],
    context: NodeContext,
): Promise<NodeOutput[]>
async execute(
    initialWorkflowInput: NodeInput,
    context?: NodeContext,
): Promise<WorkflowExecutionResult>
async *executeAsync(
    initialWorkflowInput: NodeInput,
    context?: NodeContext,
): AsyncGenerator<NodeOutput[], WorkflowExecutionResult, undefined>
validate(): boolean
private detectCycles(): void
‚ãÆ----
const dfs = (nodeId: string): void =>
</file>

<file path="lib/prompts/character-prompts.ts">
export function getCharacterCompressorPromptZh(userInput: string, story: string): string
export function getCharacterCompressorPromptEn(userInput: string, story: string): string
export function getStatusPromptZh(info: string)
export function getStatusPromptEn(info: string)
</file>

<file path="lib/prompts/preset-prompts.ts">

</file>

<file path="lib/workflow/examples/DialogueWorkflow.ts">
import { BaseWorkflow, WorkflowConfig } from "@/lib/workflow/BaseWorkflow";
import { NodeCategory } from "@/lib/nodeflow/types";
import { UserInputNode } from "@/lib/nodeflow/UserInputNode/UserInputNode";
import { ContextNode } from "@/lib/nodeflow/ContextNode/ContextNode";
import { WorldBookNode } from "@/lib/nodeflow/WorldBookNode/WorldBookNode";
import { PresetNode } from "@/lib/nodeflow/PresetNode/PresetNode";
import { LLMNode } from "@/lib/nodeflow/LLMNode/LLMNode";
import { RegexNode } from "@/lib/nodeflow/RegexNode/RegexNode";
import { OutputNode } from "@/lib/nodeflow/OutputNode/OutputNode";
import { PromptType } from "@/lib/models/character-prompts-model";
export interface DialogueWorkflowParams {
  characterId: string;
  userInput: string;
  number?: number;
  promptType?: PromptType;
  language?: "zh" | "en";
  username?: string;
  modelName: string;
  apiKey: string;
  baseUrl?: string;
  llmType?: "openai" | "ollama";
  temperature?: number;
  maxTokens?: number;
  maxRetries?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  topK?: number;
  repeatPenalty?: number;
  streaming?: boolean;
  streamUsage?: boolean;
  fastModel?: boolean;
}
export class DialogueWorkflow extends BaseWorkflow
‚ãÆ----
protected getNodeRegistry()
protected getWorkflowConfig(): WorkflowConfig
</file>

<file path="lib/workflow/BaseWorkflow.ts">
import { NodeContext } from "../nodeflow/NodeContext";
import { WorkflowEngine } from "../nodeflow/WorkflowEngine";
import { NodeCategory } from "../nodeflow/types";
export interface WorkflowConfig {
  id: string;
  name: string;
  nodes: WorkflowNode[];
}
export interface WorkflowNode {
  id: string;
  name: string;
  category: NodeCategory;
  next: string[];
  initParams: string[];
  inputFields: string[];
  outputFields: string[];
  inputMapping?: Record<string, string>;
}
export interface WorkflowParams {
  [key: string]: any;
}
export class ValidationError extends Error
‚ãÆ----
constructor(message: string)
‚ãÆ----
export abstract class BaseWorkflow
‚ãÆ----
constructor()
protected abstract getNodeRegistry():
protected abstract getWorkflowConfig(): WorkflowConfig;
protected validateWorkflowConfig(): void
private validateEntryNode(node: WorkflowNode): void
private validateInputFields(node: WorkflowNode, availableOutputs: Set<string>): void
private validateNodeConnections(node: WorkflowNode, index: number, nodes: WorkflowNode[]): void
private validateNodeCategories(nodes: WorkflowNode[]): void
public async execute(params: WorkflowParams): Promise<any>
public getContext(): NodeContext
public resetContext(): void
</file>

<file path="utils/character-parser.ts">
import extract from "png-chunks-extract";
import encode from "png-chunks-encode";
import PNGtext from "png-chunk-text";
const encodeBase64 = (str: string): string =>
const decodeBase64 = (b64: string): string =>
export const writeCharacterToPng = async (file: File, data: string): Promise<Blob> =>
export const readCharacterFromPng = async (file: File): Promise<string> =>
export const parseCharacterCard = async (file: File): Promise<string> =>
</file>

<file path="utils/google-analytics.ts">
interface Window {
    gtag: (...args: any[]) => void;
    dataLayer: any[];
  }
‚ãÆ----
export const initGA = () =>
export const pageview = (url: string) =>
export const gtagEvent = (eventName: string, params: Record<string, any>) =>
export const trackButtonClick = (buttonId: string, buttonName: string) =>
export const trackFormSubmit = (formId: string, formName: string) =>
</file>

<file path="utils/response-parser.ts">
export function parseEvent(story: string): string
</file>

<file path="utils/version-compare.ts">
export function isUpdateAvailable(current: string, latest: string): boolean
‚ãÆ----
// Ensure both arrays have the same length by padding with zeros
‚ãÆ----
// Compare each part
‚ãÆ----
/**
 * Fetch the latest release information from GitHub API
 * @returns Promise<{version: string, url: string} | null>
 */
export async function fetchLatestRelease(): Promise<
</file>

<file path=".env.example">
# Google OAuth Configuration
# Copy this file to .env.local and fill in your actual values
GOOGLE_OAUTH_CLIENT_ID=your_google_oauth_client_id_here
GOOGLE_OAUTH_CLIENT_SECRET=your_google_oauth_client_secret_here
GOOGLE_OAUTH_REDIRECT_URI=https://www.narratium.org/oauth2callback
NEXT_PUBLIC_API_KEY=your_api_key
NEXT_PUBLIC_API_URL=your_base_url
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions
# testing
/coverage
show.html

# next.js
/.next/
/out/
/public/characters

# production
/build
!/data
/data/*
# misc
.DS_Store
*.pem
action.txt

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# resources
/resources

Narratium.dmg
Narratium.msi
narratium.deb
</file>

<file path="docker-compose.yml">
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_BASE_URL=http://localhost:3000
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
</file>

<file path="Dockerfile">
FROM node:20.12-alpine AS builder

RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

COPY . .
RUN pnpm build

FROM node:20.12-alpine AS runner

RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app

COPY --from=builder /app/out ./out

RUN pnpm add serve

EXPOSE 3000

CMD ["npx", "serve", "-s", "out", "-l", "3000"]
</file>

<file path="eslint.config.mjs">

</file>

<file path="LICENSE">
# Project License

This project is composed of two distinct parts: source code and user-contributed content.

## 1. Code License (MIT)

All source code in this repository is licensed under the MIT License:

---

MIT License

Copyright (c) [2025] [Narratium/Narratium.ai]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights  
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  
copies of the Software, and to permit persons to whom the Software is  
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  
SOFTWARE.

---

## 2. Community-Contributed Content License (CC BY-NC-SA 4.0)

All community-contributed content ‚Äî including but not limited to character cards, story elements, names, descriptions, and visual assets ‚Äî is licensed under the **Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)** license.

You are free to:

- Share ‚Äî copy and redistribute the material in any medium or format  
- Adapt ‚Äî remix, transform, and build upon the material  

**Under the following terms:**

- **Attribution** ‚Äî You must give appropriate credit to the original creators.  
- **NonCommercial** ‚Äî You may not use the material for commercial purposes.  
- **ShareAlike** ‚Äî If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.

For full details of the CC BY-NC-SA 4.0 license, see:  
[https://creativecommons.org/licenses/by-nc-sa/4.0/](https://creativecommons.org/licenses/by-nc-sa/4.0/)

---

## 3. Additional Restrictions on Generated Content and Brand Elements

**IMPORTANT NOTICE:** While the source code is licensed under MIT, the following restrictions apply:

### Generated Content Ownership and Restrictions
All content generated by this software ‚Äî including but not limited to:
- Generated text, stories, dialogues
- Generated images, artwork, visual content
- Generated character cards and character data
- Any other AI-generated or software-generated content

**Ownership**: Generated content is jointly owned by **Narratium** and the **actual creator/user who performed the creative work**. Fork developers or redistributors of the code do NOT acquire ownership rights to content created by others using their fork.

**Commercial Use**: Generated content **IS STRICTLY PROHIBITED FROM COMMERCIAL USE** without explicit written permission from both Narratium and the original content creator.

### Brand Protection
The following Narratium brand elements are proprietary and **NOT COVERED BY THE MIT LICENSE**:
- The "Narratium" name and trademark
- Project logos, branding, and visual identity
- UI design elements, styles, and layouts specific to Narratium
- Any fork or derivative work that incorporates these elements

**Commercial use of the above brand elements and generated content is strictly forbidden without explicit written permission from Narratium.**

### Permitted Use
You may:
- Use the code for personal, educational, or non-commercial purposes
- Create derivative works for non-commercial use (with proper attribution)
- Study and learn from the codebase

You may NOT:
- Use any generated content for commercial purposes (unless you are the original creator AND have Narratium's permission)
- Use Narratium branding in commercial projects
- Create commercial services using this codebase without removing all Narratium branding
- Claim ownership of content created by other users of your fork

---

## Summary

- ‚úÖ **Code**: MIT License ‚Äî open for commercial and non-commercial use with attribution
- üîí **Community Content**: CC BY-NC-SA 4.0 ‚Äî non-commercial use only, with attribution and same-license sharing required
- üö´ **Generated Content**: No commercial use permitted, belongs to Narratium
- üö´ **Brand Elements**: Proprietary to Narratium, commercial use prohibited

Please review all license terms carefully before using, contributing to, or distributing this project.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";
</file>

<file path="package.json">
{
  "name": "Narratium",
  "version": "0.1.0",
  "private": true,
  "main": "electron/main.js",
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "lint": "next lint",
    "preview": "serve -s out",
    "test": "vitest",
    "pake-mac": "pake out/index.html --name Narratium --use-local-file --icon ./public/icon.icns --multi-arch",
    "pake-win": "pake out/index.html --name Narratium --use-local-file --icon ./public/icon.ico",
    "pake-linux": "pake out/index.html --name narratium --use-local-file --icon ./public/icon.png"
  },
  "dependencies": {
    "@langchain/core": "^0.3.44",
    "@langchain/ollama": "^0.2.0",
    "@langchain/openai": "^0.5.5",
    "@supabase/supabase-js": "^2.50.0",
    "@types/react-color": "^3.0.13",
    "@vercel/analytics": "^1.5.0",
    "better-sqlite3": "^11.9.1",
    "dotenv": "^16.5.0",
    "elkjs": "^0.10.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "framer-motion": "^12.6.3",
    "gsap": "^3.12.7",
    "langchain": "^0.3.24",
    "lucide-react": "^0.514.0",
    "marked": "^15.0.12",
    "next": "15.2.4",
    "png-chunk-text": "^1.0.0",
    "png-chunks-encode": "^1.0.0",
    "png-chunks-extract": "^1.0.0",
    "react": "^19.0.0",
    "react-color": "^2.19.3",
    "react-dom": "^19.0.0",
    "react-hot-toast": "^2.5.2",
    "react-markdown": "^10.1.0",
    "react-parallax-tilt": "^1.7.297",
    "reactflow": "^11.11.4",
    "uuid": "^11.1.0",
    "zod": "^3.25.67",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@next/eslint-plugin-next": "^15.3.1",
    "@tailwindcss/postcss": "^4",
    "@types/better-sqlite3": "^7.6.13",
    "@types/node": "^20",
    "@types/png-chunk-text": "^1.0.3",
    "@types/png-chunks-encode": "^1.0.2",
    "@types/png-chunks-extract": "^1.0.2",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@typescript-eslint/eslint-plugin": "^8.31.0",
    "@typescript-eslint/parser": "^8.31.0",
    "@vitest/expect": "^3.2.2",
    "concurrently": "^9.1.2",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^4",
    "typescript": "^5",
    "vitest": "^3.2.2"
  }
}
</file>

<file path="postcss.config.mjs">

</file>

<file path="README_ZH.md">
<h1 style="border-bottom: none" align="center">
  <a href="https://narratium.org/">Narratium.ai</a>
  <br />
  <p>ÂàõÂª∫„ÄÅÊ∏∏Áé©Âíå‰∏éAIËßíËâ≤ÊâÆÊºî</p>
</h1>

<div align="center">
  <blockquote>
    <em><strong>‰∏ñÁïåÂπøÈòîÊó†Âû†ÔºåËÆ©ÊÉ≥Ë±°ÂäõÂºïÈ¢ÜÂâçË°åÔºå‰ΩÜ‰∫∫ÂøÉÊ∞∏Ëøú‰∏çÂèØÁõ¥ËßÜ</strong></em><br>
    <em><strong>The world is vast, let imagination lead, but human hearts remain forever inscrutable</strong></em>
  </blockquote>
</div>

<br>

![Narratium.ai](/public/banner.png)

<p align="center">
  <em>‰∏Ä‰∏™ÂºÄÊ∫êÁöÑAIËßíËâ≤Âπ≥Âè∞ÔºåÁî®‰∫éÊûÑÂª∫„ÄÅÂÆöÂà∂Âíå‰∏éËôöÊãüËßíËâ≤ËÅäÂ§©</em>
  <br>
  <em>‰∏∫ÊûÑÂª∫‰∫íÂä®‰∏ñÁïåÁöÑ‰ΩúÂÆ∂„ÄÅÂºÄÂèëËÄÖÂíåÊïÖ‰∫ãËÆ≤Ëø∞ËÄÖËÄåËÆæËÆ°</em>
</p>

<div align="center">
  <a href="https://narratium.org">üîó Live Demo</a> &nbsp;|&nbsp;
  <a href="https://deepwiki.com/Narratium/Narratium.ai/">üìñ DeepWiki Docs</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/stargazers">‚≠ê Star Us</a> &nbsp;|&nbsp;
  <a href="https://discord.gg/PP7EpSzDfU">üí¨ Discord Community</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/releases">üíæ Download</a> &nbsp;|&nbsp;
  <a href="./README_ZH.md">üá®üá≥ ‰∏≠ÊñáÊñáÊ°£</a>
</div>

<br>

<div align="center">

![GitHub stars](https://img.shields.io/github/stars/Narratium/Narratium.ai?style=social)
![GitHub forks](https://img.shields.io/github/forks/Narratium/Narratium.ai?style=social)
![GitHub commits](https://img.shields.io/github/commit-activity/m/Narratium/Narratium.ai)
![GitHub Downloads](https://img.shields.io/github/downloads/Narratium/Narratium.ai/total)

</div>

<div align="center">
  <em><strong>ËßíËâ≤„ÄÅ‰∏ñÁïåÂíåÂØπËØù ‚Äî Âú®Narratium‰∏≠ÂÆåÁæéÁªü‰∏Ä</strong></em>
</div>

<br>

<img src="./assets/demo_show.gif" style="width: 100%"/>

## ÂºÄÂßã‰ΩøÁî®Âπ∂ÂÖ≥Ê≥®Êàë‰ª¨

<div align="center">
  <strong>ÁªôÊàë‰ª¨ÊòüÊ†áÔºåÊÇ®Â∞ÜÂèäÊó∂Êî∂Âà∞GitHubÁöÑÊâÄÊúâÂèëÂ∏ÉÈÄöÁü•ÔºÅ</strong>
</div>

<br>

<img src="./assets/welcome_star.gif" style="width: 100%"/>

| ‰ªÄ‰πàÊòØNarratium |
| :---------------- |

[Narratium.ai](https://narratium.org/) ÊòØ‰∏Ä‰∏™Áî®‰∫éÂàõÂª∫AIËßíËâ≤„ÄÅÊ≤âÊµ∏Âºè‰∏ñÁïåÂíåÂä®ÊÄÅÂØπËØùÁöÑÂºÄÊ∫êÂπ≥Âè∞„ÄÇÂÆÉÊòØÊÇ®ÊûÑÂª∫‰∏™ÊÄßÂåñËßíËâ≤ÊâÆÊºîÂÜíÈô©ÁöÑÂàõÊÑèÂ∑•‰ΩúÂÆ§ ‚Äî ‰ªéÊÉÖÊÑüÊóÖÁ®ãÂà∞Âè≤ËØó‰º†Â•á„ÄÇ

| Âø´ÈÄüÂºÄÂßã |
| :---------- |

Â¶ÇÈúÄËØ¶ÁªÜÁöÑÂÆâË£ÖÂíåËÆæÁΩÆËØ¥ÊòéÔºåËØ∑ÂèÇÈòÖÊàë‰ª¨ÁöÑ[Âø´ÈÄüÂºÄÂßãÊåáÂçó](./docs/GETTING_STARTED.md)

Â¶ÇÈúÄËØ¶ÁªÜÁöÑ Vercel ÈÉ®ÁΩ≤ËØ¥ÊòéÔºåËØ∑ÂèÇÈòÖ [Vercel ÈÉ®ÁΩ≤ÊåáÂçó](./docs/VERCEL_DEPLOYMENT.md)„ÄÇ

Â¶ÇÈúÄÂÆ¢Êà∑Á´Ø‰∏ãËΩΩÁâàÊú¨ÔºåËØ∑ËÆøÈóÆ [Mac„ÄÅWindows„ÄÅLinux ‰∏ãËΩΩÈ°µÈù¢](https://github.com/Narratium/Narratium.ai/releases)

| ÂäüËÉΩÁâπÊÄß |
| :------- |

- **Ê≤âÊµ∏ÂºèÂÜíÈô©Ê®°Âºè**: ÂàõÂª∫‰∏™ÊÄßÂåñ‰∏ñÁïåÂπ∂ÂÅöÂá∫ÈáçË¶ÅÁöÑÂÜ≥Á≠ñ„ÄÇ
- **ÂèØËßÜÂåñËÆ∞ÂøÜÁÆ°ÁêÜ**: Âü∫‰∫éReact FlowÁöÑ‰ºöËØùËøΩË∏™ÂíåÂàÜÊîØ„ÄÇ
- **ËßíËâ≤Âç°Áâá‰∏éËÉåÊôØ**: ÂÖºÂÆπSillyTavernÂç°ÁâáÔºåÂú®‰∏ÄÂ§ÑÁÆ°ÁêÜÊâÄÊúâÂÜÖÂÆπ„ÄÇ

| Narratium‰∏éÂÖ∂‰ªñAIËßíËâ≤ÊâÆÊºîÂπ≥Âè∞ÂØπÊØî |
| :---------------------------------------- |

<table style="width: 100%;">
  <tr>
    <th align="center">ÂäüËÉΩ</th>
    <th align="center">Narratium.ai</th>
    <th align="center">SillyTavern</th>
    <th align="center">AI Dungeon</th>
  </tr>
  <tr>
    <td><strong>ÂºÄÊ∫ê</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Êñ∞ÊâãÂèãÂ•Ω</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (Â§çÊùÇËÆæÁΩÆ)</td>
    <td align="center">‚úÖ (‰ΩÜÊµÅÁ®ãÊúâÈôê)</td>
  </tr>
  <tr>
    <td><strong>ËßíËâ≤ËÆ∞ÂøÜ‰∏éËøΩË∏™</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (Âü∫‰∫éÊèí‰ª∂)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>‰∏ñÁïå‰π¶ÊîØÊåÅ</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (ÈÄöËøáÊâ©Â±ï)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>ÈïøÊúüÂØπËØùÊîØÊåÅ</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (‰∏ä‰∏ãÊñáÊúâÈôê)</td>
  </tr>
  <tr>
    <td><strong>Á¶ªÁ∫ø/Êú¨Âú∞ÈÉ®ÁΩ≤</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>ÂèØËßÜÂåñÁïåÈù¢/UIÁ≤æÁæé</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (ÊûÅÁÆÄ)</td>
    <td align="center">‚úÖ</td>
  </tr>
  <tr>
    <td><strong>Êó†ÈôêÂàÜÊîØÊïÖ‰∫ãÊÉÖËäÇ</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (ÈúÄË¶ÅÊâãÂä®Âä™Âäõ)</td>
    <td align="center">‚úÖ (‰ΩÜ‰∏çÁ®≥ÂÆö)</td>
  </tr>
</table>

| ËÆ∏ÂèØËØÅÊ¶ÇËßà |
| :--------------- |

Êú¨È°πÁõÆÁî±‰∏§‰∏™ÂÖ∑ÊúâÁã¨Á´ãËÆ∏ÂèØËØÅÁöÑ‰∏çÂêåÈÉ®ÂàÜÁªÑÊàêÔºö

- ‚úÖ ‰ª£Á†Å: MITËÆ∏ÂèØËØÅ ‚Äî ÂºÄÊîæÁî®‰∫éÂïÜ‰∏öÂíåÈùûÂïÜ‰∏öÁî®ÈÄîÔºåÈúÄË¶ÅÁΩ≤Âêç„ÄÇ
- üîí ÂÜÖÂÆπ: CC BY-NC-SA 4.0 ‚Äî ‰ªÖÈôêÈùûÂïÜ‰∏öÁî®ÈÄîÔºåÈúÄË¶ÅÁΩ≤ÂêçÂíåÁõ∏ÂêåËÆ∏ÂèØËØÅÂÖ±‰∫´„ÄÇ

> ÊúâÂÖ≥ÂÆåÊï¥ËÆ∏ÂèØËØÅËØ¶ÊÉÖÔºåËØ∑ÂèÇÈòÖ [LICENSE](./LICENSE)„ÄÇ

| ËÅîÁ≥ª‰∏éÊîØÊåÅ |
| :---------------- |

* Â¶ÇÊûú‰Ω†ÂñúÊ¨¢Ëøô‰∏™È°πÁõÆÔºåÊàë‰ª¨ÈùûÂ∏∏Ê¨¢Ëøé‰Ω†Âä†ÂÖ•
* If you like this project, we warmly welcome you to join us
[DiscordÁ§æÂå∫](https://discord.gg/PP7EpSzDfU)

| ‰ª£Á†ÅË¥°ÁåÆËÄÖ |
| :--------------- |

[![Contributors](https://contrib.rocks/image?repo=Narratium/Narratium.ai)](https://github.com/Narratium/Narratium.ai/graphs/contributors)

| ÂÖ∂‰ªñ |
| :----- |

ÊÑüË∞¢ÊâÄÊúâÂÆòÊñπÁΩëÁ´ôÊµãËØïAPIËµûÂä©ÂïÜ

| ÊòüÊ†áÂ¢ûÈïø |
| :---------- |

[![Stargazers over time](https://starchart.cc/Narratium/Narratium.ai.svg?variant=adaptive)](https://starchart.cc/Narratium/Narratium.ai)
</file>

<file path="README.md">
<h1 style="border-bottom: none" align="center">
  <a href=https://narratium.org/">Narratium.ai</a>
  <br />
  <p>Create, Play, and Roleplay with AI</p>
</h1>

<div align="center">
  <blockquote>
    <em><strong>The world is vast, let imagination lead, but human hearts remain forever inscrutable</strong></em><br>
    <em><strong>‰∏ñÁïåÂπøÈòîÊó†Âû†ÔºåËÆ©ÊÉ≥Ë±°ÂäõÂºïÈ¢ÜÂâçË°åÔºå‰ΩÜ‰∫∫ÂøÉÊ∞∏Ëøú‰∏çÂèØÁõ¥ËßÜ</strong></em>
  </blockquote>
</div>

<br>

![Narratium.ai](/public/banner.png)

<p align="center">
  <em>An open-source AI character platform to build, customize, and chat with virtual personas</em>
  <br>
  <em>For writers, developers, and storytellers building interactive worlds</em>
</p>

<div align="center">
  <a href="https://narratium.org">üîó Live Demo</a> &nbsp;|&nbsp;
  <a href="https://deepwiki.com/Narratium/Narratium.ai/">üìñ DeepWiki Docs</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/stargazers">‚≠ê Star Us</a> &nbsp;|&nbsp;
  <a href="https://discord.gg/PP7EpSzDfU">üí¨ Discord Community</a> &nbsp;|&nbsp;
  <a href="https://github.com/Narratium/Narratium.ai/releases">üíæ Download</a> &nbsp;|&nbsp;
  <a href="./README_ZH.md">üá®üá≥ ‰∏≠ÊñáÊñáÊ°£</a>
</div>

<br>

<div align="center">

![GitHub stars](https://img.shields.io/github/stars/Narratium/Narratium.ai?style=social)
![GitHub forks](https://img.shields.io/github/forks/Narratium/Narratium.ai?style=social)
![GitHub commits](https://img.shields.io/github/commit-activity/m/Narratium/Narratium.ai)
![GitHub Downloads](https://img.shields.io/github/downloads/Narratium/Narratium.ai/total)

</div>

<div align="center">
  <em><strong>Characters, worlds, and conversations ‚Äî beautifully unified in Narratium</strong></em>
</div>

<br>

<img src="./assets/demo_show.gif" style="width: 100%"/>

## Getting started & staying tuned with us

<div align="center">
  <strong>Star us, and you will receive all release notifications from GitHub without any delay!</strong>
</div>

<br>

<img src="./assets/welcome_star.gif" style="width: 100%"/>

| What is Narratium |
| :---------------- |

[Narratium.ai](https://narratium.org/) is an open-source platform for creating AI characters, immersive worlds, and dynamic conversations.It's your creative studio for building personalized roleplay adventures ‚Äî from emotional journeys to epic sagas.

| Quickly Start |
| :---------- |

For detailed installation and setup instructions, please refer to our [Getting Started Guide](./docs/GETTING_STARTED.md)

For detailed Vercel deployment instructions, please refer to the [Vercel Deployment Guide](./docs/VERCEL_DEPLOYMENT.md).

For Download Version: please refer to the [Download for Mac, Windows, Linux](https://github.com/Narratium/Narratium.ai/releases)

| Features |
| :------- |

- **Immersive Adventure Mode**: Create personalized worlds and make decisions that matter.
- **Visual Memory Management**: React Flow-powered session tracing and branching.
- **Character Cards & Lore**: Compatible with SillyTavern cards, manage everything in one place.

| Narratium vs. Other AI Roleplay Platforms |
| :---------------------------------------- |

<table style="width: 100%;">
  <tr>
    <th align="center">Feature</th>
    <th align="center">Narratium.ai</th>
    <th align="center">SillyTavern</th>
    <th align="center">AI Dungeon</th>
  </tr>
  <tr>
    <td><strong>Open Source</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Beginner Friendly</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (complex setup)</td>
    <td align="center">‚úÖ (but limited flow)</td>
  </tr>
  <tr>
    <td><strong>Character Memory &amp; Tracking</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (plugin-based)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Worldbook Support</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (via extensions)</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Long-term Conversation Support</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (limited context)</td>
  </tr>
  <tr>
    <td><strong>Offline / Local Deployment</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå</td>
  </tr>
  <tr>
    <td><strong>Visual Interface / UI Polish</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ùå (minimal)</td>
    <td align="center">‚úÖ</td>
  </tr>
  <tr>
    <td><strong>Infinite Branching Storylines</strong></td>
    <td align="center">‚úÖ</td>
    <td align="center">‚ö†Ô∏è (manual effort)</td>
    <td align="center">‚úÖ (but unstable)</td>
  </tr>
</table>

| License Overview |
| :--------------- |

This project consists of two distinct parts with independent licenses:

- ‚úÖ Code: MIT License ‚Äî open for commercial and non-commercial use with attribution.
- üîí Content: CC BY-NC-SA 4.0 ‚Äî non-commercial use only, with attribution and same-license sharing required.

> For full license details, please refer to the [LICENSE](./LICENSE).

| Contact & Support |
| :---------------- |

* Â¶ÇÊûú‰Ω†ÂñúÊ¨¢Ëøô‰∏™È°πÁõÆÔºåÊàë‰ª¨ÈùûÂ∏∏Ê¨¢Ëøé‰Ω†Âä†ÂÖ•
* If you like this project, we warmly welcome you to join us
[Discord community](https://discord.gg/PP7EpSzDfU)

| Code Contributer |
| :--------------- |

[![Contributors](https://contrib.rocks/image?repo=Narratium/Narratium.ai)](https://github.com/Narratium/Narratium.ai/graphs/contributors)

| Others |
| :----- |

Thanks all Official Website Test API Sponsor

| Star Growth |
| :---------- |

[![Stargazers over time](https://starchart.cc/Narratium/Narratium.ai.svg?variant=adaptive)](https://starchart.cc/Narratium/Narratium.ai)
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "out/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

</files>
</file>

<file path="signaldb-create-persistent-adapter.md">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# createPersistenceAdapter

```ts
import { createPersistenceAdapter } from '@signaldb/core'
```

While SignalDB comes with a few built-in Persistence Adapters, there may be scenarios where you need to create a custom one to cater to specific requirements.

You can create a custom persistene adapter by calling `createPersistenceAdapter` and supplying a `PersistenceAdapter` compatible object as follows:

```ts
interface Changeset<T> {
  added:    T[],
  modified: T[],
  removed:  T[],
}

// contains either items or changes (but not both)
type LoadResponse<T> =
    { items:  T[],   changes?: never }
  | { items?: never, changes:  Changeset<T> }

interface PersistenceAdapter<T> {
  register(onChange: (data?: LoadResponse<T>) => void | Promise<void>): Promise<void>,
  load(): Promise<LoadResponse<T>>,
  save(items: T[], changes: Changeset<T>): Promise<void>,
  unregister?(): Promise<void>,
}
```

* **register** is called when initializing the collection.  The `onChange` function should be called when data in the adapter was updated externally so the collection can update its internal memory. You can optionally directly pass a `LoadResponse<T>` object returned from the `load` function to make the implementation of your adapter more straightforward.
* **load** is called to load data from the adapter and should return a `LoadResponse<T>` which includes either an `items` property containing all of the items, or a `changeset` property containing only the changes.  The collection will update its internal memory by either replacing all of its items, or applying the changeset to make differential changes, respectively.
* **save** is called when data was updated, and should save the data.  Both `items` and `changes` are provided so you can chose which one you'd like to use.
* **unregister?** *(optional)* is called when the `dispose` method of the collection is called. Allows you to clean up things.

Here is a short example how the File system persistence adapter is implemented:

```js
import fs from 'fs'
import { createPersistenceAdapter } from '@signaldb/core'

export default function createFilesystemAdapter(filename: string) {
  return createPersistenceAdapter({
    async register(onChange) {
      const exists = await fs.promises.access(filename).then(() => true).catch(() => false)
      if (!exists) await fs.promises.writeFile(filename, '[]')
      fs.watch(filename, { encoding: 'utf8' }, () => {
        void onChange()
      })
    },
    async load() {
      const exists = await fs.promises.access(filename).then(() => true).catch(() => false)
      if (!exists) return { items: [] }
      const contents = await fs.promises.readFile(filename, 'utf8')
      const items = JSON.parse(contents)
      return { items }
    },
    async save(items) {
      await fs.promises.writeFile(filename, JSON.stringify(items))
    },
  })
}
```


# Directory Structure of persistence-adapters
```
persistence-adapters/
  fs/
    __tests__/
      adapter.spec.ts
    src/
      index.ts
    CHANGELOG.md
    package.json
    README.md
    tsconfig.json
    typedoc.json
    vite.config.mts
    vitest.config.mts
  indexeddb/
    __tests__/
      adapter.spec.ts
    src/
      index.ts
    CHANGELOG.md
    package.json
    README.md
    tsconfig.json
    typedoc.json
    vite.config.mts
    vitest.config.mts
  localstorage/
    __tests__/
      adapter.spec.ts
    src/
      index.ts
    CHANGELOG.md
    package.json
    README.md
    tsconfig.json
    typedoc.json
    vite.config.mts
    vitest.config.mts
  opfs/
    __tests__/
      adapter.spec.ts
    src/
      index.ts
    CHANGELOG.md
    package.json
    README.md
    tsconfig.json
    typedoc.json
    vite.config.mts
    vitest.config.mts
```

# Files

## File: persistence-adapters/fs/__tests__/adapter.spec.ts
```typescript
import fs from 'fs/promises'
import type { EventEmitter } from '@signaldb/core'
import { it, expect } from 'vitest'
import { Collection } from '@signaldb/core'
import createFilesystemAdapter from '../src'

/**
 * Waits for a specific event to be emitted.
 * @template T
 * @param emitter - The event emitter instance.
 * @param event - The name of the event to wait for.
 * @param [timeout] - Optional timeout in milliseconds.
 * @returns A promise that resolves with the event value.
 */
async function waitForEvent<T>(
  emitter: EventEmitter<any>,
  event: string,
  timeout?: number,
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timeoutId = timeout && setTimeout(() => {
      reject(new Error('waitForEvent timeout'))
    }, timeout)

    emitter.once(event, (value: T) => {
      if (timeoutId) clearTimeout(timeoutId)
      resolve(value)
    })
  })
}

it('should persist changes to filesystem', { retry: 5 }, async () => {
  const file = `/tmp/${Math.floor(Math.random() * 1e17).toString(16)}.json`
  const persistence = createFilesystemAdapter(file)
  const collection = new Collection({ persistence })
  collection.on('persistence.error', (error) => {
    expect(error).toBeUndefined()
  })
  await waitForEvent(collection, 'persistence.init')

  collection.insert({ id: '1', name: 'John' })
  await waitForEvent(collection, 'persistence.transmitted')

  const contents = await fs.readFile(file, 'utf8')
  expect(JSON.parse(contents)).toEqual([{ id: '1', name: 'John' }])
})

it('should persist data that was modified before persistence.init', { retry: 5 }, async () => {
  const file = `/tmp/${Math.floor(Math.random() * 1e17).toString(16)}.json`
  const persistence = createFilesystemAdapter(file)
  await persistence.save([], { added: [], removed: [], modified: [] })
  const collection = new Collection({ persistence })
  collection.insert({ id: '1', name: 'John' })
  collection.insert({ id: '2', name: 'Jane' })
  collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
  collection.removeOne({ id: '2' })
  await waitForEvent(collection, 'persistence.init')

  const items = collection.find().fetch()
  expect(items).toEqual([{ id: '1', name: 'Johnny' }])
  const contents = await fs.readFile(file, 'utf8')
  expect(JSON.parse(contents)).toEqual([{ id: '1', name: 'Johnny' }])
})
```

## File: persistence-adapters/fs/src/index.ts
```typescript
import { createPersistenceAdapter } from '@signaldb/core'

/**
 * Creates a persistence adapter for managing a SignalDB collection backed by a filesystem.
 * This adapter reads and writes data to a file, providing serialization and deserialization options.
 * @template T - The type of the items in the collection.
 * @template I - The type of the unique identifier for the items.
 * @param filename - The name of the file to read/write data from/to.
 * @param options - Optional configuration for serialization and deserialization.
 * @param options.serialize - A function to serialize items to a string (default: `JSON.stringify`).
 * @param options.deserialize - A function to deserialize a string into items (default: `JSON.parse`).
 * @returns A SignalDB persistence adapter for managing data in the filesystem.
 * @example
 * import createFilesystemAdapter from './createFilesystemAdapter';
 *
 * const adapter = createFilesystemAdapter('data.json', {
 *   serialize: (items) => JSON.stringify(items, null, 2), // Pretty-print JSON
 *   deserialize: (itemsString) => JSON.parse(itemsString), // Default JSON parse
 * });
 *
 * const collection = new Collection({
 *   persistence: adapter,
 * });
 *
 * // Perform operations on the collection, and changes will be reflected in the file.
 */
export default function createFilesystemAdapter<
  T extends { id: I } & Record<string, any>,
  I,
>(
  filename: string,
  options?: {
    serialize?: (items: T[]) => string,
    deserialize?: (itemsString: string) => T[],
  },
) {
  const { serialize = JSON.stringify, deserialize = JSON.parse } = options || {}

  let savePromise: Promise<void> | null = null

  /**
   * Retrieves the items from the file.
   * @returns A promise that resolves to an array of items.
   */
  async function getItems(): Promise<T[]> {
    const fs = await import('fs')
    const exists = await fs.promises.access(filename).then(() => true).catch(() => false)
    if (!exists) return []
    const serializedItems = await fs.promises.readFile(filename, 'utf8').catch((error) => {
      /* istanbul ignore next -- @preserve */
      if (error.code === 'ENOENT') return
      /* istanbul ignore next -- @preserve */
      throw error
    })
    return serializedItems ? deserialize(serializedItems) : []
  }

  return createPersistenceAdapter<T, I>({
    async register(onChange) {
      // eslint-disable-next-line unicorn/prefer-global-this
      if (typeof window !== 'undefined') throw new Error('Filesystem adapter is not supported in the browser')
      const fs = await import('fs')
      const exists = await fs.promises.access(filename).then(() => true).catch(() => false)
      if (!exists) await fs.promises.writeFile(filename, '[]')
      fs.watch(filename, { encoding: 'utf8' }, () => {
        void onChange()
      })
    },
    async load() {
      // eslint-disable-next-line unicorn/prefer-global-this
      if (typeof window !== 'undefined') throw new Error('Filesystem adapter is not supported in the browser')
      if (savePromise) await savePromise
      const items = await getItems()
      return { items }
    },
    async save(_items, { added, modified, removed }) {
      // eslint-disable-next-line unicorn/prefer-global-this
      if (typeof window !== 'undefined') throw new Error('Filesystem adapter is not supported in the browser')
      if (savePromise) await savePromise
      savePromise = getItems()
        .then((currentItems) => {
          const items = [...currentItems]
          added.forEach((item) => {
            const index = items.findIndex(({ id }) => id === item.id)
            /* istanbul ignore if -- @preserve */
            if (index !== -1) {
              items[index] = item
              return
            }
            items.push(item)
          })
          modified.forEach((item) => {
            const index = items.findIndex(({ id }) => id === item.id)
            /* istanbul ignore if -- @preserve */
            if (index === -1) {
              items.push(item)
              return
            }
            items[index] = item
          })
          removed.forEach((item) => {
            const index = items.findIndex(({ id }) => id === item.id)
            /* istanbul ignore if -- @preserve */
            if (index === -1) return
            items.splice(index, 1)
          })
          return items
        })
        .then(async (items) => {
          const fs = await import('fs')
          await fs.promises.writeFile(filename, serialize(items))
        })
        .then(() => {
          savePromise = null
        })
      await savePromise
    },
  })
}
```

## File: persistence-adapters/fs/CHANGELOG.md
```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Fixed

* Custom deserialize function now works correctly when file is empty (thanks to @krolebord!)

## [1.0.1] - 2025-04-24

### Fixed

* Avoid duplicate ids and unnecessary errors

## [1.0.0] - 2024-12-16

### Added

* Added JSDoc comments to public API
```

## File: persistence-adapters/fs/package.json
```json
{
  "name": "@signaldb/fs",
  "version": "1.0.1",
  "description": "",
  "scripts": {
    "build": "rimraf dist && vite build",
    "analyze-bundle": "bundle-analyzer ./dist --upload-token=$BUNDLE_ANALYZER_UPLOAD_TOKEN --bundle-name=@signaldb/fs",
    "test": "vitest"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/maxnowack/signaldb.git"
  },
  "homepage": "https://signaldb.js.org",
  "keywords": [
    "filesystem",
    "client-database",
    "client",
    "database",
    "local-database",
    "offline-first",
    "optimistic-ui",
    "plugin",
    "reactive",
    "reactivity",
    "solid",
    "synchronization",
    "typescript"
  ],
  "author": "Max Nowack <max.nowack@gmail.com>",
  "license": "MIT",
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.umd.js",
      "default": "./dist/index.umd.js"
    }
  },
  "main": "./dist/index.umd.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "typesVersions": {
    "*": {
      "*": [
        "./dist/*",
        "./dist/index.d.ts"
      ]
    }
  },
  "files": [
    "dist"
  ],
  "peerDependencies": {
    "@signaldb/core": "1.x"
  }
}
```

## File: persistence-adapters/fs/README.md
```markdown
# @signaldb/fs

This is the filesystem persistence adapter for [SignalDB](https://github.com/maxnowack/signaldb). SignalDB is a local-first JavaScript database with real-time sync, enabling optimistic UI with signal-based reactivity across multiple frameworks.

See https://signaldb.js.org/reference/fs/ for more information.
```

## File: persistence-adapters/fs/tsconfig.json
```json
{
  "extends": "../../../tsconfig.json",
  "exclude": [
    "**/*.spec.ts",
  ],
  "include": [
    "src/**/*.ts"
  ]
}
```

## File: persistence-adapters/fs/typedoc.json
```json
{
     "extends": ["../../../typedoc.base.json"],
     "entryPoints": ["src/index.ts"]
 }
```

## File: persistence-adapters/fs/vite.config.mts
```
/// <reference types="vitest" />
import path from 'path'
import { defineConfig } from 'vite'
import typescript from '@rollup/plugin-typescript'
import { typescriptPaths } from 'rollup-plugin-typescript-paths'
import dts from 'vite-plugin-dts'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [
    dts(),
    tsconfigPaths(),
  ],
  build: {
    manifest: true,
    minify: true,
    sourcemap: true,
    reportCompressedSize: true,
    lib: {
      name: 'SignalDB',
      entry: path.resolve(__dirname, 'src/index.ts'),
      fileName: format => (format === 'es' ? 'index.mjs' : `index.${format}.js`),
    },
    rollupOptions: {
      external: [
        '@signaldb/core',
        'fs',
      ],
      plugins: [
        typescriptPaths({
          preserveExtensions: true,
        }),
        typescript({
          sourceMap: false,
          declaration: true,
          outDir: 'dist',
        }),
      ],
    },
  },
})
```

## File: persistence-adapters/fs/vitest.config.mts
```
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config.mts'

export default mergeConfig(viteConfig, defineConfig({}))
```

## File: persistence-adapters/indexeddb/__tests__/adapter.spec.ts
```typescript
// @vitest-environment happy-dom
import type { EventEmitter } from '@signaldb/core'
import { describe, it, expect } from 'vitest'
import { Collection } from '@signaldb/core'
import 'fake-indexeddb/auto'
import createIndexedDBAdapter from '../src'

/**
 * Waits for a specific event to be emitted.
 * @param emitter - The event emitter.
 * @param event - The event to wait for.
 * @param [timeout] - Optional timeout in milliseconds.
 * @returns A promise that resolves with the event value.
 */
async function waitForEvent<T>(
  emitter: EventEmitter<any>,
  event: string,
  timeout?: number,
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timeoutId = timeout && setTimeout(() => {
      reject(new Error('waitForEvent timeout'))
    }, timeout)

    emitter.once(event, (value: T) => {
      if (timeoutId) clearTimeout(timeoutId)
      resolve(value)
    })
  })
}

describe('Persistence', () => {
  describe('IndexedDB', () => {
    it('should load items from IndexedDB persistence adapter', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')
      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'John' }])
    })

    it('should save items to IndexedDB persistence adapter', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')
      collection.insert({ id: '1', name: 'John' })
      await waitForEvent(collection, 'persistence.transmitted')
      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'John' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'John' }])
    })

    it('should remove item from IndexedDB persistence adapter', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }, { id: '2', name: 'Jane' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.removeOne({ id: '1' })
      await waitForEvent(collection, 'persistence.transmitted')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '2', name: 'Jane' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '2', name: 'Jane' }])
    })

    it('should update item in IndexedDB persistence adapter', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
      await waitForEvent(collection, 'persistence.transmitted')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'Johnny' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'Johnny' }])
    })

    it('should not modify original items in IndexedDB persistence adapter', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      const originalItems = [{ id: '1', name: 'John' }]
      await persistence.save([], { added: originalItems, removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.insert({ id: '2', name: 'Jane' })
      await waitForEvent(collection, 'persistence.transmitted')

      expect(originalItems).toEqual([{ id: '1', name: 'John' }])
    })

    it('should handle multiple operations in order', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.insert({ id: '1', name: 'John' })
      await waitForEvent(collection, 'persistence.transmitted')
      collection.insert({ id: '2', name: 'Jane' })
      await waitForEvent(collection, 'persistence.transmitted')
      collection.removeOne({ id: '1' })
      await waitForEvent(collection, 'persistence.transmitted')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '2', name: 'Jane' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '2', name: 'Jane' }])
    })

    it('should persist data that was modified before persistence.init on client side', { retry: 5 }, async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      collection.insert({ id: '1', name: 'John' })
      collection.insert({ id: '2', name: 'Jane' })
      collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
      collection.removeOne({ id: '2' })
      await waitForEvent(collection, 'persistence.init')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'Johnny' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'Johnny' }])
    })

    it('should not overwrite persisted data if items is undefined and changeSet is empty.', async () => {
      const persistence = createIndexedDBAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')
      await persistence.save([], { added: [], removed: [], modified: [] })
      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'John' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'John' }])
    })

    it('should use custom prefix when provided in options', async () => {
      const collectionName = `test-${Math.floor(Math.random() * 1e17).toString(16)}`
      const customPrefix = 'custom-prefix-'
      const persistence = createIndexedDBAdapter(collectionName, { prefix: customPrefix })
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })

      // Verify data was saved with the custom prefix by opening the database directly
      const openRequest = indexedDB.open(`${customPrefix}${collectionName}`, 1)
      const database = await new Promise<IDBDatabase>((resolve, reject) => {
        openRequest.addEventListener('success', () => resolve(openRequest.result))
        openRequest.addEventListener('error', () => reject(new Error('Failed to open database with custom prefix')))
      })

      const transaction = database.transaction('items', 'readonly')
      const store = transaction.objectStore('items')
      const getAllRequest = store.getAll()

      const items = await new Promise<any[]>((resolve, reject) => {
        getAllRequest.addEventListener('success', () => resolve(getAllRequest.result))
        getAllRequest.addEventListener('error', () => reject(new Error('Failed to get items')))
      })

      expect(items).toEqual([{ id: '1', name: 'John' }])
      database.close()
    })
  })
})
```

## File: persistence-adapters/indexeddb/src/index.ts
```typescript
import { createPersistenceAdapter } from '@signaldb/core'

/**
 * Creates a persistence adapter for managing a SignalDB collection using IndexedDB.
 * This adapter reads and writes data to an IndexedDB object store, with customizable serialization and deserialization.
 * @template T - The type of the items in the collection.
 * @template I - The type of the unique identifier for the items.
 * @param name - A unique name for the collection, used as the database name.
 * @param options - Optional configuration for the adapter.
 * @param options.prefix - A prefix to be added to the database name (default: 'signaldb-').
 * @returns A SignalDB persistence adapter for managing data in IndexedDB.
 */
export default function createIndexedDBAdapter<
  T extends { id: I } & Record<string, any>,
  I extends IDBValidKey,
>(name: string, options?: { prefix?: string }) {
  const { prefix = 'signaldb-' } = options || {}
  const databaseName = `${prefix}${name}`
  const storeName = 'items'

  /**
   * Opens the IndexedDB database and creates the object store if it doesn't exist.
   * @returns A promise that resolves with the opened database.
   */
  function openDatabase(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(databaseName, 1)
      request.addEventListener('upgradeneeded', () => {
        const database = request.result
        if (!database.objectStoreNames.contains(storeName)) {
          database.createObjectStore(storeName, { keyPath: 'id' })
        }
      })
      request.addEventListener('success', () => resolve(request.result))
      request.addEventListener('error', () => reject(new Error(request.error?.message || 'Database error')))
    })
  }

  /**
   * Retrieves all items from the IndexedDB object store.
   * @returns A promise that resolves with an array of items.
   */
  async function getAllItems(): Promise<T[]> {
    const database = await openDatabase()
    return new Promise((resolve, reject) => {
      const transaction = database.transaction(storeName, 'readonly')
      const store = transaction.objectStore(storeName)
      const request = store.getAll()
      request.addEventListener('success', () => resolve(request.result as T[]))
      request.addEventListener('error', () => reject(new Error(request.error?.message || 'Error fetching items')))
    })
  }

  return createPersistenceAdapter<T, I>({
    async load() {
      const items = await getAllItems()
      return { items }
    },
    async save(items, { added, modified, removed }) {
      const database = await openDatabase()
      const transaction = database.transaction(storeName, 'readwrite')
      const store = transaction.objectStore(storeName)

      added.forEach(item => store.add(item))
      modified.forEach(item => store.put(item))
      removed.forEach(item => store.delete(item.id))

      return new Promise((resolve, reject) => {
        transaction.addEventListener('complete', () => resolve())
        transaction.addEventListener('error', () => reject(new Error(transaction.error?.message || 'Transaction error')))
      })
    },
    async register() {
      return
    },
  })
}
```

## File: persistence-adapters/indexeddb/CHANGELOG.md
```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [1.1.0] - 2025-05-08

### Added

* Added support for custom database prefix option (thanks to @pierissimo!)

## [1.0.0] - 2025-01-06

* Initial release
```

## File: persistence-adapters/indexeddb/package.json
```json
{
  "name": "@signaldb/indexeddb",
  "version": "1.1.0",
  "description": "",
  "scripts": {
    "build": "rimraf dist && vite build",
    "analyze-bundle": "bundle-analyzer ./dist --upload-token=$BUNDLE_ANALYZER_UPLOAD_TOKEN --bundle-name=@signaldb/indexeddb",
    "test": "vitest"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/maxnowack/signaldb.git"
  },
  "homepage": "https://signaldb.js.org",
  "keywords": [
    "indexeddb",
    "client-database",
    "client",
    "database",
    "local-database",
    "offline-first",
    "optimistic-ui",
    "plugin",
    "reactive",
    "reactivity",
    "solid",
    "synchronization",
    "typescript"
  ],
  "author": "Max Nowack <max.nowack@gmail.com>",
  "license": "MIT",
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.umd.js",
      "default": "./dist/index.umd.js"
    }
  },
  "main": "./dist/index.umd.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "typesVersions": {
    "*": {
      "*": [
        "./dist/*",
        "./dist/index.d.ts"
      ]
    }
  },
  "files": [
    "dist"
  ],
  "devDependencies": {
    "fake-indexeddb": "6.0.1"
  },
  "peerDependencies": {
    "@signaldb/core": "1.x"
  }
}
```

## File: persistence-adapters/indexeddb/README.md
```markdown
# @signaldb/indexeddb

This is the `IndexedDB` persistence adapter for [SignalDB](https://github.com/maxnowack/signaldb). SignalDB is a local-first JavaScript database with real-time sync, enabling optimistic UI with signal-based reactivity across multiple frameworks.

See https://signaldb.js.org/reference/indexeddb/ for more information.
```

## File: persistence-adapters/indexeddb/tsconfig.json
```json
{
  "extends": "../../../tsconfig.json",
  "exclude": [
    "**/*.spec.ts",
  ],
  "include": [
    "src/**/*.ts"
  ]
}
```

## File: persistence-adapters/indexeddb/typedoc.json
```json
{
     "extends": ["../../../typedoc.base.json"],
     "entryPoints": ["src/index.ts"]
 }
```

## File: persistence-adapters/indexeddb/vite.config.mts
```
/// <reference types="vitest" />
import path from 'path'
import { defineConfig } from 'vite'
import typescript from '@rollup/plugin-typescript'
import { typescriptPaths } from 'rollup-plugin-typescript-paths'
import dts from 'vite-plugin-dts'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [
    dts(),
    tsconfigPaths(),
  ],
  build: {
    manifest: true,
    minify: true,
    sourcemap: true,
    reportCompressedSize: true,
    lib: {
      name: 'SignalDB',
      entry: path.resolve(__dirname, 'src/index.ts'),
      fileName: format => (format === 'es' ? 'index.mjs' : `index.${format}.js`),
    },
    rollupOptions: {
      external: [
        '@signaldb/core',
      ],
      plugins: [
        typescriptPaths({
          preserveExtensions: true,
        }),
        typescript({
          sourceMap: false,
          declaration: true,
          outDir: 'dist',
        }),
      ],
    },
  },
})
```

## File: persistence-adapters/indexeddb/vitest.config.mts
```
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config.mts'

export default mergeConfig(viteConfig, defineConfig({}))
```

## File: persistence-adapters/localstorage/__tests__/adapter.spec.ts
```typescript
// @vitest-environment happy-dom
import type { EventEmitter } from '@signaldb/core'
import { describe, it, expect } from 'vitest'
import { Collection } from '@signaldb/core'
import createLocalStorageAdapter from '../src'

/**
 * Waits for a specific event to be emitted.
 * @param emitter - The event emitter instance.
 * @param event - The event name to wait for.
 * @param [timeout] - Optional timeout in milliseconds.
 * @returns A promise that resolves with the event value.
 */
async function waitForEvent<T>(
  emitter: EventEmitter<any>,
  event: string,
  timeout?: number,
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timeoutId = timeout && setTimeout(() => {
      reject(new Error('waitForEvent timeout'))
    }, timeout)

    emitter.once(event, (value: T) => {
      if (timeoutId) clearTimeout(timeoutId)
      resolve(value)
    })
  })
}

describe('Persistence', () => {
  describe('localStorage', () => {
    it('should load items from localStorage persistence adapter', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')
      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'John' }])
    })

    it('should save items to localStorage persistence adapter', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')
      collection.insert({ id: '1', name: 'John' })
      await waitForEvent(collection, 'persistence.transmitted')
      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'John' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'John' }])
    })

    it('should remove item from localStorage persistence adapter', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }, { id: '2', name: 'Jane' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.removeOne({ id: '1' })
      await waitForEvent(collection, 'persistence.transmitted')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '2', name: 'Jane' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '2', name: 'Jane' }])
    })

    it('should update item in localStorage persistence adapter', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
      await waitForEvent(collection, 'persistence.transmitted')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'Johnny' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'Johnny' }])
    })

    it('should not modify original items in localStorage persistence adapter', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      const originalItems = [{ id: '1', name: 'John' }]
      await persistence.save([], { added: originalItems, removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.insert({ id: '2', name: 'Jane' })
      await waitForEvent(collection, 'persistence.transmitted')

      expect(originalItems).toEqual([{ id: '1', name: 'John' }])
    })

    it('should handle multiple operations in order', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')

      collection.insert({ id: '1', name: 'John' })
      await waitForEvent(collection, 'persistence.transmitted')
      collection.insert({ id: '2', name: 'Jane' })
      await waitForEvent(collection, 'persistence.transmitted')
      collection.removeOne({ id: '1' })
      await waitForEvent(collection, 'persistence.transmitted')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '2', name: 'Jane' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '2', name: 'Jane' }])
    })

    it('should persist data that was modified before persistence.init on client side', { retry: 5 }, async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      collection.insert({ id: '1', name: 'John' })
      collection.insert({ id: '2', name: 'Jane' })
      collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
      collection.removeOne({ id: '2' })
      await waitForEvent(collection, 'persistence.init')

      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'Johnny' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'Johnny' }])
    })

    it('should not overwrite persisted data if items is undefined and changeSet is empty.', async () => {
      const persistence = createLocalStorageAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
      await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
      const collection = new Collection({ persistence })
      await waitForEvent(collection, 'persistence.init')
      await persistence.save([], { added: [], removed: [], modified: [] })
      const items = collection.find().fetch()
      expect(items).toEqual([{ id: '1', name: 'John' }])
      const loadResult = await persistence.load()
      expect(loadResult.items).toEqual([{ id: '1', name: 'John' }])
    })
  })
})
```

## File: persistence-adapters/localstorage/src/index.ts
```typescript
import { createPersistenceAdapter } from '@signaldb/core'

/**
 * Creates a persistence adapter for managing a SignalDB collection using browser `localStorage`.
 * This adapter reads and writes data to `localStorage`, with customizable serialization and deserialization.
 * @template T - The type of the items in the collection.
 * @template I - The type of the unique identifier for the items.
 * @param name - A unique name for the collection, used as the key in `localStorage`.
 * @param options - Optional configuration for serialization and deserialization.
 * @param options.serialize - A function to serialize items to a string (default: `JSON.stringify`).
 * @param options.deserialize - A function to deserialize a string into items (default: `JSON.parse`).
 * @returns A SignalDB persistence adapter for managing data in `localStorage`.
 * @example
 * import createLocalStorageAdapter from './createLocalStorageAdapter';
 *
 * const adapter = createLocalStorageAdapter('myCollection', {
 *   serialize: (items) => JSON.stringify(items, null, 2), // Pretty-print JSON
 *   deserialize: (itemsString) => JSON.parse(itemsString), // Default JSON parse
 * });
 *
 * const collection = new Collection({
 *   persistence: adapter,
 * });
 *
 * // Perform operations on the collection, and changes will be reflected in local storage.
 */
export default function createLocalStorageAdapter<
  T extends { id: I } & Record<string, any>,
  I,
>(
  name: string,
  options?: {
    serialize?: (items: T[]) => string,
    deserialize?: (itemsString: string) => T[],
  },
) {
  const { serialize = JSON.stringify, deserialize = JSON.parse } = options || {}

  const collectionId = `signaldb-collection-${name}`
  /**
   * Retrieves items from localStorage and deserializes them.
   * @returns The deserialized items from localStorage.
   */
  function getItems(): T[] {
    const serializedItems = localStorage.getItem(collectionId)
    return serializedItems ? deserialize(serializedItems) : []
  }
  return createPersistenceAdapter<T, I>({
    async load() {
      const items = getItems()
      return { items }
    },
    async save(_items, { added, modified, removed }) {
      const items = [...getItems()]
      added.forEach((item) => {
        const index = items.findIndex(({ id }) => id === item.id)
        /* istanbul ignore if -- @preserve */
        if (index !== -1) {
          items[index] = item
          return
        }
        items.push(item)
      })
      modified.forEach((item) => {
        const index = items.findIndex(({ id }) => id === item.id)
        /* istanbul ignore if -- @preserve */
        if (index === -1) {
          items.push(item)
          return
        }
        items[index] = item
      })
      removed.forEach((item) => {
        const index = items.findIndex(({ id }) => id === item.id)
        /* istanbul ignore if -- @preserve */
        if (index === -1) return
        items.splice(index, 1)
      })
      localStorage.setItem(collectionId, serialize(items))
      return
    },
    async register() {
      return
    },
  })
}
```

## File: persistence-adapters/localstorage/CHANGELOG.md
```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Fixed

* Custom deserialize function now works correctly when localStorage is empty (thanks to @krolebord!)

## [1.0.1] - 2025-04-24

### Fixed

* Avoid duplicate ids and unnecessary errors

## [1.0.0] - 2024-12-16

### Added

* Added JSDoc comments to public API
```

## File: persistence-adapters/localstorage/package.json
```json
{
  "name": "@signaldb/localstorage",
  "version": "1.0.1",
  "description": "",
  "scripts": {
    "build": "rimraf dist && vite build",
    "analyze-bundle": "bundle-analyzer ./dist --upload-token=$BUNDLE_ANALYZER_UPLOAD_TOKEN --bundle-name=@signaldb/localstorage",
    "test": "vitest"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/maxnowack/signaldb.git"
  },
  "homepage": "https://signaldb.js.org",
  "keywords": [
    "local-storage",
    "client-database",
    "client",
    "database",
    "local-database",
    "offline-first",
    "optimistic-ui",
    "plugin",
    "reactive",
    "reactivity",
    "solid",
    "synchronization",
    "typescript"
  ],
  "author": "Max Nowack <max.nowack@gmail.com>",
  "license": "MIT",
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.umd.js",
      "default": "./dist/index.umd.js"
    }
  },
  "main": "./dist/index.umd.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "typesVersions": {
    "*": {
      "*": [
        "./dist/*",
        "./dist/index.d.ts"
      ]
    }
  },
  "files": [
    "dist"
  ],
  "peerDependencies": {
    "@signaldb/core": "1.x"
  }
}
```

## File: persistence-adapters/localstorage/README.md
```markdown
# @signaldb/localstorage

This is the `localStorage` persistence adapter for [SignalDB](https://github.com/maxnowack/signaldb). SignalDB is a local-first JavaScript database with real-time sync, enabling optimistic UI with signal-based reactivity across multiple frameworks.

See https://signaldb.js.org/reference/localstorage/ for more information.
```

## File: persistence-adapters/localstorage/tsconfig.json
```json
{
  "extends": "../../../tsconfig.json",
  "exclude": [
    "**/*.spec.ts",
  ],
  "include": [
    "src/**/*.ts"
  ]
}
```

## File: persistence-adapters/localstorage/typedoc.json
```json
{
     "extends": ["../../../typedoc.base.json"],
     "entryPoints": ["src/index.ts"]
 }
```

## File: persistence-adapters/localstorage/vite.config.mts
```
/// <reference types="vitest" />
import path from 'path'
import { defineConfig } from 'vite'
import typescript from '@rollup/plugin-typescript'
import { typescriptPaths } from 'rollup-plugin-typescript-paths'
import dts from 'vite-plugin-dts'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [
    dts(),
    tsconfigPaths(),
  ],
  build: {
    manifest: true,
    minify: true,
    sourcemap: true,
    reportCompressedSize: true,
    lib: {
      name: 'SignalDB',
      entry: path.resolve(__dirname, 'src/index.ts'),
      fileName: format => (format === 'es' ? 'index.mjs' : `index.${format}.js`),
    },
    rollupOptions: {
      external: [
        '@signaldb/core',
      ],
      plugins: [
        typescriptPaths({
          preserveExtensions: true,
        }),
        typescript({
          sourceMap: false,
          declaration: true,
          outDir: 'dist',
        }),
      ],
    },
  },
})
```

## File: persistence-adapters/localstorage/vitest.config.mts
```
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config.mts'

export default mergeConfig(viteConfig, defineConfig({}))
```

## File: persistence-adapters/opfs/__tests__/adapter.spec.ts
```typescript
// @vitest-environment happy-dom
import type { EventEmitter } from '@signaldb/core'
import { describe, it, expect } from 'vitest'
import { Collection } from '@signaldb/core'
import createOPFSAdapter from '../src'

/**
 * Waits for a specific event to be emitted.
 * @param emitter - The event emitter.
 * @param event - The event to wait for.
 * @param [timeout] - Optional timeout in milliseconds.
 * @returns A promise that resolves with the event value.
 */
async function waitForEvent<T>(
  emitter: EventEmitter<any>,
  event: string,
  timeout?: number,
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timeoutId = timeout && setTimeout(() => {
      reject(new Error('waitForEvent timeout'))
    }, timeout)

    emitter.once(event, (value: T) => {
      if (timeoutId) clearTimeout(timeoutId)
      resolve(value)
    })
  })
}

describe('OPFS', () => {
  const fileContents: Record<string, string | null> = {}
  const mockedOPFS = {
    getDirectory: () => {
      const opfsRoot = {
        getFileHandle(filename: string, options?: { create: boolean }) {
          if (!Object.hasOwnProperty.call(fileContents, filename)) {
            if (options?.create) {
              fileContents[filename] = null
            } else {
              return Promise.reject(new Error('File not found'))
            }
          }

          const fileHandle = {
            getFile() {
              return Promise.resolve({
                text() {
                  return Promise.resolve(fileContents[filename])
                },
              })
            },
            createWritable() {
              return Promise.resolve({
                write(data: string) {
                  fileContents[filename] = data
                  return Promise.resolve()
                },
                close() {
                  return Promise.resolve()
                },
              })
            },
          }

          return fileHandle
        },
      }
      return Promise.resolve(opfsRoot)
    },
  }

  // @ts-expect-error mocking navigator.storage for testing purposes
  navigator.storage = mockedOPFS

  it('should load items from OPFS persistence adapter', async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
    const collection = new Collection({ persistence })
    await waitForEvent(collection, 'persistence.init')
    const items = collection.find().fetch()
    expect(items).toEqual([{ id: '1', name: 'John' }])
  })

  it('should save items to OPFS persistence adapter', async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    await persistence.save([], { added: [], removed: [], modified: [] })
    const collection = new Collection({ persistence })
    await waitForEvent(collection, 'persistence.init')
    collection.insert({ id: '1', name: 'John' })
    await waitForEvent(collection, 'persistence.transmitted')
    const items = collection.find().fetch()
    expect(items).toEqual([{ id: '1', name: 'John' }])
    const loadResult = await persistence.load()
    expect(loadResult.items).toEqual([{ id: '1', name: 'John' }])
  })

  it('should remove item from OPFS persistence adapter', async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    await persistence.save([], { added: [{ id: '1', name: 'John' }, { id: '2', name: 'Jane' }], removed: [], modified: [] })
    const collection = new Collection({ persistence })
    await waitForEvent(collection, 'persistence.init')

    collection.removeOne({ id: '1' })
    await waitForEvent(collection, 'persistence.transmitted')

    const items = collection.find().fetch()
    expect(items).toEqual([{ id: '2', name: 'Jane' }])
    const loadResult = await persistence.load()
    expect(loadResult.items).toEqual([{ id: '2', name: 'Jane' }])
  })

  it('should update item in OPFS persistence adapter', async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    await persistence.save([], { added: [{ id: '1', name: 'John' }], removed: [], modified: [] })
    const collection = new Collection({ persistence })
    await waitForEvent(collection, 'persistence.init')

    collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
    await waitForEvent(collection, 'persistence.transmitted')

    const items = collection.find().fetch()
    expect(items).toEqual([{ id: '1', name: 'Johnny' }])
    const loadResult = await persistence.load()
    expect(loadResult.items).toEqual([{ id: '1', name: 'Johnny' }])
  })

  it('should not modify original items in OPFS persistence adapter', async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    const originalItems = [{ id: '1', name: 'John' }]
    await persistence.save([], { added: originalItems, removed: [], modified: [] })
    const collection = new Collection({ persistence })
    await waitForEvent(collection, 'persistence.init')

    collection.insert({ id: '2', name: 'Jane' })
    await waitForEvent(collection, 'persistence.transmitted')

    expect(originalItems).toEqual([{ id: '1', name: 'John' }])
  })

  it('should handle multiple operations in order', async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    await persistence.save([], { added: [], removed: [], modified: [] })
    const collection = new Collection({ persistence })
    await waitForEvent(collection, 'persistence.init')

    collection.insert({ id: '1', name: 'John' })
    await waitForEvent(collection, 'persistence.transmitted')
    collection.insert({ id: '2', name: 'Jane' })
    await waitForEvent(collection, 'persistence.transmitted')
    collection.removeOne({ id: '1' })
    await waitForEvent(collection, 'persistence.transmitted')

    const items = collection.find().fetch()
    expect(items).toEqual([{ id: '2', name: 'Jane' }])
    const loadResult = await persistence.load()
    expect(loadResult.items).toEqual([{ id: '2', name: 'Jane' }])
  })

  it('should persist data that was modified before persistence.init on client side', { retry: 5 }, async () => {
    const persistence = createOPFSAdapter(`test-${Math.floor(Math.random() * 1e17).toString(16)}`)
    await persistence.save([], { added: [], removed: [], modified: [] })
    const collection = new Collection({ persistence })
    collection.insert({ id: '1', name: 'John' })
    collection.insert({ id: '2', name: 'Jane' })
    collection.updateOne({ id: '1' }, { $set: { name: 'Johnny' } })
    collection.removeOne({ id: '2' })
    await waitForEvent(collection, 'persistence.init')

    const items = collection.find().fetch()
    expect(items).toEqual([{ id: '1', name: 'Johnny' }])
    const loadResult = await persistence.load()
    expect(loadResult.items).toEqual([{ id: '1', name: 'Johnny' }])
  })
})
```

## File: persistence-adapters/opfs/src/index.ts
```typescript
import { createPersistenceAdapter } from '@signaldb/core'

/**
 * Creates a persistence adapter for managing a SignalDB collection using the
 * Origin Private File System (OPFS). This adapter allows data to be stored and managed
 * directly in the browser's file system with support for customizable serialization
 * and deserialization.
 * @template T - The type of the items in the collection.
 * @template I - The type of the unique identifier for the items.
 * @param filename - The name of the file in OPFS where data will be stored.
 * @param options - Optional configuration for serialization and deserialization.
 * @param options.serialize - A function to serialize items to a string (default: `JSON.stringify`).
 * @param options.deserialize - A function to deserialize a string into items (default: `JSON.parse`).
 * @returns A SignalDB persistence adapter for managing data in OPFS.
 * @example
 * import createOPFSAdapter from './createOPFSAdapter';
 * import { Collection } from '@signaldb/core';
 *
 * const adapter = createOPFSAdapter('myCollection.json', {
 *   serialize: (items) => JSON.stringify(items, null, 2), // Pretty-print JSON
 *   deserialize: (itemsString) => JSON.parse(itemsString), // Default JSON parse
 * });
 *
 * const collection = new Collection({
 *   persistence: adapter,
 * });
 *
 * // Perform operations on the collection, and changes will be reflected in the OPFS file.
 */
export default function createOPFSAdapter<
  T extends { id: I } & Record<string, any>,
  I,
>(
  filename: string,
  options?: {
    serialize?: (items: T[]) => string,
    deserialize?: (itemsString: string) => T[],
  },
) {
  const { serialize = JSON.stringify, deserialize = JSON.parse } = options || {}

  let savePromise: Promise<void> | null = null

  /**
   * Retrieves the items from the OPFS file.
   * @returns A promise that resolves to an array of items.
   */
  async function getItems(): Promise<T[]> {
    const opfsRoot = await navigator.storage.getDirectory()
    const existingFileHandle = await opfsRoot.getFileHandle(filename, { create: true })
    const serializedItems = await existingFileHandle.getFile().then(value => value.text())
    return serializedItems ? deserialize(serializedItems) : []
  }

  return createPersistenceAdapter<T, I>({
    async register(onChange) {
      const opfsRoot = await navigator.storage.getDirectory()
      await opfsRoot.getFileHandle(filename, { create: true })
      void onChange()
    },
    async load() {
      if (savePromise) await savePromise

      const items = await getItems()
      return { items }
    },
    async save(_items, { added, modified, removed }) {
      if (savePromise) await savePromise
      const opfsRoot = await navigator.storage.getDirectory()
      const existingFileHandle = await opfsRoot.getFileHandle(filename, { create: true })
      if (added.length === 0 && modified.length === 0 && removed.length === 0) {
        const writeStream = await existingFileHandle.createWritable()
        await writeStream.write(serialize(_items))
        await writeStream.close()
        await savePromise
        return
      }
      savePromise = getItems()
        .then((currentItems) => {
          const items = [...currentItems]
          added.forEach((item) => {
            const index = items.findIndex(({ id }) => id === item.id)
            /* istanbul ignore if -- @preserve */
            if (index !== -1) {
              items[index] = item
              return
            }
            items.push(item)
          })
          modified.forEach((item) => {
            const index = items.findIndex(({ id }) => id === item.id)
            /* istanbul ignore if -- @preserve */
            if (index === -1) {
              items.push(item)
              return
            }
            items[index] = item
          })
          removed.forEach((item) => {
            const index = items.findIndex(({ id }) => id === item.id)
            /* istanbul ignore if -- @preserve */
            if (index === -1) return
            items.splice(index, 1)
          })
          return items
        })
        .then(async (items) => {
          const writeStream = await existingFileHandle.createWritable()
          await writeStream.write(serialize(items))
          await writeStream.close()
        })
        .then(() => {
          savePromise = null
        })
      await savePromise
    },
  })
}
```

## File: persistence-adapters/opfs/CHANGELOG.md
```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Fixed

* Custom deserialize function now works correctly when file is empty (thanks to @krolebord!)

## [1.0.1] - 2025-04-24

### Fixed

* Avoid duplicate ids and unnecessary errors

## [1.0.0] - 2024-12-16

### Added

* Added JSDoc comments to public API
```

## File: persistence-adapters/opfs/package.json
```json
{
  "name": "@signaldb/opfs",
  "version": "1.0.1",
  "description": "",
  "scripts": {
    "build": "rimraf dist && vite build",
    "analyze-bundle": "bundle-analyzer ./dist --upload-token=$BUNDLE_ANALYZER_UPLOAD_TOKEN --bundle-name=@signaldb/opfs",
    "test": "vitest"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/maxnowack/signaldb.git"
  },
  "homepage": "https://signaldb.js.org",
  "keywords": [
    "opfs",
    "client-database",
    "client",
    "database",
    "local-database",
    "offline-first",
    "optimistic-ui",
    "plugin",
    "reactive",
    "reactivity",
    "solid",
    "synchronization",
    "typescript"
  ],
  "author": "Max Nowack <max.nowack@gmail.com>",
  "license": "MIT",
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.umd.js",
      "default": "./dist/index.umd.js"
    }
  },
  "main": "./dist/index.umd.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "typesVersions": {
    "*": {
      "*": [
        "./dist/*",
        "./dist/index.d.ts"
      ]
    }
  },
  "files": [
    "dist"
  ],
  "peerDependencies": {
    "@signaldb/core": "1.x"
  }
}
```

## File: persistence-adapters/opfs/README.md
```markdown
# @signaldb/opfs

This is the OPFS persistence adapter for [SignalDB](https://github.com/maxnowack/signaldb). SignalDB is a local-first JavaScript database with real-time sync, enabling optimistic UI with signal-based reactivity across multiple frameworks.

See https://signaldb.js.org/reference/opfs/ for more information.
```

## File: persistence-adapters/opfs/tsconfig.json
```json
{
  "extends": "../../../tsconfig.json",
  "exclude": [
    "**/*.spec.ts",
  ],
  "include": [
    "src/**/*.ts"
  ]
}
```

## File: persistence-adapters/opfs/typedoc.json
```json
{
     "extends": ["../../../typedoc.base.json"],
     "entryPoints": ["src/index.ts"]
 }
```

## File: persistence-adapters/opfs/vite.config.mts
```
/// <reference types="vitest" />
import path from 'path'
import { defineConfig } from 'vite'
import typescript from '@rollup/plugin-typescript'
import { typescriptPaths } from 'rollup-plugin-typescript-paths'
import dts from 'vite-plugin-dts'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [
    dts(),
    tsconfigPaths(),
  ],
  build: {
    manifest: true,
    minify: true,
    sourcemap: true,
    reportCompressedSize: true,
    lib: {
      name: 'SignalDB',
      entry: path.resolve(__dirname, 'src/index.ts'),
      fileName: format => (format === 'es' ? 'index.mjs' : `index.${format}.js`),
    },
    rollupOptions: {
      external: [
        '@signaldb/core',
      ],
      plugins: [
        typescriptPaths({
          preserveExtensions: true,
        }),
        typescript({
          sourceMap: false,
          declaration: true,
          outDir: 'dist',
        }),
      ],
    },
  },
})
```

## File: persistence-adapters/opfs/vitest.config.mts
```
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config.mts'

export default mergeConfig(viteConfig, defineConfig({}))
```
</file>

<file path="test-streaming.js">
// Test script for streaming functionality in gmFetchLLM
// This script helps verify that streaming responses work correctly

console.log('=== Testing gmFetchLLM streaming functionality ===');

// Expected behavior with debug logs:
// 1. gmFetchLLM should detect streaming responses (containing 'data: ') at readyState 3
// 2. Console should show: "Streaming detected! Resolving immediately."
// 3. It should resolve immediately with a streaming response object
// 4. The response.body.getReader().read() should return chunks progressively
// 5. Console should show: "Reader.read called, position: X" for each read
// 6. Each chunk should contain part of the streaming data
// 7. Console should show: "Returning chunk of size: X" for each chunk
// 8. When complete, console should show: "Stream complete, returning done."

// MANUAL TESTING STEPS:
// 1. Open browser developer console (F12)
// 2. Load the userscript in a page that uses LLM streaming
// 3. Make a streaming request (e.g., chat with AI)
// 4. Watch console logs for the following sequence:
//    - "onreadystatechange called with readyState: 3, data length: X"
//    - "Streaming detected! Resolving immediately."
//    - "Reader.read called, position: 0"
//    - "Returning chunk of size: X"
//    - (repeat read/chunk logs as data streams)
//    - "Stream marked as complete."
//    - "Stream complete, returning done."

// WHAT TO LOOK FOR:
// ‚úÖ GOOD: Response resolves immediately when first 'data: ' is detected
// ‚úÖ GOOD: Console shows streaming detection and chunk processing logs
// ‚úÖ GOOD: Text appears progressively in the UI (real-time streaming)
// ‚ùå BAD: No "Streaming detected!" message in console
// ‚ùå BAD: Response waits for entire request to complete before showing text
// ‚ùå BAD: No chunk processing logs in console

console.log('üìã Manual testing required:');
console.log('1. Open browser console (F12)');
console.log('2. Load userscript in a page with LLM streaming');
console.log('3. Make a streaming request and watch console logs');
console.log('4. Verify immediate response and progressive text display');
console.log('\nüîç Debug logs to watch for:');
console.log('- "onreadystatechange called with readyState: 3"');
console.log('- "Streaming detected! Resolving immediately."');
console.log('- "Reader.read called, position: X"');
console.log('- "Returning chunk of size: X"');
console.log('- "Stream marked as complete."');
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    
    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "preserve",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
// vite.config.ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import monkey, { cdn } from 'vite-plugin-monkey';
import tailwindcss from '@tailwindcss/vite';
import Components from 'unplugin-vue-components/vite';
import { PrimeVueResolver } from '@primevue/auto-import-resolver';

import { fileURLToPath, URL } from 'url'

export default defineConfig({
  plugins: [
    vue(),
    tailwindcss(),
    Components({
      resolvers: [
        PrimeVueResolver(),
      ],
    }),
    monkey({
      entry: 'src/main.ts',
      userscript: {
        name: 'Mianix RoleplayAI',
        version: '0.1.1', // TƒÉng phi√™n b·∫£n ƒë·ªÉ Tampermonkey c·∫≠p nh·∫≠t
        icon: 'https://mianix.sourman.dev/logo.png',
        namespace: 'sourman.dev/mianix',
        match: ['https://mianix.sourman.dev/roleplay'],

        grant: [
          'GM.getValue',
          'GM.setValue',
          'GM.xmlHttpRequest',
          'GM.addValueChangeListener'
        ],
      },
      build: {
        externalGlobals: {
          vue: cdn.jsdelivr('Vue', 'dist/vue.global.prod.js'),
          'primevue': cdn.jsdelivr('primevue', 'dist/primevue.min.js'),
          // '@primeuix/themes/aura': cdn.jsdelivr('@primeuix/themes', '@1.1.2/+esm'),
        },
      },
    }),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    },
  },
  build: {
    // lib: {
    //   entry: 'src/main.ts',
    //   name: SCRIPT_NAME,
    //   formats: ['iife'],
    // },
    // rollupOptions: {
    //   external: ['vue', '@electric-sql/pglite'],
    //   output: {
    //     globals: {
    //       vue: 'Vue',
    //       // '@electric-sql/pglite': 'PGlite',
    //     },
    //     inlineDynamicImports: true,
    //     extend: true,
    //   },
    // },
    minify: 'terser',
  },

});
</file>

</files>
